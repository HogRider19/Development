Redis представляет собой систему управления базами данных класса `NoSQL` с открытым исходным кодом, работающая со структурами данных типа «`key-value`». Используется как для баз данных, так и для реализации кэшей, брокеров сообщений. Ориентирована на достижение максимальной производительности на атомарных операциях.

Redis держит все данные в оперативной памяти, для уменьшения времени доступа к ним, но в некоторых случаях сохраняет их на диск для обеспечения персистентности. 
Redis хранит данные в виде массива байт и не интересуется их изначальным типом.

По умолчанию, для поддержания персистентности, Redis сохраняет снимки базы данных на диск в зависимости от того, сколько ключей было изменено. По умолчанию, Redis сохраняет базу с интервалами `60` секунд, если изменились более `1000` ключей, и производит сохранение каждые `15` минут, если изменились хотя бы `9` ключей.

Кроме того, Redis может быть запущен в режиме дозаписи `(append mode)`.  В таком случае, каждый раз, когда ключ меняется, на диске дописывается файл с изменениями, открытом в режиме дозаписи. Иногда стоит принять риск потери данных последних `60` секунд в случае аппаратной или программной ошибки в обмен на производительность.

В Redis была реализована поддержка виртуальной памяти. Но эта функция была признана неудачной самими инженерами Redis и ее использование не рекомендуется.  Redis не использует автоматическое сжатие, но, поскольку он трактует данные, как набор байт, можно обменять время обработки на память путем сжатия данных.

Redis также поддерживает конвейерную обработку. Обычно, когда клиент посылает запрос к Redis, он ждет ответа, прежде чем послать следующий запрос. С конвейерной обработкой вы можете посылать несколько запросов без ожидания результата. Это снижает накладные расходы обмена данными и может увеличить производительность.

Для Redis ничего не стоит использовать память для создания очереди запросов, поэтому хорошей идеей будет группировать запросы. Насколько большим будет используемый вами пакет запросов зависит от того, какие команды вы используете, и, что более важно, каков размер их параметров. То, как именно вы исполняете команды в конвейере, будет зависеть от используемого драйвера языка программирования.

Каждая команда Redis атомарная, включая команды, которые делают несколько вещей. Дополнительно, Redis поддерживает транзакции при использовании команд. Redis на самом деле работает в одном потоке, благодаря чему и гарантируется атомарность. Пока исполняется одна команда, остальные команды не могут быть исполнены.
Для создания транзакции команды оборачиваются в вызов `multi` и `exec`.

Если до выполнения `exec` вызвать команду `watch <name>` и наблюдаемое свойство изменится другим конвейером, то вызов `exec` приведет к откату операции. Также транзакцию можно отменить отправкой команды `discard` до вызова `exec`.  

---

Когда вы впервые запустили сервер Redis, он предупредил вас, что файл `redis.conf` не может быть найден. Этот файл может быть использован для настройки различных параметров Redis. Хорошо документированный файл `redis.conf` доступен для каждой версии Redis. Образец файла содержит стандартные варианты конфигурации, что очень полезно для понимания того, для чего предназначены конкретные опции.

Кроме конфигурирования Redis через файл `redis.conf`, команда `config set` может быть использована для задания конкретных опций. Существует также специальная команда `config get`, которая выводит значения параметров конфигурации. 

Redis можно настроить так, чтобы он требовал пароль. За это отвечает специальная опция конфигурации` requirepass`. Когда опция `requirepass` устанавливается в какое-либо значение, клиенты должны выполнять команду `auth password` при обращении.

Как только клиент проходит авторизацию, он может выполнять команды в любой базе данных. В том числе команду `flushall`, которая удаляет все ключи из всех баз. У вас есть возможность переименовать команды или полностью их отключить присвоив пустое значение для обеспечения определенного уровня защиты базы данных.

Redis поддерживает репликацию, которая означает, что все данные, которые попадают на один узел Redis `(master)` будут попадать также и на другие узлы `(slave)`. Для конфигурирования `slave` узлов можно изменить опцию `slaveof`. Узлы, запущенные без подобных опций являются `master` узлами. Репликация помогает защитить ваши данные, копируя их на другие сервера. Репликация также может быть использована для производительности, так как запросы чтения могут обслуживаться `slave` узлами. 

К сожалению, система репликации Redis еще не поддерживает автоматическую отказоустойчивость. Если `master` узел выходит из строя, необходимо вручную  выбрать новый из `slave` узлов. Необходимо использовать традиционные утилиты, использующие мониторинг и специальные скрипты для переключения `master` узлов.

Резервное копирование Redis это просто копирование снимка базы данных Redis в любое место. По умолчанию, Redis сохраняет данные в файл` dump.rdb`. В любой момент времени вы можете скопировать этот файл куда угодно. 

Допускается одновременное отключение сохранения данных на диск и режима дозаписи в файл у `master` узлов и возложение функции резервирования на `slave` узлы. Данный шаг уменьшает нагрузку на` master`  узел и позволяет `slave` узлам использовать более агрессивные настройки сохранения данных.

---

В Redis база данных идентифицируется просто числом, которое по умолчанию 0. Если вы хотите сменить базу данных, то вы можете сделать это командой `select <num>`.  Redis должен ответить сообщением `OK`, подсветив возле указателя номер базы. 

```sh
select <data_base_number>
```

Redis имеет собственную оболочку для подключения к серверу `redis-cli`.  Подключение к этой оболочке производится выполнением команды `redis-cli`.
По умолчанию `Redis` запускается на `6389` порту локального хоста системы. 

```sh
docker exec -it redis_cont_id redis-cli
```

Но производительность Redis обычно измеряется в десятках тысяч или даже сотнях тысяч операций в секунду. Вы можете запустить `redis-benchmark`, чтобы проверить это.

```sh
docker exec -it redis_cont_id redis-benchmark
```

---

Для записи значения по ключу используется команда `set`, а для получения данных используется `get`. Redis также позволяет задавать значение на определенное время.

```sh
set <name> <value>
set <name> <value> ex <ex_seconds>
get <name>
del <name>
```

Дополнительно, Redis позволяет выполнять некоторые стандартные действия. Например, `strlen` используется для вычисления длины значения; `getrange` возвращает подстроку из строки; `append` добавляет введенное значение к концу.
Также есть команды для инкрементирования и декрементирования значений.  

```sh
strlen <name>
getrange <name> <start_index> <stop_index>
append <name> <append_value>

incr <name>
decr <name>
```

---

Хеши во многом похожи на строки. Важным отличием является то, что они предоставляют дополнительный уровень адресации данных поля `(fields)`.

Хеши дают чуть больше контроля, чем строки. Вместо того, чтобы хранить данные о пользователе в виде одного сериализованного значения, мы можем использовать хеш для более точного представления. Преимуществом будет возможность извлечения, изменения и удаления отдельных частей данных без необходимости полного чтения.

```sh
hset <name> <field> <value>
hget <name> <field>

hkeys <name>
hdel <name> <field>
```

---

Списки позволяют хранить и манипулировать массивами значений для заданного ключа. Можно добавлять значения в список, получать первое и последнее значение из списка и манипулировать значениями с заданными индексами. Списки сохраняют порядок своих значений и имеют эффективные операции с использованием индексов.

```sh
rpush <name> <value1> <value2> ...       // Добавлене в начало
lpush <name> <value1> <value2> ...       // Добавлене в конец

ltrim <name> <start_index> <stop_index>  // Присвоение левым срезом
rtrim <name> <start_index> <stop_index>  // Присвоение парвым срезом

lrange <name> <start_index> <stop_index> // Получение среза
lrange <name> 0 -1                       // Получение всего списка

lpop <name>                              // Левое удаление
rpop <name>                              // Парвое удаление

lrem <name> <start_index> <stop_index>   // Удаление среза
rrem <name> <start_index> <stop_index>   // Удаление среза
```

---

Множества используются для хранения уникальных значений и предоставляют набор операций. Множества не упорядочены, но предоставляют эффективные операции со значениями. Список друзей является классическим примером использования множеств.

```sh
sadd <name> <value1> <value2> ...       // Добавление в множество
srem <name> <value1> <value2> ...       // Удаление из множества

sismember <name> <value>                // Проверка на вхождение
smember <name>                          // Получение всех элементов

sinter <name1> <name2> ...              // Пересечение множеств
sunion <name1> <name2> ...              // Объединение множеств
```

---

Redis поддерживает публикацию сообщений и подписку на каналы как на объекты первого класса (То есть эти объекты можно создавать, изменять, удалять и так далее).

```sh
subscribe <name1> ...          // Подписка на каналы
unsubscribe <name>             // Отписка от канала
publish <name> <value>         // Отправка в канал
```
