Представления в `AspNetCoreMvc` может содержать не только стандартный код `html`, но и также вставки кода на языке `C#`. Для обработки кода, который содержит как элементы 
`html`, так и конструкции языка `C#`, применяется движок представлений `Razor`.

В действительности при вызове метода `View` контроллер не производит рендеринг представления и не генерирует разметку` html`. Контроллер только готовит данные и выбирает, какое представление надо возвратить в качестве объекта `ViewResult`. Затем
уже объект `ViewResult` обращается к движку представления для рендеринга представления.

По умолчанию в `AspNetCoreMvc` применяется один движок представлений `Razor`. Хотя при желании мы можем также использовать какие-то другие сторонние движки или создать свой движок. Цель движка представлений `Razor` определить переход разметки `html` к коду `C#`.
Синтаксис `Razor` довольно прост все его конструкции предваряются символом `@`, после которого происходит переход к коду `C#`. Например, можем использовать конструкцию:

```C#
<h2>Time: @DateTime.Now.ToShortTimeString()</h2>
<p>@(20 + 30)</p>
```

Все конструкции `Razor` можно разделить на два вида: однострочные выражения и блоки кода. Блоки кода могут иметь несколько выражений. Блок кода заключается в фигурные скобки, а каждое выражение завершается точкой с запятой аналогично блокам в `C#`:

```c#
@{
    string head = "Hello METANIT.COM!"; // определяем переменную head
    string text = "ASP.NET Core Application";   // определяем переменную text
}

<h2>@head</h2> <!-- используем переменную head -->
<div>@text</div> <!-- используем переменную text -->
```

Если необходимо вывести значение переменной без каких либо `html` элементов,
то мы можем использовать специальный зарезервированный `Razor` тэг `<text>`:

```c#
@{
    int i = 8;
    <text>@i</text>
}
<text>@(i+1)</text>
```

Также `Razor` поддерживает и другие полезные конструкции генерации кода, такие
как условные конструкции, циклы кода, а также использование оператора `switch`:

```c#
@if (hour < 12)
{
    <h2>@morning</h2>
}
else if (hour > 17)
{
    <h2>@evening</h2>
}
else
{
    <h2>@hello</h2>
}
```

```c#
@{
    string[] people = { "Tom", "Sam", "Bob" };
}

<ul>
    @for (var i = 0; i < people.Length; i++)
    {
        <li>@people[i]</li>
    }
</ul>
```

```c#
@{
    string[] people = { "Tom", "Sam", "Bob" };
    var i = 0;
}
<ul>
    @while ( i < people.Length)
    {
        <li>@people[i++]</li>
    }
</ul>
```

```c#
@try
{
    throw new InvalidOperationException("Something wrong");
}
catch (Exception ex)
{
    <p>Exception: @ex.Message</p>
}
finally
{
    <p>finally</p>
}
```

С использованием оператора `@:` мы можем вывести текст на `html` страницу
внутри выделенного блока кода Razor. Для примера, можно сделать так: 

```c#
@{
    bool isEnabled = true;
}
@if (isEnabled)
{
    @: Hello
}
```

Директива `@functions` позволяет определить блок кода `Razor`, в котором можно определить функции, которые могут применяться в представлении. Например:

```c#
@functions
{
    public int Sum(int a, int b) 
    {
        return a + b;
    }
    
    public int Square(int n) => n * n;
}
<p>Sum of 5 and 4: <b> @Sum(5, 4)</b></p>
<p>Square of 4: <b>@Square(4)</b></p>
```

---
Установка типа модели, требуемой для представления, производится через `@model`. После передачи модели, она будет доступна через `@Model`. Сама модель передается в контроллере.

```c#
@model <ModelType>
@Model // Переданная модель
```

```c#
public IActionResult Index()
{
    var people = new List<string> { "Tom", "Sam", "Bob" };
    return View(people);
}
```

```c#
@model List<string>
 
<h2>Count: @Model.Count</h2>
<ul>
@foreach(string person in Model)
{
    <li>@person</li>
}
</ul>
```

---

Мастер страницы `layout` позволяют задать единый шаблон для представлений. По сути `layout` это те же самые представления, которые могут включать  другие представления. Например, можно определить на `layout` общие для всех остальных представлений меню,
а также подключить общие стили и скрипты. В итоге нам не придется на каждом отдельном представлении прописывать путь к файлам стилей, а потом при необходимости изменять. 
А специальные теги позволяют вставлять в определенное место другие представления.

```c#
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>METANIT.COM | @ViewBag.Title</title>
</head>
<body>
    <h2>@ViewBag.Title</h2>
    <div><a href="/Home/Index">Home</a> | <a href="/Home/About">About</a></div>
    <div>
        @RenderBody()
    </div>
</body>
</html>
```

Главное же отличие от обычных представлений состоит в использовании метода `@RenderBody()`, который является плейсхолдером и на место которого потом будут подставляться другие представления, использующие данную страницу. В итоге мы
сможем легко установить для всех представлений единообразное оформление.

```c#
@{
    ViewBag.Title = "Index";
    Layout = "/Views/Shared/_Layout.cshtml";
}
<h3>Index Content</h3>
```

Свойство `Layout` необязательно каждый раз задавать. Для этого мы можем воспользоваться файлом `_ViewStart.cshtml`, который определяет общие свойства для всех представлений.

```c#
@{
    Layout = "_Layout";
}
```

Если в обеих папках: и в `/Views/[Название_контроллера]`, и в `/Views/Shared/` имеется файл с одинаковым именем, например, `_Layout.cshtml`, то к представлению применяется файл, который находится с ним в одной папке как более приоритетный. То есть таким образом
мы можем определить для представлений каждого контроллера свою мастер страницу.
Мы можем не использовать мастер страницу, тогда нужно установить `Layout` в `null`.

Если вдруг мы хотим глобально по всему проекту поменять мастер страницу на другой файл, который расположен в какой-то другой папке, например, в корне каталога `Views`, то нам надо использовать полный путь к файлу в файле общего кода `_ViewStart.cshtml`:

```c#
@{
    Layout = "~/Views/_Layout.cshtml";
}
```

Кроме метода `RenderBody()`, который вставляет основное содержимое представлений, `Layout` может также использовать специальный метод `RenderSection()` для вставки секций. `Layout` может иметь несколько секций, куда можно поместить свой код.
Например, добавим к мастер странице `_Layout.cshtml` добавим `footer`:


```c#
<h1>METANIT.COM | @ViewBag.Title</h1>
<div>@RenderBody()</div>
<footer>@RenderSection("Footer")</footer>
```

```c#
@{
    ViewBag.Title = "Index";
}
</h3>Index Content</h3>
 
@section Footer {
   Copyright© Metanit.com, @DateTime.Now.Year. All rights reserved
}
```

Но при таком подходе, если у нас есть куча представлений, и мы вдруг захотели определить новую секцию на `Layout`, нам придется изменить все имеющиеся представления, что не очень удобно. В этом случае мы можем воспользоваться вариантом настройки секций.

Первый вариант заключается в использовании перегруженной версии `RenderSection`, которая позволяет указать, что данную секцию не обязательно определять в представлении. Чтобы отметить секцию `Footer` в качестве необязательной, надо передать в метод `false`.

```c#
<footer>@RenderSection("Footer", false)</footer>
```

Второй вариант гибкой настройки секций позволяет задать содержание секции по умолчанию, она отобразиться, если данная секция не определена в представлении:

```c#
<footer>
    @if (IsSectionDefined("Footer"))
    {
        @RenderSection("Footer")
    }
    else
    {
        <span>Содержание элемента footer по умолчанию.</span>
    }
</footer>
```

---

Файл `_ViewImports.cshtml` позволяет по умолчанию подключить некоторый функционал. Сначала рассмотрим ситуацию: пусть у нас в проекте определен некоторый класс `Person`:

```c#
namespace MvcApp
{
    public record class Person(string Name, int Age);
}
```

```c#
@using MvcApp @* Подключаем пространство имен класса Person *@
@{
    Layout = null;
    Person tom = new Person("Tom", 37);
}
<h2>Person Data</h2>
<h3>Name: @tom.Name</h3>
<h3>Age: @tom.Age</h3>
```

Чтобы использовать тип `Person` в представлении, мы вынуждены импортировать с помощью директивы `using` пространство имен, где этот тип определен. В данном случае ничего сложного нет, однако если у нас куча представлений, где мы хотим использовать этот же тип `Person`, то мы будем вынуждены определить то же самое выражение импорта всех представлениях. Это может создавать некоторые неудобства. Во-первых, мы повторяем один и тот же код. Во-вторых, если пространство имен изменится, то мы вынуждены будем менять все представления. Использование файла `_ViewImports.cshtml `решает эту проблему.

Для каждой группы представлений в одной папке мы можем определить свой импорты. Например, если мы хотим отдельно подключать ряд пространств имен только в контроллер `HomeController`, тогда нам надо добавить импорты в каталог контроллера `Views/Home`.

И в этом случае все директивы и выражения из файла `Views/Home/_ViewImports.cshtml` будут применяться к представлениям только из папки `Views/Home`. Кроме того, ко всем представлениям во всех папках продолжит применяться глобальный файл импортов.