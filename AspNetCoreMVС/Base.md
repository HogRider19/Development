Фреймворк `AspNetCoreMVC` является частью платформы `AspNetCore`, его отличительная особенность применение паттерна `MVC`. Преимуществом использования `AspNetCoreMVC` 
по сравнению с чистым `AspNetCore` является то, что он упрощает в ряде ситуаций и сценариев организацию и создание приложений, особенно при большом масштабе.

Стоит отметить, что паттерн `MVC` не является исключительной особенностью `AspNetCore`, данный паттерн появился еще в конце `1970` годов в компании `Xerox` для организации компонентов в графическом приложение на языке `Smalltalk` и в настоящее время применяется во многих платформах и для различных языках программирования.
Концепция `MVC` предполагает разделение приложения на три компонента:

==**Model**==. Описывает используемые в приложении данные, а также логику, которая связана непосредственно с данными, например, логику валидации данных. Как правило, объекты моделей хранятся в базе данных. В `MVC` модели представлены двумя основными типами: модели представлений, которые используются представлениями для отображения и передачи данных, и модели домена, которые описывают логику управления данными.

Модель может содержать данные, хранить логику управления этими данными. В то же
время модель не должна содержать логику взаимодействия с пользователем и не должна осуществлять обработку запроса. Еще модель не должна отображать данные представления.

**==View==**. Отвечают за визуальную часть или пользовательский интерфейс, к примеру,
`Html` страница, через которую пользователь взаимодействует с приложением. Также представление может содержать логику, связанную с отображением данных. В то же время представление не должно содержать логику обработки запроса или управления данными.

**==Controller==**. Представляет центральный компонент `MVC`, который обеспечивает связь между пользователем и приложением, представлением и хранилищем данных. Он содержит логику обработки запроса пользователя. Контроллер получает вводимые пользователем данные
и обрабатывает их. И в зависимости от результатов обработки отправляет пользователю определенный вывод, например, в виде представления, наполненного данными моделей.

![[Pasted image 20250705190901.png]]

В этой схеме модель является независимым компонентом, любые изменения контроллера или представления никак не влияют на модель. Контроллер и представление являются относительно независимыми компонентами. Так, из представления можно обращаться
к определенному контроллеру, а из контроллера генерировать представления, но при 
этом нередко их можно изменять независимо друг от друга в кодовой базе приложения.

Такое разграничение компонентов приложения позволяет реализовать концепцию разделение ответственности, при которой каждый компонент отвечает за свою строго очерченную сферу. В связи с чем легче построить работу над отдельными компонентами. 
И благодаря этому приложение легче разрабатывать и поддерживать. Допустим, если нам важна визуальная часть или фронтэнд, то мы можем тестировать представление независимо от контроллера. Либо мы можем сосредоточиться на бэкэнде и тестировать контроллер.

---

Для добавления функциональности `Mvc` нужно подключить нужные сервисы, используя метод расширения коллекции сервисов `services.AddControllersWithViews()`. После
этого мы можем использовать функциональность фреймворка `MVC` в виде сервисов.

Кроме того, чтобы связать приходящие от пользователей запросы с контроллерами применяется метод `MapControllerRoute()`. Через первый параметр `name` в метод передается название маршрута в данном случае `default`. Через второй параметр
параметр `pattern` передается шаблон, которому должен соответствовать запрос. 

В качестве шаблона маршрута применяется `{controller=Home}/{action=Index}/{id?}`, который представляет трехсегментный запрос. В нем первый сегмент представляет контроллер, второй сегмент метод контроллера, а третий необязательный параметр.
При этом если в запросе не указаны сегменты например, обращение идет к корню приложения, то тогда в качестве контроллера применяется `HomeController/Index`.

```c#
var builder = WebApplication.CreateBuilder(args);

// Добавляем сервисы MVC
builder.Services.AddControllersWithViews();
 
var app = builder.Build();
 
// устанавливаем сопоставление маршрутов с контроллерами
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
 
app.Run();
```

---
---
---


**AspNetCore MVC** - фреймворк, который является частью платформы AspNetCore, его отличительная особенность - применение паттерна MVC. Преимуществом использования фреймворка является то, что он упрощает в ряде ситуаций и сценариев организацию и создание приложений, особенно это относится к большим приложениям

**AddMvc()** - добавляет все сервисы фреймворка MVC
**AddMvcCore()** - добавляет только основные сервисы фреймворка
**AddControllersWithViews()** - добавляет только сервисы организации 
**AddControllers()** - позволяет использовать только контроллеры

---

**Модель (Model)** - описывает используемые в приложении данные, а также логику, которая связана непосредственно с данными, например, логику валидации данных. Как правило, объекты моделей хранятся в базе данных.

В MVC модели представлены двумя основными типами: модели представлений, которые используются представлениями для отображения и передачи данных, и модели домена, которые описывают логику управления данными.

Модель может содержать данные, хранить логику управления этими данными. В то же время модель не должна содержать логику взаимодействия с пользователем и не должна определять механизм обработки запроса. Кроме того, модель не должна содержать логику отображения данных в представлении.

**Представление (View)** - отвечают за визуальную часть или пользовательский интерфейс, через который пользователь взаимодействует с приложением. Также представление может содержать логику, связанную с отображением данных. В то же время представление не должно содержать логику обработки запроса пользователя или управления данными.

**Контроллер (Controller)** - представляет центральный компонент MVC, который обеспечивает связь между пользователем и приложением, представлением и хранилищем данных. Он содержит логику обработки запроса пользователя. Контроллер получает вводимые пользователем данные и обрабатывает их. И в зависимости от результатов обработки отправляет пользователю определенный вывод, например, в виде представления, наполненного данными моделей