---

---
Основным элементом в архитектуре `AspNetCoreMvc` является контроллер. При получении запроса система маршрутизации выбирает для обработки запроса нужный контроллер и передает данные запроса. Контроллер обрабатывает его и посылает обратно результат.

При использовании контроллеров существуют некоторые условности. Обычно 
в проекте контроллеры помещаются в каталог `Controllers`. Однако это в принципе необязательно можно добавлять контроллеры в другие папки или даже в корень проекта.

В `AspNetCoreMvc` контроллер представляет обычный класс на языке `C#`, который обычно наследуется от абстрактного базового класса `Microsoft.AspNetCore.Mvc.Controller` и который, как и любой класс на языке `C#`, может иметь поля, свойства, методы. Согласно соглашениям об именовании названия контроллеров обычно оканчиваются на суффикс `Controller`, остальная же часть до этого суффикса считается именем контроллера, например, `HomeController`. Но в принципе эти условности также необязательны.

Но есть также и обязательные условности, которые предъявляются к контроллерам. В частности, класс контроллера должен удовлетворять как минимум одному из условий:

```c#
// 1) Класс контроллера имеет суффикс "Controller"
public class HomeController { }

// 2) Класс контроллера наследуется от класса, который имеет суффикс "Controller"
public class Home : Controller { }

// 3) К классу контроллера применяется атрибут [Controller]
[Controller]
public class Home { }
```

Ключевым элементом контроллера являются его действия. Действия контроллера представляют собой публичные методы, которые могут сопоставляться с запросами. Например, возьмем контроллер `HomeController` и определим в нем метод `Index`:

```c#
public class HomeController : Controller
{
	public string Index()
	{
		return "Hello METANIT.COM";
	}
}
```

Сопоставление запроса с контроллером и его действием происходит благодаря системе маршрутизации. И для настройки сопоставления используется метод `MapControllerRoute`":

```c#
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

В качестве шаблона маршрута применяется `{controller=Home}/{action=Index}/{id?}`, который представляет трехсегментный запрос. В нем первый сегмент представляет контроллер, второй сегмент метод контроллера, а третий необязательный параметр.
При этом если в запросе не указаны сегменты например, обращение идет к корню приложения, то тогда в качестве контроллера применяется `HomeController/Index`.

Собственно поэтому система может соотнести запрос типа `localhost:xxxx/Home/Index`
с контроллером и его действием. Чтобы обратиться контроллеру из веб-браузера, нам
надо в адресной строке набрать `адрес_сайта/Имя_контроллера/Действие_контроллера`. 

Однако не все методы контроллера являются действиями. Контроллер также может иметь непубличные методы  такие методы не рассматриваются системой как действия контроллера.

Возможно, сопоставление по умолчанию бывает не всегда удобно. Например, у нас есть класс в папке `Controllers`, но мы не хотим, чтобы он мог обрабатывать запрос. Чтобы указать, что этот класс не является контроллером, нам нужен атрибут `[NonController]`.

```c#
[NonController]
public class HomeController : Controller { }
```

Аналогично, если мы хотим, чтобы какой-либо публичный метод контроллера не рассматривался как действие, то мы можем использовать атрибут `[NonAction]`
Атрибут `[ActionName]` позволяет для метода задать другое имя действия:

```c#
[NonAction]
public string Hello() => "Hello ASP.NET";

[ActionName("Welcome")]
public string Hello() => "Hello ASP.NET";
```

Кроме того, методы могут обслуживать разные типы запросов. Для указания типа запроса `HTTP` нам надо применить к методу один из атрибутов: `[HttpGet]`, `[HttpPost]`, `[HttpPut]`, `[HttpPatch]`, `[HttpDelete]` и `[HttpHead]`. Если атрибут явным образом не указан, то метод может обрабатывать все перечисленные типы `Http` запросов: `GET`, `POST`, `PUT`, `DELETE`.

```c#
public class HomeController : Controller
{
	[HttpGet]
	public string Index() => "Hello METANIT.COM";
	
	[HttpPost]
	public string Hello() => "Hello ASP.NET";
}
```

---

При обращении к контроллеру среда `AspNetCore` создает для этого контроллера контекст, который содержит различные связанные с контроллером данные. Для получения контекста
в классе контроллера нам доступно свойство `ControllerContext`, которое представляет одноименный класс `ControllerContext`. Этот класс определяет ряд важный свойств:

```c#
public IActionResult Index()
{
	// Содержит информацию о контексте запроса
	var httpContext = ControllerContext.HttpContext;
	
	// Возвращает дескриптор действия - объект ActionDescriptor,
	// который описывает вызываемое действие контроллера
	var actionDescriptor = ControllerContext.ActionDescriptor;
	
	// Возвращает словарь ModelStateDictionary, который
	// используется для валидации данных, отправленных пользователем
	var modelState = ControllerContext.ModelState;
	
	// Возвращает данные маршрута
	var routeData = ControllerContext.RouteData;
	
	return View();
}

public abstract class ControllerBase  
{
	public HttpContext HttpContext => ControllerContext.HttpContext;
    public HttpRequest Request => HttpContext?.Request!;
    public HttpResponse Response => HttpContext?.Response!;
    public RouteData RouteData => ControllerContext.RouteData;
    public ModelStateDictionary ModelState => ControllerContext.ModelState;
}
```

Действие контроллера по факту представляет собой конечную точку. Из-за этого действие контроллера позволяет записывать результат с использованием подхода через `Responce`.

---
---
---

**Контроллер** - основным элементом в архитектуре mvc. При получении запроса система маршрутизации выбирает для обработки запроса нужный контроллер и передает ему данные запроса. Контроллер обрабатывает эти данные и посылает обратно результат обработки

В AspNetCore MVC контроллер представляет обычный класс, который обычно наследуется от класса Microsoft.AspNetCore.Mvc.Controller.

Класс контроллера должен удовлетворять как минимум одному из следующих условий:

1. Класс контроллера имеет суффикс "Controller"
2. Класс контроллера наследуется от класса, с суффиксом "Controller"
3. К классу контроллера применяется атрибут \[Controller]

---

### Действия контроллера

**Действия контроллера** - это публичные методы, которые могут сопоставляться с запросами. Является основной частью контроллера

Сопоставление запроса с контроллером и его действием происходит благодаря системе маршрутизации в Program.cs

Однако не все методы контроллера являются действиями. Контроллер может иметь непубличные методы - такие методы не рассматриваются как действия и соответственно не соотноситься с запросами

**\[Controller]** - указывает, что класс является контроллером
**\[NonController]** - указывает, что класс не является контроллером
**\[NonAction]** - указывает, что метод не является действием
**\[ActionName]** - переопределяет имя действия

Кроме того, методы могут обслуживать разные типы запросов. Для указания типа запроса нам надо применить к методу один из атрибутов: \[HttpGet], \[HttpPost], \[HttpPut], \[HttpPatch], \[HttpDelete]. Если атрибут не указан, то метод может обрабатывать все типы запросов

---

### Контекст контроллера

При обращении к контроллеру среда создает для него контекст, который содержит связанные с контроллером данные. Для получения контекста в классе контроллера есть свойство ControllerContext, которое представляет одноименный класс ControllerContext

## Свойства ControllerContext:

1. **RouteData:** возвращает данные маршрута
2. **HttpContext:** содержит информацию о контексте запроса
3. **ActionDescriptor:** возвращает дескриптор действия контроллера
4. **ModelState:** возвращает словарь ModelStateDictionary, который используется для валидации данных, отправленных пользователем

## Свойства HttpContext:

1. **Request:** содержит собственно информацию о текущем запросе.
2. **Response:** управляет ответом
3. **User:** представляет текущего пользователя
4. **Session:** объект для работы с сессиями

---

### Результаты действий

**ActionResult** - абстрактный класс результата действия контроллера

**ContentResult** - отправляет в ответ в виде строки
**EmptyResult** - отправляет пустой ответ в виде статусного кода 200
**NoContentResult** - отправляет пустой ответ в виде статусного кода 204 
**FileResult** - базовый для результатов записи потока данных
**FileContentResult:** FileResult, пишет в ответ массив байтов
**VirtualFileResult:** FileResult, пишет в ответ массив байтов по пути
**FileStreamResult:** FileResult, пишет бинарный поток в выходной ответ
**StatusCodeResult:** возвращает клиенту определенный статусный код
**UnauthorizedResult**: возвращает клиенту ответ 401 
**NotFoundResult:** возвращает клиенту ответ 404
**BadRequestResult:** возвращает клиенту ответ 400 
**OkResult:** возвращает клиенту ответ 200 
**CreatedResult:** возвращает клиенту ответ 201 
**AcceptedResult:** возвращает статусный код 202
**ChallengeResult:** используется для проверки аутентификации
**JsonResult:** возвращает в качестве ответа объект в формате JSON 
**RedirectResult:** возвращает статусный код 301 или 301 
**RedirectToActionResult:** выполняет переадресацию на действие
**PartialViewResult:** производит рендеринг View в выходной поток 
**ViewComponentResult:** возвращает в ответ сущность ViewComponent
**ViewResult:** производит рендеринг представления и отправляет результаты рендеринга в виде html-страницы клиенту




---

### Переопределение контроллеров

Как правило, для создания контроллера достаточно унаследовать свой класс от базового класса Controller. Однако если нам необходимо, чтобы наши контроллеры реализовали некоторую общую логику, мы можем определить свой базовый класс контроллера и уже от него наследовать остальные контроллеры. Либо мы также можем переопределить некоторые методы базового класса Contro ller

**OnActionExecuting()** - метод выполняется при вызове метода контроллера до его непосредственного выполнения. В качестве параметра принимает объект типа ActionExecutingContext

**OnActionExecuted()** - метод выполняется после выполнения метода контроллера. В качестве параметра принимает ActionExecutedContext