Представления в `AspNetCoreMvc` может содержать не только стандартный код `html`, но и также вставки кода на языке `C#`. Для обработки кода, который содержит как элементы 
`html`, так и конструкции языка `C#`, применяется движок представлений `Razor`.

В действительности при вызове метода `View` контроллер не производит рендеринг представления и не генерирует разметку` html`. Контроллер только готовит данные и выбирает, какое представление надо возвратить в качестве объекта `ViewResult`. Затем
уже объект `ViewResult` обращается к движку представления для рендеринга представления.

По умолчанию в `AspNetCoreMvc` применяется один движок представлений `Razor`. Хотя при желании мы можем также использовать какие-то другие сторонние движки или создать свой движок. Цель движка представлений `Razor` определить переход разметки `html` к коду `C#`.
Синтаксис `Razor` довольно прост все его конструкции предваряются символом `@`, после которого происходит переход к коду `C#`. Например, можем использовать конструкцию:

```C#
<h2>Time: @DateTime.Now.ToShortTimeString()</h2>
<p>@(20 + 30)</p>
```

Все конструкции `Razor` можно разделить на два вида: однострочные выражения и блоки кода. Блоки кода могут иметь несколько выражений. Блок кода заключается в фигурные скобки, а каждое выражение завершается точкой с запятой аналогично блокам в `C#`:

```c#
@{
    string head = "Hello METANIT.COM!"; // определяем переменную head
    string text = "ASP.NET Core Application";   // определяем переменную text
}

<h2>@head</h2> <!-- используем переменную head -->
<div>@text</div> <!-- используем переменную text -->
```

Если необходимо вывести значение переменной без каких либо `html` элементов,
то мы можем использовать специальный зарезервированный `Razor` тэг `<text>`:

```c#
@{
    int i = 8;
    <text>@i</text>
}
<text>@(i+1)</text>
```

Также `Razor` поддерживает и другие полезные конструкции генерации кода, такие
как условные конструкции, циклы кода, а также использование оператора `switch`:

```c#
@if (hour < 12)
{
    <h2>@morning</h2>
}
else if (hour > 17)
{
    <h2>@evening</h2>
}
else
{
    <h2>@hello</h2>
}
```

```c#
@{
    string[] people = { "Tom", "Sam", "Bob" };
}

<ul>
    @for (var i = 0; i < people.Length; i++)
    {
        <li>@people[i]</li>
    }
</ul>
```

```c#
@{
    string[] people = { "Tom", "Sam", "Bob" };
    var i = 0;
}
<ul>
    @while ( i < people.Length)
    {
        <li>@people[i++]</li>
    }
</ul>
```

```c#
@try
{
    throw new InvalidOperationException("Something wrong");
}
catch (Exception ex)
{
    <p>Exception: @ex.Message</p>
}
finally
{
    <p>finally</p>
}
```

С использованием оператора `@:` мы можем вывести текст на `html` страницу
внутри выделенного блока кода Razor. Для примера, можно сделать так: 

```c#
@{
    bool isEnabled = true;
}
@if (isEnabled)
{
    @: Hello
}
```

Директива `@functions` позволяет определить блок кода `Razor`, в котором можно определить функции, которые могут применяться в представлении. Например:

```c#
@functions
{
    public int Sum(int a, int b) 
    {
        return a + b;
    }
    
    public int Square(int n) => n * n;
}
<p>Sum of 5 and 4: <b> @Sum(5, 4)</b></p>
<p>Square of 4: <b>@Square(4)</b></p>
```

---
Установка типа модели, требуемой для представления, производится через `@model`. После передачи модели, она будет доступна через `@Model`. Сама модель передается в контроллере.

```c#
@model <ModelType>
@Model // Переданная модель
```

```c#
public IActionResult Index()
{
    var people = new List<string> { "Tom", "Sam", "Bob" };
    return View(people);
}
```

```c#
@model List<string>
 
<h2>Count: @Model.Count</h2>
<ul>
@foreach(string person in Model)
{
    <li>@person</li>
}
</ul>
```

---

Мастер страницы `layout` позволяют задать единый шаблон для представлений. По сути `layout` это те же самые представления, которые могут включать  другие представления. Например, можно определить на `layout` общие для всех остальных представлений меню,
а также подключить общие стили и скрипты. В итоге нам не придется на каждом отдельном представлении прописывать путь к файлам стилей, а потом при необходимости изменять. 
А специальные теги позволяют вставлять в определенное место другие представления.

```c#
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>METANIT.COM | @ViewBag.Title</title>
</head>
<body>
    <h2>@ViewBag.Title</h2>
    <div><a href="/Home/Index">Home</a> | <a href="/Home/About">About</a></div>
    <div>
        @RenderBody()
    </div>
</body>
</html>
```

Главное же отличие от обычных представлений состоит в использовании метода `@RenderBody()`, который является плейсхолдером и на место которого потом будут подставляться другие представления, использующие данную страницу. В итоге мы
сможем легко установить для всех представлений единообразное оформление.

```c#
@{
    ViewBag.Title = "Index";
    Layout = "/Views/Shared/_Layout.cshtml";
}
<h3>Index Content</h3>
```