Обычно при обращении к веб приложению пользователь ожидает получить веб страницу
с какими-нибудь данными. В `MVC` для этого, как правило, используются представления, которые определяют внешний вид приложения и на основе которых потом формируется страница. В `AspNetCoreMvs` представления это файлы с расширением `cshtml`, которые содержат код пользовательского интерфейса в основном на языке `html`, а также  `Razor`
конструкции движка представлений, которые позволяют переходить к коду на языке `C#`.

Для хранения представлений в проекте `AspNetCoreMvs` предназначена папка `Views`.
Но при желании этот путь можно сменить через конфигурацию сервисов `MVC`.

```c#
builder.Services.AddControllersWithViews()
    .AddRazorOptions(options =>
    {
        // {1} - контроллер, {0} - имя представления
        options.ViewLocationFormats.Add("/CustomViews/{1}/{0}.cshtml"); 
    });
```

Как правило, для каждого контроллера в проекте создается подкаталог в директории `Views`, который называется по имени контроллера и который хранит представления, используемые методами данного контроллера. Так, по умолчанию имеется контроллер `HomeController` и для него в папке `Views` есть подкаталог `Home` с представлениями для методов контроллера. Также здесь есть папка `Shared`, которая хранит общие представления  контроллеров. По умолчанию там есть `_Layout.cshtml` для мастер страницы, `Error.cshtml` для отображения ошибок и `_ValidationScripsPartial.cshtml` для подключения скриптов валидации форм.
Также в корне каталога есть `ViewImports.cshtml` определяющий общие импорты `Views`
и `_ViewStart.cshtml` который устанавливает общую мастер-страницу для всех `Views`. 

За работу с представлениями отвечает объект `ViewResult`. Он производит рендеринг представления в веб-страницу и возвращает ее в виде ответа клиенту. Чтобы возвратить объект `ViewResult`, в методе контроллера вызывается метод `View`. Вызов метода `View` возвращает объект `ViewResult`. Затем уже `ViewResult` производит рендеринг нужного представления в ответ. По умолчанию контроллер производит поиск представления так:

```
/Views/Имя_контроллера/Имя_представления.cshtml
/Views/Shared/Имя_представления.cshtml
```

Чтобы возвратить объект `ViewResult`, который производит рендеринг представления в веб-страницу и возвращает ее в виде ответа клиенту, используется метод `View()`. Например, в пример выше применялась версия этого метода, которая не применяла параметров. Но также у этого метода есть ряд перегрузок, позволяющих вручную выбрать файл с `View`.

```c#
View() // Для генерации ответа c View с темже именем
View(string? viewName) // Ручной выбор представления
View(object? model) // Передача модели в представление
View(string? viewName, object? model) // Выбор и перелача модели
```

При ручной передаче имени представления можно передать, как имя представления,
тогда оно будет искаться в папке контроллера, а также полный путь до представления.

```c#
return View("About");
return View("~/Views/Some/About.cshtml");
```

После возвращения `ViewResult` представление будет сформировано с использованием специального языка разметки [[Razor]], если при этом не был выбран другой движок.

---
В концепции `Mvc` представление принимает данные из контроллера в виде модели.
Существуют различные способы передачи данных из контроллера в представление.

**==ViewData==**. Представляет простой словарь из пар ключ значение. Доступен как поле базового класса. Для использования требуется записать данные перед возвращением `ViewResult`.

```c#
public IActionResult Index()
{
    ViewData["Message"] = "Hello METANIT.COM";
    ViewData["Title"] = "ASP.NET Core MVC";
    return View();
}
```

```c#
<h2>@ViewData["Title"]</h2>
<h3>@ViewData["Message"]</h3>
```

**==ViewBag==**. Класс во многом подобен `ViewData`. Так как он является `dynemic` он
позволяет определить различные свойства и присвоить им любое значения:

```c#
public IActionResult Index()
{
    ViewBag.Message = "Hello METANIT.COM";
    ViewBag.Title = "ASP.NET Core MVC";
    return View();
}
```

```c#
<h2>@ViewBag.Title</h2>
<h3>@ViewBag.Message</h3>
```

**==Model==**. Модель представления является во многих случаях более предпочтительным способом для передачи данных в представление. Для передачи данных в представление используется версия метода `View`, при этом в качестве модели используется любой объект:

```c#
public IActionResult Index()
{
    var people = new List<string> { "Tom", "Sam", "Bob" };
    return View(people);
}
```

```c#
@model List<string>
 
<h2>Count: @Model.Count</h2>
<ul>
@foreach(string person in Model)
{
    <li>@person</li>
}
</ul>
```

В самом начале представления с помощью директивы `@model` устанавливается тип модели представления. Тип модели должен совпадать с типом объекта, который передается `View()`.
Представления у которых есть модель, называются строго типизированными `StronglyTyped`.

```c#
@model <ModelType>
@Model // Переданная модель
```









---
---
---
Представления определяют внешний вид приложения и на основе которых потом формируется веб-страница. В AspNetCoreMVC представления - это файлы с расширением cshtml, которые содержат код пользовательского интерфейса в основном на языке html и razor

За работу с представлениями отвечает объект ViewResult. Он производит рендеринг представления в веб-страницу и возвращает ее в виде ответа клиенту. Чтобы возвратить объект ViewResult, в методе контроллера вызывается метод View:

Вызов метода View возвращает объект ViewResult. Затем уже ViewResult производит рендеринг определенного представления в ответ

## Перегрузки метода View():

1. **View():** для генерации ответа используется представление, которое по имени совпадает с вызывающим методом
2. **View(string? viewName):** в метод передается имя представления, что позволяет переопределить используемое представление
3. **View(string? viewName, object? model):** переопределяет имя представления и передает в него данные в виде объекта mode
4. **View(object? model):** передает в представление данные

---

### Передача данных в Views

**ViewData** - представляет словарь из пар ключ-значение. Значения могут устанавливаться как в самом представлении, так и в котроллере

**ViewBag** - во многом подобен ViewData. Он позволяет определить различные свойства и присвоить им любое значение. При этом само свойство задается динамически при присвоении

**View Model** - является во многих случаях более предпочтительным способом для передачи данных в представление. Для передачи данных в представление используется одна из версий метода View. В представлении, через тег model объявляется тип передаваемого значения, после чего данные будут доступны через свойство Model

---

### Мастер страницы

**layout** - позволяют задать единый шаблон для представлений и применяются для создания единообразного, унифицированного вида сайта. По сути мастер-страницы - это те же самые представления, которые могут включать в себя другие представления. Кроме того, с помощью свойства Layout устанавливается используемая layout

**\@‌RenderBody()** - метода на место которого потом будут подставляться другие представления, использующие данный layout

**\@‌RenderSection(name)** - метод для вставки отдельных секций в шаблон представления. Layout может иметь несколько различный секций. В самих представлениях содержимое определяется \@‌section {}

**\_ViewStart.cshtml** - код этого файла добавляется в самое начало кода преставлений при их запуске. При этом файлы представлений, к которым применяется ViewStart, должны находиться с этим файлом в одном каталоге

**\_ViewImports.cshtml** - позволяет по умолчанию подключить в представления требуемые пространства имен для представлений

---

### Частичные представления

Также можно использовать частичные представления или partial views. Их отличительной особенностью является то, что их можно встраивать в другие обычные представления. Частичные представления могут использоваться также как и обычные, однако наиболее удобной областью их использования является рендеринг результатов AJAX-запроса. Частичные представления похожи на секции, только их код выносится в отдельные файлы

**PartialViewResult** - объект, который отвечает за рендеринг частичных представлений, который возвращается методом PartialView(). Этот метод имеет четыре версии, аналогичные простым представлениям

**Html.PartialAsync()** - встраивает код частичного представления в обычное. Он возвращает объект IHtmlContent, который представляет html-содержимое и который обернут в объект Task