Фреймворк `AspNetCoreMVC` является частью платформы `AspNetCore`, его отличительная особенность применение паттерна `MVC`. Преимуществом использования `AspNetCoreMVC` 
по сравнению с чистым `AspNetCore` является то, что он упрощает в ряде ситуаций и сценариев организацию и создание приложений, особенно при большом масштабе.

Стоит отметить, что паттерн `MVC` не является исключительной особенностью `AspNetCore`, данный паттерн появился еще в конце `1970` годов в компании `Xerox` для организации компонентов в графическом приложение на языке `Smalltalk` и в настоящее время применяется во многих платформах и для различных языках программирования.
Концепция `MVC` предполагает разделение приложения на три компонента:

==**Model**==. Описывает используемые в приложении данные, а также логику, которая связана непосредственно с данными, например, логику валидации данных. Как правило, объекты моделей хранятся в базе данных. В `MVC` модели представлены двумя основными типами: модели представлений, которые используются представлениями для отображения и передачи данных, и модели домена, которые описывают логику управления данными.

Модель может содержать данные, хранить логику управления этими данными. В то же
время модель не должна содержать логику взаимодействия с пользователем и не должна осуществлять обработку запроса. Еще модель не должна отображать данные представления.

**==View==**. Отвечают за визуальную часть или пользовательский интерфейс, к примеру,
`Html` страница, через которую пользователь взаимодействует с приложением. Также представление может содержать логику, связанную с отображением данных. В то же время представление не должно содержать логику обработки запроса или управления данными.

**==Controller==**. Представляет центральный компонент `MVC`, который обеспечивает связь между пользователем и приложением, представлением и хранилищем данных. Он содержит логику обработки запроса пользователя. Контроллер получает вводимые пользователем данные
и обрабатывает их. И в зависимости от результатов обработки отправляет пользователю определенный вывод, например, в виде представления, наполненного данными моделей.

![[Pasted image 20250705190901.png]]

В этой схеме модель является независимым компонентом, любые изменения контроллера или представления никак не влияют на модель. Контроллер и представление являются относительно независимыми компонентами. Так, из представления можно обращаться
к определенному контроллеру, а из контроллера генерировать представления, но при 
этом нередко их можно изменять независимо друг от друга в кодовой базе приложения.

Такое разграничение компонентов приложения позволяет реализовать концепцию разделение ответственности, при которой каждый компонент отвечает за свою строго очерченную сферу. В связи с чем легче построить работу над отдельными компонентами. 
И благодаря этому приложение легче разрабатывать и поддерживать. Допустим, если нам важна визуальная часть или фронтэнд, то мы можем тестировать представление независимо от контроллера. Либо мы можем сосредоточиться на бэкэнде и тестировать контроллер.

---

Для добавления функциональности `Mvc` нужно подключить нужные сервисы, используя метод расширения коллекции сервисов `services.AddControllersWithViews()`. После
этого мы можем использовать функциональность фреймворка `MVC` в виде сервисов.

Кроме того, чтобы связать приходящие от пользователей запросы с контроллерами применяется метод `MapControllerRoute()`. Через первый параметр `name` в метод передается название маршрута в данном случае `default`. Через второй параметр
параметр `pattern` передается шаблон, которому должен соответствовать запрос. 

В качестве шаблона маршрута применяется `{controller=Home}/{action=Index}/{id?}`, который представляет трехсегментный запрос. В нем первый сегмент представляет контроллер, второй сегмент метод контроллера, а третий необязательный параметр.
При этом если в запросе не указаны сегменты например, обращение идет к корню приложения, то тогда в качестве контроллера применяется `HomeController/Index`.

```c#
var builder = WebApplication.CreateBuilder(args);

// Добавляем сервисы MVC
builder.Services.AddControllersWithViews();
 
var app = builder.Build();
 
// устанавливаем сопоставление маршрутов с контроллерами
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
 
app.Run();
```

Функциональность `MVC` и ее работа в приложении зависит от добавляемых сервисов. В примере выше мы использовали метод `AddControllersWithViews()` для добавления сервисов `MVC`, благодаря чему система маршрутизации смогла связать запрос с контроллером. Однако в данном случае у нас есть ряд других опций системы:

**===AddMvc()===**. Добавляет все сервисы фреймворка `MVC` в том числе сервисы
для проведения аутентификации, авторизации, сервисы валидации и так далее.

==**AddMvcCore()**==. Добавляет только основные сервисы фреймворка `MVC`, без дополнительных сервисов аутентификациn, авторизации, валидации и других второстипенных сервисов.

**==AddControllersWithViews()==**. Добавляет только те сервисы фреймворка `MVC`, которые позволяют использовать контроллеры и представления и связанную функциональность. 
При создании проекта по типу `Model-View-Controller` используется именно этот метод

**==AddControllers()==**. Позволяет добавить сервисы фреймворка, которые обеспечивают функционирование контроллеров и их маршрутизацию, но без представлений.

И в зависимости от того, насколько широко нам надо использовать возможности фреймворка `MVC`, выбирается соответствующий метод. Например, в примере выше мы могли бы использовать вместо вызова `AddControllersWithViews()` метод `AddMvc()`.

```c#
builder.Services.AddMvc();
builder.Services.AddMvcCore();
builder.Services.AddControllersWithViews();
builder.Services.AddControllers();
```
