Спецификация `OpenGl` определяет множество различных примитивов: `Point`, `Line`, `LineStrip`, `LineLoop`, `Polygon`, `Triangle`, `TriangleStrip`, `Quads` и другие. 

Спецификация `OpenGl` также позволяет использовать несколько различных подходов для отображения примитивных объектов на сцене. Вот примеры некоторых из них:

**==ImmediateMode==**. Это самый простой способ отображения примитивов. Он использует функции `glBegin(type)` и `glEnd()` для начала и завершения определения примитива, а также функции `glVertex()` для определения вершин примитива. Однако этот подход устарел и не рекомендуется к использованию из-за его низкой производительности.

При этом подходе при расчете каждого кадра, требуется по общей шине передавать данные о всех вершинах примитива. Такой подход достаточно медленный из-за неэффективного использования шины. Намного выгоднее передавать только измененные вершины, а статические сохранять один раз в памяти видеочипа.

```c
glBegin(GL_POINTS);
glVertex2(0.5f, 0.5f);
glEnd();
```

==**DisplayLists**==. Этот подход предполагает создание списков отображения с помощью функций `glGenLists()`, `glNewList()` и `glEndList()`, где и определяются примитивы. Затем эти списки могут быть вызваны для отображения в дальнейшем. Этот метод более эффективен, чем обычный немедленный режим, но все еще имеет недостатки.
Удаление производится вызовом  функции `glDeleteLists(id, count)`.

Такой подход позволяет сохранять координаты вершин примитива в памяти видеокарты и передавать по шине только дескрипторы советующего списка.

Каждый дисплейный список должен иметь идентификатор. Это может быть произвольное целое число, которое вы можете назначить сами. 

Во избежание конфликтов идентификаторов списков библиотека рекомендует воспользоваться функцией `GenLists(count)` которая находит свободный идентификатор и возвращает его. В качестве аргумента функции указывается количество, следующих подряд, списков, для которых следует получить идентификаторы. Если  идентификаторов не осталось, то возвращается ноль.

```c#
int id = gl.GenLists(1);
gl.NewList(id, GL_COMPILE) // GL_COMPILE || GL_COMPILE_AND_EXECUTE
...
gl.glEndList();
gl.CallList(id)
```

**==VertexArray==**. Подход, подразумевающий создание массивов с координатами вершин и массивов с иными данными о вершинах, с последующей передачей этих данных по шине в графическую карту.  Это позволяет вам не заниматься управлением памятью на уровне `CPU`, что может быть полезно для статических или небольших данных. 

```c#
glEnableClientState(GL_VERTEX_ARRAY);
glVertexPointer(count_by_item, GL_FLOAT, shift, data);

glEnableClientState(GL_COLOR_ARRAY);
glColorPointer(count_by_item, GL_FLOAT, shift, data);

glDrawArrays(GL_TRIANGLES, shift, count_by_item);

glDisableClientState(GL_VERTEX_ARRAY);
```

**==VertexBufferObject==**. 

![[Pasted image 20240405192319.png]]