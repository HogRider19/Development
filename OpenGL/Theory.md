В 3D графике сцены обычно описываются как объекты в трехмерном пространстве, причем каждый объект состоит из множества трехмерных вершин. В конечном итоге эти объекты визуализируются и отображаются на плоском экране. Рендеринг сцены всегда происходит относительно камеры, и поэтому вершины сцены также должны        при рендеринге должны быть определены относительно обзора камеры.

При рисовании сетки в конвейере `OpenGL` вершинный шейдер будет обрабатывать каждую вершину, ожидая, что положение вершины будет определено в пространстве отсечения . _Проекция представления модели_ — это обычная серия матричных преобразований, которые можно применить к вершине, определенной в _пространстве модели_ , преобразуя ее в _пространство отсечения_ , которое затем можно растрировать.

---

Перемещение объектов по средствам изменяя координаты вершин для каждого кадра, является сложным и требует процессорных вычислений. Есть более удобный способ для совершения трансформаций это применение преобразований векторов и матриц.

В самом простом определении, вектора представляют собой направление. У вектора может быть _направление_ и _магнитуда_ также иногда называется модулем или длиной.

Вектора могут иметь любую размерность, но в рендеринге чаще всего используются двухкомпонентные и четырехкомпонентные вектора. Если вектор двухкомпонентный, то он описывает направление на плоскости или на 2D графике, если вектор трехкомпонентный, то он описывает направление в трехмерном мире.

Вектора разделяют на _позиционные_ и _направленные_. Позиционные указывают на положение точки в пространстве относительно начала координат, а направленные в свою очередь указывают на направление, для них не важно значение магнитуды.

Также выделяют нормализованные вектора, которые представляют из себя вектора с единичной длинной. Нормализовать вектор можно поделив его на его магнитуду.

Множество операций пространственных преобразований очень легко математически описываются с помощью матричных и векторных арифметических операций.

---

**==IdentityMatrix==**. В `OpenGL` обычно работают с матрицами трансформации размерами `4х4` по той причине, что большинство векторов имеет `4` компонента. Самая простая матрица трансформации которую можно обсудить это единичная матрица.

Данная матрица представляет матрицу, заполненная нулями, но с единицами по диагонали. Она имеет особенное свойство: при умножении единичной матрицы         ее на какой-либо вектор, результатом всегда будет исходный вектор.

Единичная матрица зачастую является отправной точкой для генерации других матриц трансформации и если мы углубимся в линейную алгебру, это также очень удобная матрица для доказательства теорем а также для решения линейных уравнений.

**==ScalingMatrix==**. Матрица масштабирования представляет собой матрицу, которая при умножении на вектор масштабирует его размеры на величины `(s1, s2, s3)`. Такая матрицы составляется из единичной матрицы с компонентами на диагонали.

![[Pasted image 20240406232608.png]]

**==ShiftMatrix==**. Сдвиг представляет процесс добавления одного вектора к другому для получения нового вектора с другой позицией на основании вектора сдвига.

Также как и с матрицей масштабирования в матрице `4х4` есть несколько позиций для выполнения требуемых операций, для сдвига — это верхние `3` элемента четвертой колонки. Если мы представим вектор сдвига как `(Tx, Ty, Tz)`, то матрицы сдвига:

![[Pasted image 20240406232922.png]]
Это работает, потому что все значения вектора умножаются на `w` компонент вектора и складываются с начальным значениями. Это было бы невозможно при матрице `3х3`.

>[!info] Гомогенные координаты
>Компонента вектора `w` также называется гомогенной координатой. Использование гомогенных координат имеет несколько преимуществ: они позволяют нам выполнять сдвиги на трехмерных векторах и для трехмерных визуализаций.
>
>Когда гомогенная координата равна 0, то вектор считается направленным, так как вектор с компонентой `w` равной `0` не может быть сдвинут. При этой координате равной единице, вектор считается позиционным вектором.

**==RotationMatrix==**. Вращение в трехмерном пространстве описывается углом и осью вращения. Угол определяет то насколько вектор будет повернут вокруг данной оси. При вращении `2D` векторов в `3D` мире, к примеру, мы установим ось вращения `Z`.

Вращение можно определить разными способами: с использованием матриц или с использованием кватернионов. При использовании матриц мы можем задать матрицу вращения для каждой из осей декартовой системы координат, но такой подход очень часто приводит к проблеме шарнирного замка `GimbalLock`, реже такая проблема встречается при вращении вокруг произвольной оси с компонентами `(Rx, Ry, Rz)`:

![[Pasted image 20240406235454.png]]

>[!info] Шарнирный замок
>Проблема шарнирного замка представляет эффект, возникающей при использовании Эйлеровых углов. Из-за того, что конечный результат серии вращений зависит от порядка промежуточных вращений, иногда случается, что вращение вокруг одной оси отображается на вращение вокруг другой оси.

Для того, чтобы достичь максимальной полезности использования матриц для трансформаций мы должны комбинировать матрицы трансформации в одну матрицу. Важно, что во время умножения матриц мы в начале умножаем сдвиг, вращение , а потом масштабирование. Так как умножение матриц не коммутативно.