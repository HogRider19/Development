В 3D графике сцены обычно описываются как объекты в трехмерном пространстве, причем каждый объект состоит из множества трехмерных вершин. В конечном итоге эти объекты визуализируются и отображаются на плоском экране. Рендеринг сцены всегда происходит относительно камеры, и поэтому вершины сцены также должны        при рендеринге должны быть определены относительно обзора камеры.

---

Перемещение объектов по средствам изменяя координаты вершин для каждого кадра, является сложным и требует процессорных вычислений. Есть более удобный способ для совершения трансформаций это применение преобразований векторов и матриц.

В самом простом определении, вектора представляют собой направление. У вектора может быть _направление_ и _магнитуда_ также иногда называется модулем или длиной.

Вектора могут иметь любую размерность, но в рендеринге чаще всего используются двухкомпонентные и четырехкомпонентные вектора. Если вектор двухкомпонентный, то он описывает направление на плоскости или на 2D графике, если вектор трехкомпонентный, то он описывает направление в трехмерном мире.

Вектора разделяют на _позиционные_ и _направленные_. Позиционные указывают на положение точки в пространстве относительно начала координат, а направленные в свою очередь указывают на направление, для них не важно значение магнитуды.

Также выделяют нормализованные вектора, которые представляют из себя вектора с единичной длинной. Нормализовать вектор можно поделив его на его магнитуду.

Множество операций пространственных преобразований очень легко математически описываются с помощью матричных и векторных арифметических операций.

---

**==IdentityMatrix==**. В `OpenGL` обычно работают с матрицами трансформации размерами `4х4` по той причине, что большинство векторов имеет `4` компонента. Самая простая матрица трансформации которую можно обсудить это единичная матрица.

Данная матрица представляет матрицу, заполненная нулями, но с единицами по диагонали. Она имеет особенное свойство: при умножении единичной матрицы         ее на какой-либо вектор, результатом всегда будет исходный вектор.

Единичная матрица зачастую является отправной точкой для генерации других матриц трансформации и если мы углубимся в линейную алгебру, это также очень удобная матрица для доказательства теорем а также для решения линейных уравнений.

**==ScalingMatrix==**. Матрица масштабирования представляет собой матрицу, которая при умножении на вектор масштабирует его размеры на величины `(s1, s2, s3)`. Такая матрицы составляется из единичной матрицы с компонентами на диагонали.

![[Pasted image 20240406232608.png]]

**==ShiftMatrix==**. Сдвиг представляет процесс добавления одного вектора к другому для получения нового вектора с другой позицией на основании вектора сдвига.

Также как и с матрицей масштабирования в матрице `4х4` есть несколько позиций для выполнения требуемых операций, для сдвига — это верхние `3` элемента четвертой колонки. Если мы представим вектор сдвига как `(Tx, Ty, Tz)`, то матрицы сдвига:

![[Pasted image 20240406232922.png]]
Это работает, потому что все значения вектора умножаются на `w` компонент вектора и складываются с начальным значениями. Это было бы невозможно при матрице `3х3`.

>[!info] Гомогенные координаты
>Компонента вектора `w` также называется гомогенной координатой. Использование гомогенных координат имеет несколько преимуществ: они позволяют нам выполнять сдвиги на трехмерных векторах и для трехмерных визуализаций.
>
>Когда гомогенная координата равна 0, то вектор считается направленным, так как вектор с компонентой `w` равной `0` не может быть сдвинут. При этой координате равной единице, вектор считается позиционным вектором.

**==RotationMatrix==**. Вращение в трехмерном пространстве описывается углом и осью вращения. Угол определяет то насколько вектор будет повернут вокруг данной оси. При вращении `2D` векторов в `3D` мире, к примеру, мы установим ось вращения `Z`.

Вращение можно определить разными способами: с использованием матриц или с использованием кватернионов. При использовании матриц мы можем задать матрицу вращения для каждой из осей декартовой системы координат, но такой подход очень часто приводит к проблеме шарнирного замка `GimbalLock`, реже такая проблема встречается при вращении вокруг произвольной оси с компонентами `(Rx, Ry, Rz)`:

![[Pasted image 20240406235454.png]]

>[!info] Шарнирный замок
>Проблема шарнирного замка представляет эффект, возникающей при использовании Эйлеровых углов. Из-за того, что конечный результат серии вращений зависит от порядка промежуточных вращений, иногда случается, что вращение вокруг одной оси отображается на вращение вокруг другой оси.

Для того, чтобы достичь максимальной полезности использования матриц для трансформаций мы должны комбинировать матрицы трансформации в одну матрицу. Важно, что во время умножения матриц мы в начале умножаем сдвиг, вращение , а потом масштабирование. То есть вектор сначала масштабируется, вращается, а потом  сдвигается. Порядок важен так как умножение матриц не является коммутативным.

---

Система `OpenGL` предполагает, что все вершины, которые мы хотим увидеть, после запуска шейдера будут в нормализованных координатах устройства `NDC`. Это означает, что `x, y, z` координаты каждой вершины должны быть между `-1.0 и 1.0`.

Координаты вне этого диапазона видны не будут. Обычно мы указываем координаты в своем диапазоне, а в вершинном шейдере преобразовываем эти координаты в `NDC`. Затем, эти `NDC` передаются растеризатору для преобразования в пиксельные.

Преобразование координат в нормализованные, а затем в экранные координаты обычно осуществляется пошагово, и, до окончательного преобразования в экранные координаты, мы переводим вершины объекта в несколько координатных систем.

Преимущество преобразования координат через промежуточные координатные системы заключается в том, что некоторые операции проще выполняются в определённых системах. Всего есть 5 различных систем, которые для нас важны:

1. Локальное пространство  `Local`
2. Мировое пространство     `World`
3. Пространство Вида            `View`
4. Пространство Отсечения  `Clip`
5. Экранное пространство    `Screen`

Для преобразования координат из одного пространства в другое, используются несколько матриц трансформации, среди которых, самыми важными являются матрицы `Модели`, `Вида` и `Проекции`. Координаты наших вершин начинаются в локальном пространстве и в дальнейшем преобразуются в мировые координаты, потом в координаты вида, отсечения, и, наконец в экранные координаты.

![[Pasted image 20240407110626.png]]

Модификацию вашего объекта разумнее всего выполнять в локальном пространстве, а вычисление операций учитывающих расположение других объектов лучше делать в мировых координатах и так далее. При желании мы могли бы задать одну матрицу трансформации, которая преобразовывала координаты из локального пространства в пространство отсечения за один шаг, но это лишит нас гибкости преобразований.

**==LocalSpase==**. Локальное пространство это координатная система, которая является локальной для объекта, то есть начинается в той же точке, что и сам объект.

**==WorldSpase==**.  Координаты мирового пространства по смыслу являются координатами более крупного мира. Эти координаты измеряются относительно некоторой заданной глобальной точки отсчёта, единой для всех других объектов на отображаемой сцене.

Локальные координаты объекта преобразуются в координаты мирового пространства. Данная операция выполняется посредством матрицы `Model`. Матрица модели это матрица, которая перемещает, масштабирует и вращает объект для его расположения в мировом пространстве в позиции ориентации в которой объект должен находиться.

**==ViewSpase==**. Пространство вида это результат преобразования мировых координат в координаты, которые выглядят, как будто пользователь смотрит на них спереди.

Таким образом пространство вида представляет пространство видимое через видоискатель камеры. Это обычно достигается совокупностью таких сдвигов и вращений сцены, что некоторые объекты располагаются перед камерой. Эти комбинированные преобразования как правило хранятся в матрице `View`.

**==ClipSpase==**. После завершения работы вершинных шейдеров, `OpenGL` ожидает, что все координаты будут в определенном диапазоне, а всё что выходит за его границы будет отсечено. Отсеченные координаты отбрасываются, а оставшиеся становятся, видимыми на экране. Вот откуда данное пространство отсечения получило своё название.

Для преобразования координат из пространства вида в пространство отсечения мы задаем так называемую матрицу проекции `Projection`, которая определяет диапазон координат по каждой оси в функции `glViewport`. Матрица проекции трансформирует координаты этого диапазона в нормализованные координаты устройства `NDC`.

Если вне объема отсечения находится не весь примитив, например треугольник, а только его часть, то `OpenGL` перестроит этот треугольник в виде одного или нескольких треугольников, которые будут полностью находиться в диапазоне отсечения.

Как только координаты всех вершин будут переведены в пространство отсечения, выполняется заключительная операция, называемая перспективное деление. В ней мы делим `x,y,z` компоненты вектора позиции вершины на гомогенную компоненту вектора `w`. Перспективное деление преобразует `4D` координаты пространства отсечения в трехмерные нормализованные координаты устройства. Этот шаг выполняется автоматически после завершения работы вершинного шейдера.

Матрица проекции преобразующая координаты вида в координаты отсечения может принимать две различных формы, и каждая форма определяет свою особенную усеченную пирамиду. Мы можем создать ортографическую и перспективную матрицу.

При использовании перспективной матрицы проекции, активно используется компонент `w` каждой вершины, чем дальше находится объект от наблюдателя тем большим устанавливается значения этой компоненты вектора вершины.

При использовании ортогональной проекции каждая координата вершины отображается в пространство отсечения без какого-либо мнимого перспективного деления, на самом деле перспективное деление производится, но `w` компонент на результат никак не влияет так как равен `1`, следовательно, не имеет никакого эффекта.