Протокол `SSE (Server Sent Events)` представляет собой технологию отправки уведомлений от сервера к браузеру в виде `DOM` событий. Технология `SSE` сейчас стандартизируется как часть `HTML5`. Соединение является односторонним, то есть
клиентская часть протокола не может отправлять данные на серверную часть.

| WebSocket                                                              | EventSource                                       |
| ---------------------------------------------------------------------- | ------------------------------------------------- |
| Двунаправленноcть: и сервер, и клиент   могут обмениваться сообщениями | Однонаправленность: данные посылает только сервер |
| Бинарные и текстовые данные                                            | Только текст                                      |
| Протокол WebSocket                                                     | Обычный HTTP                                      |

Механизм `SSE` не настолько мощный способ коммуникации, как `WebSocket`.Зачем нам его использовать? Основная причина: он проще. Многим приложениям не требуется вся мощь `WebSocket`. Если нам нужно получать поток данных с сервера с этим легко справится `SSE`. К тому же, он поддерживает автоматическое переподключение при потере соединения, используя `WebSocket`, нам бы пришлось реализовывать самим.

Механизм `SSE` страдает от ограничения максимального количества открытых подключений, что может быть особенно болезненным при открытии нескольких вкладок, обычно стандартные браузеры не дают открыть больше шести соединений. 

---

Чтобы начать получать данные, нам нужно просто создать `new EventSource(url)`.
Браузер установит соединение с `url` и будет поддерживать его открытым.

```js
let eventSource = new EventSource("some_url");
```

Сервер отвечает статусом `200` и заголовком `Content-Type: text/event-stream`, затем он должен поддерживать соединение открытым и отправлять сообщения в формате:

``` text
data: message1 \n\n
data: message2 \n\n
some_event: message3 \n\n
```

На практике сложные сообщения отправляются в формате `JSON`, в котором перевод строки кодируется как `\n`, так что в разделении  на несколько строк нет нужды.

```js
eventSource.onmessage = event => console.log(event.data);
eventSource.onopen = event => {};
eventSource.onerror = event => {};
```

Механизм `EventSource`, как и `fetch`, поддерживает кросс доменные запросы. Поэтому мы можем использовать любой `URL` для установки соединения с механизмом `SSE` . 

После создания `new EventSource` подключается к серверу и, если соединение обрывается, то переподключается. Это очень удобно, так как нам не приходится беспокоиться об этом. По умолчанию между попытками возобновить соединение будет небольшая пауза в несколько секунд. Сервер выставляет ее через `retry`.

Браузеру следует ждать именно столько миллисекунд перед новой попыткой подключения. Или дольше, например, если браузер от операционной системы знает что соединения с сетью нет, то он может переподключиться только при появлении сети.

Когда соединение прерывается из-за проблем с сетью, ни сервер, ни клиент не могут быть уверены в том, какие сообщения были доставлены, а какие – нет. Чтобы правильно возобновить подключение, каждое сообщение имеет поле `id`.

Получая сообщение с указанным `id`  браузер установит его значение свойству `eventSource.lastEventId`, затем при переподключении отправит `HTTP` заголовок `Last-Event-ID` с этим `id`, чтобы сервер мог переслать последующие сообщения.

>[!info] Указывайте id после data
>Обратите внимание: id указывается сервером после данных data сообщения, чтобы обновление lastEventId произошло после того, как сообщение будет получено.

По умолчанию объект `EventSource` генерирует 3 события: `message`, `error`, `open`. Но сервер имеет возможность отправлять и другие события, для их обработки клиентской части нужно подключить обработчик к  `EventSource` через `addEventListener`.

```js
eventSource.addEventListener('some_event', event => {});
```