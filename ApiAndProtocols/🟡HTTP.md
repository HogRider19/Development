HTTP (HyperText Transfer Protocol) широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов.
Является протоколом передачи данных прикладного уровня в сетевой модели `OSI`.

Предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет его на сервер, после чего сервер обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту.

Его часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как `SOAP`, `RPC` и `WebDAV`, в качестве транспорта.

Обычно передача данных по протоколу `HTTP` осуществляется через `TCP` соединение. Серверное программное обеспечение при этом обычно использует порт `80`.

HTTPS (HTTP Secure) это надстройка над протоколом `HTTP`, которая поддерживает шифрование посредством криптографических протоколов `SSL` и `TLS`. Они шифруют отправляемые данные на клиенте и в последующем дешифруют их на сервере.

---

Весь современный веб построен на протоколе `HTTP`. Каждый сайт использует его для общения клиента с сервером. Между собой сервера тоже часто общаются по этому протоколу. На данный момент существует четыре его версии и все используются.

Заголовки `HTTP` представляют собой строки в `HTTP` сообщении, содержащие разделённую двоеточием пару имя-значение. Новый заголовок отделяется строкой.

Клиенту зачастую недостаточно просто отправить запрос на сервер. Во многих случаях надо дождаться ответа и понять, как сервер обработал запрос. Для этого были придуманы статусы ответов. Это трёхзначные числовые информирующие коды.

Тело запроса опционально и всегда отделяется от заголовков пустой строкой. Конец тела запроса тоже отделяется пустой строкой. Если требуется передать тело имеющее такие разделители, то должен быть явно указан заголовок `Content-Length`.

>[!info] GetBody
>Тело запроса не зависит от метода. В стандарте не описана возможность принимать тело запроса у GET метода, но это и не запрещено. Технически вы можете отправить данные в теле, но скорее всего оно проигнорируется .

Данные на сервер могут предаваться с помощью заголовков; строки запроса после вопросительного знака, обычно используется для конкретизации ресурса  и посредством тела запроса, что является самым безопасным способом.

Передача бинарных файлов через протокол `HTTP` может осуществляться простой передачей данных в теле запроса или с использованием `multipart/form-data`, тогда вместе с бинарным файлом можно передать дополнительную информацию к нему. 

Запросы `GET` по своей идеологии должны быть идемпотентными. Это значит, что множественный вызов метода с одними и теми же параметрами должен приводить к одному и тому же результату, не изменяя состояния выполняющего сервера.

В новых версиях протокола соединение `TCP` может оставаться открытым на протяжении нескольких запросов. Для работы механизма клиент должен отправить в запросе к серверу заголовок `Connection: keep-alive`, сервер отвечает аналогично. Соединение закроется когда в запросе или ответе будет передан `Connection: close`.
Начиная с версии `1.1` все запросы по умолчанию интерпретируются как `keep-alive`.

Иногда серверу нужно передать много данных или данные, неизвестного размера, например, при потоковом воспроизведении аудио или видео. Для того чтобы не загружать в память сервера все данные, была введена потоковая передача.

Если включить потоковую передачу, данные передаются небольшими кусочками. Длина чанка зависит от настроек сервера. В ответе на запрос сервер присылает заголовок `Transfer-Encoding` со значением `chunked`. При этом в теле ответа перед каждым чанком указывается его длина в байтах, а с новой строки данные чанка.
Когда передача данных заканчивается, последним присылается пустой чанк.

---

Протокол `HTTP` не сохраняет состояние. Это значит, что когда на сервер поступают два запроса, он не понимает: их послал один клиент или разные. В приложениях постоянно надо идентифицировать пользователя. Один из механизмов для этого `Cookies`.

`Cookies` представляет собой фрагмент данных, в которых сервер передаёт важную информацию о клиенте. Браузер получает этот фрагмент, сохраняет его и с каждым последующим запросом отсылает обратно на сервер. Куки выглядят, как пара ключ и значение. Для установки сервер должен прислать заголовок `Set-Cookie` со значением.

```sh
Set-Cookie: token=123abc
```

Как только браузер получит ответ, он сохранит значение куки в `Cookie Storage`. В каждый последующий запрос браузер будет добавлять сохранённые значения.

Пример выше это сессионный куки, для них не указываются сроки хранения. Он будет существовать, пока пользователь не закроет вкладку. Но многие браузеры используют механизм восстановления сессий, поэтому сессионные куки в теории могут жить вечно.

Обычно кукам устанавливается фиксированное время жизни. Это можно сделать двумя способами:  установить дату истечения срока годности `Expires`, установить количество секунд, по истечении которых кука перестанет быть актуальной `MAX_AGE`.

```sh
Set-Cookie: token=123abc; Expires=Tue, 01 Jan 2030 00:00:00 -0000
Set-Cookie: token=123abc; MAX_AGE=120
```

Разные браузеры могут использовать разные параметры для установки времени жизни куки. Поэтому сервер часто присылает оба, а браузер сам выбирает поддерживаемый.

Параметры `domain` и `path` управляют областью видимости куки и определяют, на каких поддоменах и для каких URL они будут работать. Если не указать параметр `domain`, то он по умолчанию будет равен хосту сайта. Тогда куки не будут работать для поддоменов. Если указать значение `domain`, то куки будет работать для поддоменов.

Параметр `path` указывает, по каким маршрутам при запросе ресурсов необходимо передавать куку в заголовке. Если установить `path=/`, то куки будут отправляться для всех запросов. Если указать значение `path=/api`, то только по шаблону пути `/api*`.

```sh
Set-Cookie: token=123abc; max_age=120; domain=example.com; path=/api
```

Не существует метода для удаления куки. Можно только установить её повторно и указать дату истечения `expires` в прошлом или нулевой или отрицательный `max_age`.

Куки представляют два параметра, которые защищают их от различных атак.
Параметр `secure` говорит о том, что такие куки будут отсылаться только по `HTTPS`. Если сайт работает по `HTTP`, то значение не будет передано. `Secure` не обеспечивает дополнительного шифрования, поэтому не стоит хранить важные данные в куках.
Параметр `httpOnly` создаёт куки, к которым нельзя обратиться из кода `JavaScript`.

---

По умолчанию в браузере действует политика безопасности `Same Origin Policy`. Это означает, что доступ к ресурсам можно получить, только если источник этих ресурсов и источник запроса совпадают. Эта стратегия работала долгое время, когда `JavaScript` считался браузерным языком для украшения страничек и не умел делать `AJAX`запросы.

Со временем разработчики поняли, что хотят уметь отправлять данные на сервер и получать их при помощи асинхронных запросов. Но политика `Same Origin Policy`    не позволяет это. Поэтому был предложен `CORS(Cross-Origin Resource Sharing)`.

Этот механизм использует дополнительные `HTTP` заголовки. С ним браузер      получает разрешения на доступ к выбранным ресурсам, в том случае                        если домен сайта и домен запрашиваемого ресурса отличаются.

Например, сайт находится на домене `example.com`. Запрос отправляется на сайт, который находится на домене `web-server.com`. Для начала браузер должен понять, сложный этот запрос или простой. Простой запрос отправляется методом `GET`, `POST` 
и содержит только `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`.

Остальные запросы считаются сложными. Простые запросы браузер отправляет напрямую на сервер и автоматически добавляет к ним заголовок `Origin`.
Его значение равно `URL` хоста, с которого отправляется запрос.

```sh
POST /path HTTP/1.0
Host: web-server.com
Origin: example.com
Content-Type: text/plain
```

Сервер принимает такой запрос и определяет, разрешить хосту получить этот ресурс или отказать в запросе. Для этого в ответе используется специальный заголовок `Access-Control-Allow-Origin`. Он определяет, с каких источников разрешено принимать запросы. Если нужно разрешить получать ресурс с любого домена,
то в ответе на запрос должен быть заголовок  `Access-Control-Allow-Origin: *`.

Браузер заблокирует ответ на запрос, если: сервер вернёт в ответе заголовок `null`, значение не будет совпадать с переданным в заголовке `Origin`, не будет заголовка.

Если браузер обнаружит сложный запрос, то сначала отправит серверу `preflight`  предварительный запроc при помощи `HTTP` метода `OPTIONS`. В запрос при этом добавляется заголовок `Access-Control-Request-Method`, в значении которого указывается `HTTP` метод оригинального запроса к желаемому серверу.

Если в оригинальном запросе передаются заголовки не из списка разрешённых, то в запрос `OPTIONS` дополнительно добавляется `Access-Control-Request-Headers`. В его значении через запятую перечисляются все заголовки оригинального запроса. 

В случае отправки `preflight` запроса сервер также должен вернуть заголовок 
`Access-Control-Allow-Origin` с необходимым значением источников запроса.

Если в запрос добавлен заголовок `Access-Control-Request-Method`, то сервер в ответе должен указать, какие `HTTP` методы разрешено использовать для запроса ресурса.

Если в запрос добавлен заголовок `Access-Control-Request-Headers`, то сервер в ответе должен указать, какие `HTTP` заголовки разрешено использовать для запроса.

```sh
HTTP/1.0 200 OK
Connection: close
Server: gunicorn/19.9.0
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: DELETE, GET, POST
Access-Control-Allow-Headers: X-Custom-Header, Authorization
```

Иногда необходимо уметь передавать `Cookies` при обращении к другим доменам. Заголовок `Cookie` не относится к списку разрешенных и попадает под политику безопасности. Чтобы их можно было передавать, сервер в ответ на `preflight` и на оригинальный запрос должен возвращать `Access-Control-Allow-Credentials: true`. Для работы куки также нужно возвращать в `Allow-Origin` конкретный хост.

Если `JS` попытается прочитать значение нестандартного заголовка кросдоменного запроса , то получит `null`. Но сервер в ответе на запрос может перечислить заголовки, к которым можно получить доступ из `JS` в заголовке `Access-Control-Expose-Headers`.

Заголовок ответа сервера `Access-Control-Max-Age` сообщает браузеру, насколько `preflight` может быть кэширован и опущен при запросах к серверу. Значение указывается в секундах. Если после первого выполнения `preflight` запроса время жизни `Max-Age` не вышло, то повторной отправки его на сервер не будет..

---

История второй версии протокола началась в `2009` году. Компания `Google` решила разрабатывать собственную надстройку над `HTTP`, чтобы повысить скорость работы и безопасности. Протокол назвали `SPDY`, браузеры реализовывали его поддержку. В `2015` году в `Google` решили объединить `SPDY` и `HTTP`. Так появился `HTTP/2`.

Протокол `HTTP/2` использует бинарный формат. Бинарные данные меньше размером, поэтому в таком формате скорость передачи и парсинга выше, а нагрузка на сеть ниже. Браузеры с поддержкой `HTTP/2` кодируют запросы в бинарный формат перед отправкой, а сервер в свою очередь обрабатывает запрос и декодирует.

В `HTTP/1.0` для загрузки каждого ресурса устанавливалось новое `TCP/IP` соединение. `HTTP/1.1` принёс `keep-alive`, который позволил загружать множество ресурсов в рамках одного соединения. Это значительно увеличило производительность. Однако, все запрашиваемые ресурсы в этой версии протокола загружаются последовательно. 

Когда запрос к ресурсу подвисает из-за сложностей с его получением, возникает проблема `Head-Of-Line Blocking`. Это означает, что зависший запрос блокирует отправку всех остальных, так как обработка идёт в порядке очереди. Новая структура передачи в бинарном формате дала возможность загружать ресурсы параллельно.

Теперь вся информация при передаче бьётся на небольшие бинарные фреймы. Они собираются в потоки, для каждого запрашиваемого ресурса создаётся отдельный. При этом все фреймы от разных потоков могут передаваться вперемешку в одном `TCP/IP` соединении. Принимающая сторона самостоятельно соберёт все фреймы из одного потока. Также клиент теперь может прервать данные потока, не закрывая соединение.

Во второй версии `HTTP` представили новый алгоритм сжатия заголовков `HPACK4`. Он не использует `DEFLATE` и заточен под эффективную защиту от `CRIME` атак. С ним новая версия `HTTP` протокола стала производительнее и безопаснее при сжатии данных.

В новой версии протокола также была добавлена функция `ServerPush`. Это функция, которая позволяет серверу начать передачу ресурсов на клиент ещё до запроса. Когда сервер формирует ответ, он анализирует, какие ресурсы еще понадобятся клиенту и используя данный механизм начинает их отправку еще до получения запроса.

Протокол `HTTP/2` кардинально изменил протокол и повысил его производительность и безопасность. Использование `HTTP/2` может ускорить загрузку страницы на` 30-50%` по сравнению с `HTTP/1.1`. Но этот прирост может зависеть от многих факторов.

---


```sh
Host           - обязательный заголовок с именем домена от клиента. 
Content-Type   - тип, отправляемого контента.
Content-Length - длинна, отправляемого контента.
Connection     - способ соединения с сервером.
Origin         - имя источника запроса
```

```sh
GET     - запрашивает представление ресурса. 
HEAD    - запрашивает ресурс так же, как и метод GET, но без тела ответа. 
POST    - используется для отправки сущностей к определённому ресурсу. 
PUT     - заменяет все текущие представления ресурса данными запроса. 
PATCH   - используется для частичного изменения ресурса 
DELETE  - удаляет указанный ресурс. 
CONNECT - устанавливает туннель к серверу, определённому по ресурсу. 
OPTIONS - используется для описания параметров соединения с ресурсом.
```