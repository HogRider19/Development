WebSokcets представляет собой продвинутую технологию, позволяющую открыть постоянное двунаправленное сетевое соединение между браузером пользователя и сервером. С помощью его `API` вы можете отправить сообщение на сервер и получить ответ без выполнения `http` запроса, причём этот процесс событийно-управляемый.

При `WebSokcets` скорость обработки стремится к скорости чистого `TCP` сокета. При этом само сообщение не будет требовать заголовков. Для упрощения протокола, в качестве единственной разрешенной кодировки выбрана кодировка `UTF-8`.

У `WebSokcets` также есть возможность шифровать передаваемые данные, для этого используется надстройка над исходным протоколом, так называемая `WSS`. 

Поток данных в `WebSocket` состоит из фреймов, фрагментов данных, которые могут быть отправлены любой стороной. Они имеют типы: текстовый, бинарный, `ping` для проверки соединения и служебный тип для закрытия соединения и других задач. В браузере мы напрямую работаем только с текстовыми и бинарными фреймами. 

По умолчанию протокол подразумевает передачу текста, но так же можно передавать и бинарные данные. Для таких данных используется другой дата фрейм следующего вида: `0x80, <длина - один или несколько байт>, <тело сообщения>`.

В отличие от `HTTP` протокол веб сокетов не имеет ограничений на время жизни в неактивном состоянии. Значит, соединение может висеть в неактивном виде и не требовать ресурсов, за исключением открытого `TCP` сокета на сервере. Но сервер с хорошим мультиплексором сможет легко обрабатывать до миллиона соединений.

| №   | Этап работы протокола WebSokcets                                                                                                               |
| --- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | Браузер подключается по протоколу `TCP` на `80` порт сервера и дает запрос  типа `GET` на установку соединения по протоколу `WebSokcets`       |
| 2   | Если сервер поддерживает `WebSokcets`, то он отвечает подтверждением, в качестве кода ответа используется код `101 Switching Protocols`        |
| 3   | Если браузер это устраивает, то он просто оставляет `TCP` соединение открытым. С этого момента про этому TCP соединению работают `WebSokcets`. |
| 4   | Как только одна сторона хочет передать другой какую-то информацию, она отправляет дата фрейм вида: `0x00,<строка в кодировке UTF-8>,0xFF`      |

При установке соединения, клиент с помощью специальных заголовков, может указать дополнительные расширения протокола, например расширение `soap` или`wamp`. 

---

Чтобы открыть `WebSockets` соединение, нам нужно создать объект `new WebSocket`, указав в конструкторе url адрес и специальный вид протокола `ws` или `wss`:

```js
let ws = new WebSocket("wss:://javascript.info", [acstantion_list]);
```

>[!info] Всегда предпочитайте wss
   Протокол wss не только более безопасен, но и более надежен. Это потому, что данные ws не зашифрованы, видны для любого посредника. Старые прокси могут закрыть соединения из-за странных заголовков незнакомого им WebSokets. 

Как только объект `WebSocket` создан, мы должны слушать его события: `open` , `message`, `error`, `close`. А для отправки данных  на сервер используется `socket.send(data)`.

```js
socket.onopen    = function(e) {}
socket.onmessage = function(e) {}
socket.onclose   = function(e) {}
socket.onerror   = function(e) {}

socket.send("Hello, world!");
```

>[!info] Запрос WebSocket нельзя эмулировать
>Мы не можем использовать XMLHttpRequest или fetch для создания такого HTTP запроса, потому что JavaScript не позволяет устанавливать заголовки WebSocket.

---

Представим, что наше приложение генерирует много данных для отправки. Но у пользователя медленное интернет соединение. Мы можем отправлять данные снова и снова, но они будут буферизованы в памяти, так-как клиент не успевает их отправить.

Свойство `socket.bufferedAmount` хранит количество байт буферизованных данных на текущий момент, ожидающих отправки по сети Мы можем использовать его, чтобы удостовериться, действительно ли сокет в данный момент доступен для передачи.

```js
setInterval(() =>
{
  if (socket.bufferedAmount == 0) 
    socket.send(moreData());
}, 100);
```

Обычно, когда сторона хочет закрыть соединение , они отправляют специальный фрейм закрытия соединения с кодом закрытия и указывают причину в виде текста.

```js
socket.close([code], [reason]);
```

Чтобы получить состояние соединения, существует  свойство `socket.readyState` 
со значениями: `0 – CONNECTING, 1 – OPEN, 2 – CLOSING, 3 – CLOSED`.