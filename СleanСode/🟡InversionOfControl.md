Принцип инверсии управления подразумевает, что поток выполнения программы управляется не прикладным кодом, а кодом фреймворка. В обычной программе программист сам решает в какой последовательности делать вызовы процедур. 

Компонент `IoC-Container` специальный инструмент, который автоматически управляет созданием объектов и внедрением их зависимостей. Он хранит информацию о том, какие зависимости каким интерфейсам соответствуют, сам создаёт нужные экземпляры классов
и передаёт их в другие объекты, избавляя разработчика от ручного связывания объектов.
Разница между `DI` и `IoCC` заключается в том, что `DI` это принцип при котором объекты не создают свои зависимости, а принимаю. А `IoCC` это инструмент автоматического внедрения.

Существуют различные способы реализации инверсии управления. В самом простом случае инверсия управления представлена, внешним кодом, принимающим `callback` функцию.
Внедрение зависимостей является одной из реализаций концепции `InversionOfControl`.

Во всех этих подходах основная идея одна: объект не сам управляет своими зависимостями
и поведением, а полагается на внешнюю систему или среду, которая предоставляет ему всё необходимое. Это позволяет строить гибкие, расширяемые и легко тестируемые приложения.

**==Dependency Injection==**. Является одним из основных способов реализации инверсии управления. Суть этого подхода заключается в том, что объект получает необходимые 
ему зависимости извне, обычно через конструктор, свойства или методы, вместо того
чтобы создавать их самостоятельно. Это позволяет значительно ослабить связь между компонентами системы, упростить замену реализаций и облегчить написание тестов. 

```c#
public class OrderService
{
    private readonly ILogger _logger;
    public OrderService(ILogger logger) => _logger = logger;
    public void Process() => _logger.Log("Order processed");
}

var service = new OrderService(new ConsoleLogger());
service.Process();
```

**==ServiceLocator==**. Представляеn паттерн, при котором зависимости хранятся в  глобальном реестре, откуда любой объект может их получить по запросу. Такой подход считается менее предпочтительным, так как нарушает принцип единой естественности, объекту приходится самому заниматься запросом сервисов. Часто `ServiceLocator` используется как решение
в проектах, где невозможно или неудобно внедрить полноценный `DependencyInjection`.

```c#
ServiceLocator.Register<ILogger>(new ConsoleLogger());
var logger = ServiceLocator.Resolve<ILogger>();
logger.Log("Message from Service Locator");
```

**==EventDrivenArchitecture==**. Является подходом, при котором взаимодействие компонентов строится вокруг событий. Компоненты не вызывают друг друга напрямую, а реагируют 
на события, на которые они подписаны. Инициатор события не знает, кто будет его обрабатывать. Именно в этом проявляется инверсия управления контроль над порядком выполнения и связями между объектами передаётся внешнему механизму обработки событий. В результате система становится более гибкой, расширяемой и удобной для масштабирования, особенно в асинхронных и распределённых архитектурах.

```c#
public class OrderService
{
    public event Action OrderProcessed;
    public void Process() => OrderProcessed?.Invoke();
}

var service = new OrderService();
service.OrderProcessed += () => { };
service.Process();
```

**==Strategy==**. В паттерне `TemplateMethod` базовый класс задаёт общий алгоритм, оставляя реализацию отдельных шагов подклассам. Таким образом, базовый класс управляет последовательностью, а конкретные детали определяются в дочерних классах.

```c#
public abstract class Report
{
	protected abstract void BuildContent();
	
    public void Generate()
    {
        // Code...
        BuildContent();
        // Code...
    }
}
```

В паттерне ``Strategy`` объект делегирует выполнение определённой операции внешней стратегии, которая передаётся ему извне. Это позволяет динамически изменять поведение. Они являются реализациями инверсии управления через делегирование поведения. 

```c#
public interface IDiscount 
{
	decimal Apply(decimal price);
}

public class TenPercentDiscount : IDiscount 
{ 
	public decimal Apply(decimal price) => price * 0.9m;
}

var discount = new TenPercentDiscount();
var result = discount.Apply(100);
```
