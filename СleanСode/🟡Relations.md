Одним из преимуществ объектно-ориентированного языка является возможность повторного использования кода. Такая возможность обеспечивается за счёт связей между классами. ООП обычно поддерживает 4 типа связей: `наследование`, `ассоциация`, `композиция` и `агрегация`. Связи основаны на отношениях `является`, `имеет` и `часть`.

При проектировании отношений между классами надо учитывать некоторые общие рекомендации. В частности, вместо наследования следует предпочитать композицию. При наследовании весь функционал класса-наследника жестко определен на этапе компиляции. И во время выполнения программы мы не можем его динамически переопределить. А класс-наследник не всегда может переопределить код, который определен в родительском классе. Композиция же позволяет динамически определять поведение объекта во время выполнения, и поэтому является более гибкой.

Вместо композиции следует предпочитать агрегацию, как более гибкий способ связи компонентов. В то же время не всегда агрегация уместна. Например, у нас есть класс человека, который содержит объект нервной системы. Понятно, что в реальности, по крайней мере на текущий момент, невозможно вовне определить нервную систему и внедрить ее в человека. То есть в данном случае человек будет главным компонентом, а нервная система - зависимым, подчиненным, и их создание и жизненный цикл будет происходить совместно, поэтому здесь лучше выбрать отношение композицией.

---

==**Наследование**==. Является отношением типа `is_a`. Может выражаться в наследовании классов или наследовании интерфейсов. Наследование является базовым принципом ООП и позволяет одному классу унаследовать функционал другого класса. Нередко отношения наследования еще называют генерализацией или обобщением.

```c#
class User
{
    public int Id { get; set; }
    public string Name { get; set; }
}
 
class Manager : User
{
    public string Company{ get; set; }
}
```

**==Реализация==**. Также представляет отношении `is_a`. Реализация является частным случаем наследования, при котором класс реализует интерфейс другого объекта.

```c#
public interface IMovable
{
    void Move();
}

public class Car : IMovable
{
    public void Move()
    {
        Console.WriteLine("Машина едет");
    }
}
```

**==Ассоциация==**. Это отношение типа `has_a`. Ассоциация устанавливает связь между
двумя классами с помощью их объектов. Отношения ассоциации могут быть связывать объекты `1:1`, `1:N`, `N:N` способами. Два класса ассоциированы, если они используют друг друга для выполнения задач и в то же время могут оба существовать независимо.

```c#
class Team {}
class Armor {}

class Player
{
    public int TeamID { get; set; }
    public List<int> ArmorIDs { get; set; }
}
```

**==Агрегация==**. Агрегация также основана на `has_a`. Агрегация представляет ассоциацию
в односторонней форме.  В агрегации один объект является слабой частью другого.

```c#
public abstract class Engine
{ }
 
public class Car
{
    Engine engine;
    public Car(Engine eng)
    {
        engine = eng;
    }
}
```

**==Композиция==**. Представляет отношение `part_of`.  Представляет очень строгую форму ассоциации, при которой объект полностью управляет жизненным циклом другого.  Зависимые объекты создаются в контексте владельца и удаляются вместе с ним.

```c#
class SomeCar : Car
{
	private Engine _engine;

	SomeCar()
	{
		_engine = new ElectricEngine();
	}
}

class ElectricEngine : Engine
{
	public void Engine_Info() {};
}
```
