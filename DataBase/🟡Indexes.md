**Индекс** - это структура данных, ускоряющая выборку данных из таблицы за счет доп. операций записи и пространства на диске, используемых для хранения индекса и поддержания его в актуальном синхронизированном состоянии.

Когда индекс создан, никакие дополнительные действия не требуются: система сама будет обновлять его при изменении данных в таблице и сама будет использовать его в запросах, где, по её мнению, это будет эффективнее, чем сканирование всей таблицы.

Вам, возможно, придётся только периодически запускать команду `ANALYZE` для обновления статистических данных, на основе которых планировщик запросов принимает решения для поддержания планировки в оптимальном состоянии.

PostgreSQL поддерживает индексы: BTree(default), Hash, GiST, SP-GiST, GIN, BRIN, bloom. Для разных типов индексов применяются разные алгоритмы. Выбрать другой тип индекса можно, написав название типа индекса после ключевого слова `USING`.

```sql
CREATE INDEX index_name ON table_name [USING index_type] (column);
DROP   INDEX index_name;
```

Индексы могут быть полезны также при выполнении команд `UPDATE` и `DELETE` с условиями поиска. Кроме того, они могут применяться в поиске с соединением. 

Создание индекса для большой таблицы может занимать много времени. Можно параллельно с созданием индекса выполнять чтение таблицы, но остальные операции блокируются до окончания построения индекса. Есть возможность разрешить запись параллельно с созданием индексов, но с рядом оговорок.

После создания индекса система должна поддерживать его в согласованном состоянии. С этим связаны неизбежные накладные расходы при изменении данных.

**==BTree==**. Сбалансированное дерево может работать в условиях на равенство и в проверках диапазонов с данными, которые могут быть отсортированы.

Сбалансированное дерево подразумевает, что на каждой из сторон узлов находится одинаковое количество подузлов и листьев. то есть. узел может делится на 2 и более подузлов и каждый подузел также может иметь другие подузлы, но не может быть такого, что один подузел имеет некое кол-во подузлов, а второй нет.

Также такой индекс обрабатывает операторы `BETWEEN`, `IN`, `IS NULL`, `IS NOT NULL`. Также оптимизатор может использовать BTree при сопоставлении `LIKE`, если этот шаблон определяется константой и он привязан к началу строки.

**==Hash==**. Хеш-индексы хранят 32-битный хеш-код, полученный из значения индексированного столбца, поэтому хеш-индексы работают только с простыми условиями равенства. Планировщик запросов может применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором равенства.

Поиск на равенство столбца с таким индексом начинает производиться за константное время. Но в реальных запросах такой индекс будет уступать индексу BTree.

**==GIST==**. Индекс обобщенного поискового дерева представляют собой целую инфраструктуру, позволяющую реализовать много разных стратегий индексирования.

Являются обобщенными и многоцелевыми, предназначены для работы с сложными типами данных, такими как геометрические объекты, текст и массивы. Они позволяют быстро выполнять поиск по пространственным, текстовым и иерархическим данным.

Как следствие, GiST индексы могут применяться с разными операторами, в зависимости от стратегии индексирования. Например, стандартный дистрибутив включает классы операторов GiST для нескольких двумерных типов геометрических данных. GiST индексы также могут оптимизировать поиск «ближайшего соседа».

**==SP-GiST==**. Обобщённое дерево по разбитому на партиции пространству, как и GiST, предоставляют инфраструктуру, поддерживающую различные типы поиска.

Предназначены для работы с непересекающимися и неравномерно распределенными данными. Они эффективны для поиска в геометрических и IP-адресных данных.

Индексы SP-GiST, как и GiST, поддерживают поиск ближайших соседей. Для классов операторов SP-GiST, поддерживающих упорядочивание по расстоянию.

**==GIN==**. Обобщенный инвертированный индекс представляет индекс, в котором могут содержаться значения с несколькими ключами, например массивы. Инвертированный индекс содержит отдельный элемент для значения каждого компонента, и может эффективно работать в запросах, проверяющих присутствие определённых значений.

GIN-индексы применяются для полнотекстового поиска и поиска по массивам, JSON и триграммам. Обеспечивают высокую скорость при поиске в больших объемах данных.

Подобно GiST и SP-GiST, индексы GIN могут поддерживать различные определённые пользователем стратегии и в зависимости от них могут применяться с разными операторами. Например, стандартный дистрибутив включает класс для массивов.

**==BRIN==**. Индексы зон блоков хранят обобщённые сведения о значениях, находящихся в физически последовательно расположенных блоках таблицы. Поэтому такие индексы наиболее эффективны для столбцов, значения в которых хорошо коррелируют с физическим порядком столбцов таблицы. Также поддерживает различные стратегии.

BRIN-индексы используются для компактного представления больших объемов данных, особенно когда значения в таблице имеют определенный порядок. Они эффективны для хранения и обработки временных рядов и географических данных.

---

Индексы можно создавать и по нескольким столбцам таблицы. Для этого в поле аргумента столбца индекса, нужно перечислить желаемые столбцы через запятую.

В настоящее время составными могут быть только индексы типов BTree, GiST, GIN, BRIN.
Составной индекс BTree может применяться с любым подмножеством столбцов, но наиболее эффективен он при ограничениях по ведущим левыми столбцам. 

Точное правило состоит в том, что сканируемая область индекса определяется условиями равенства с ведущими столбцами и условиями неравенства с первым столбцом, не участвующим в условии равенства.

---

Помимо простого поиска строк для выдачи в результате запроса, индексы также могут применяться для сортировки строк в определённом порядке. Это позволяет учесть предложение `ORDER BY` в запросе, не выполняя сортировку дополнительно.

Из всех типов индексов, сортировать данные могут только BTree. Индексы других типов возвращают строки в неопределённом, зависящем от реализации порядке.

Планировщик может выполнить сортировку, либо просканировав существующий индекс, либо просканировав таблицу в физическом порядке выполнив команду явно. 

Для запроса, требующего сканирования большой части таблицы, явная сортировка скорее всего будет быстрее, чем применение индекса, так как при последовательном чтении она потребует меньше операций ввода/вывода.

Очевидно, что индексы с нестандартными правилами сортировки весьма специфичны, но иногда они могут ускорить определённые запросы. Стоит ли вводить такие индексы, зависит от того, как часто выполняются запросы с необычным порядком сортировки.

---

Индексы также могут обеспечивать уникальность значения в столбце или уникальность сочетания значений в нескольких столбцах. В настоящее время обеспечение уникальности поддерживают только индексы с типом BTree.

```sql
CREATE UNIQUE INDEX index_name ON table_name (col) [ NULLS [ NOT ] DISTINCT ];
```

Если индекс создаётся как уникальный, в таблицу нельзя будет добавить несколько строк с одинаковыми значениями ключа индекса. По умолчанию значения NULL в уникальном столбце считаются не равными друг другу, так что в таком столбце может быть несколько значений NULL. Параметр `NULLS NOT DISTINCT` изменяет это правило.

Когда для таблицы определяется ограничение уникальности или первичный ключ, PostgreSQL автоматически создаёт уникальный индекс по всем столбцам. Такой индекс и является механизмом, который обеспечивает выполнение ограничения.

>[!info] Примечание
>Для уникальных столбцов не нужно вручную создавать отдельные индексы - они просто продублируют индексы, созданные базой данных автоматически.

---

Индекс можно создать не только по столбцу нижележащей таблицы, но и по функции или скалярному выражению с одним или несколькими столбцами таблицы. Это позволяет быстро находить данные в таблице по результатам вычислений.

```sql
CREATE INDEX index_name ON table_name (lower(col));
```

Вышеописанный индекс ускорит запросы к текстовому столбцу, к которому применяется понижения регистра, то есть в запросе присутствует `WHERE lower(col)`.

Если мы объявим этот индекс уникальным (`UNIQUE`), он не даст добавить строки, в которых значения столбца различаются только регистром. Таким образом, индексы по выражениям можно использовать ещё и для обеспечения ограничений уникальности, которые нельзя записать как простые ограничения уникальности.

Поддержка индексируемых выражений обходится довольно дорого, так как эти выражения должны вычисляться при каждом добавлении строки и при каждом изменении без оптимизации Heap-Only Tuples. Зато при поиске индексируемое выражение не вычисляется повторно, так как его результат уже сохранён в индексе.

---

Система также поддерживает частичные индексы. Частичный индекс - это индекс, который строится по подмножеству строк таблицы, определяемому условным выражением (оно называется предикатом частичного индекса).

Такой индекс содержит записи только для строк, удовлетворяющих предикату. Частичные индексы довольно специфичны, но в ряде ситуаций они могут быть полезны.

Частичные индексы могут быть полезны тем, что позволяют избежать индексирования распространённых значений. Так как при поиске распространённого значения индекс всё равно не будет использоваться, хранить эти строки в индексе нет смысла.

```sql
CREATE INDEX index_name ON table_name (column) WHERE condition;
```

Заметьте, что при таком определении частичного индекса необходимо, чтобы распространённые значения были известны заранее, так что такие индексы лучше использовать, когда распределение данных не меняется.

Хотя такие частичные индексы можно пересоздавать время от времени, подстраиваясь под новое распределение значений, это значительно усложняет поддержку.

У вас может возникнуть желание создать множество неперекрывающихся частичных индексов, в качестве замены секционированию таблицы. Но так делать не следует!

При поиске в большем индексе может потребоваться опуститься на несколько уровней ниже, чем при поиске в меньшем частичном, но это почти гарантированно будет дешевле, чем выбрать при планировании из всех частичных индексов подходящий. 

Сложность с выбором индекса объясняется тем, что система не знает, как взаимосвязаны все построенные частичные индексы, и ей придётся проверять каждый из них, чтобы понять, соответствует ли он текущему запросу.

Если ваша таблица настолько велика, что создавать один индекс кажется действительно плохой идей, рассмотрите возможность использования секционирования. Когда применяется этот механизм, система понимает, что таблицы и индексы не перекрываются, и может выполнять запросы гораздо эффективнее.

---

Все индексы в PostgreSQL являются вторичными, что значит, что каждый индекс хранится вне области основных данных таблицы, которая в терминологии PostgreSQL называется кучей таблицы. Это значит, что при обычном сканировании индекса для извлечения каждой строки необходимо прочитать данные и из индекса, и из кучи.

 Более того, тогда как элементы индекса, соответствующие заданному условию, обычно находятся в индексе рядом, строки таблицы могут располагаться в куче произвольным образом. Таким образом, обращение к куче при поиске по индексу влечёт множество операций произвольного чтения кучи, которые могут обойтись недёшево.

Чтобы решить эту проблему с производительностью, есть механизм `IndexOnly`, при котором результат запроса получается из самого индекса, без обращения к куче.

Для применения этого метода есть два фундаментальных ограничения: Тип индекса должен поддерживать механизм `IndexOnly`. Его всегда поддерживает BTree, а также GiST и SP-GiST в зависимости от класса операторов. Также сам запрос должен обращаться и извлекать только данные столбцов по которым построен индекс.

Существует и ещё одно требование для сканирования таблицы: все возвращаемые строки доступны в снимке MVCC запроса. Таким образом, такой тип сканирования даст выигрыш, только если для значительной части страниц в куче таблицы установлены биты полной видимости. Удовлетворяющие таблицы встречаются достаточно часто.

Чтобы эффективно использовать возможность сканирования только индекса, вы можете создавать `покрывающие индексы`. Такие индексы специально предназначены для включения столбцов, которые требуются часто выполняемых запросах. 

Так как в запросах обычно нужно получить не только столбцы, по которым выполняется поиск, PostgreSQL позволяет создать индекс, в котором некоторые столбцы будут просто дополнительной нагрузкой, но не войдут в поисковый ключ.

Данный механизм в базе данных реализуется предложением `INCLUDE`, в котором перечисляются дополнительные столбцы при построении индекса.

```sql
CREATE INDEX index_name ON table(col) INCLUDE (add_col);
```

---

Хотя индексы не требуют обслуживания, это не избавляет от необходимости проверять, как и какие индексы используются на самом деле в реальных условиях. 

Узнать, как отдельный запрос использует индексы, можно с помощью `EXPLAIN`. Также возможно собрать общую статистику об использовании индексов на сервере.

Всегда начинайте исследование с `ANALYZE`. Эта команда собирает статистические данные о распределении значений в таблице, которые необходимы для оценивания числа строк, возвращаемых запросов. А это число, нужно планировщику, чтобы оценить реальные затраты для всевозможных планов выполнения запроса.

Без реальной статистики, планировщик будет принимать некоторые значения по умолчанию. Такие значения почти всегда оказываются далекими от реальности.

Если система начинает использовать индекс только под принуждением, то либо система права и применять индекс в самом деле неэффективно, либо оценка стоимости применения индекса не соответствует действительности. Тогда следует замерить время выполнения с индексами и без с помощью`EXPLAIN ANALYZE`. 

Без указания таблицы и столбцов команда `ANALYZE` обрабатывает все таблицы и материализованные представления в текущей базе данных. Со списком `ANALYZE` обрабатывает только указанные в нём таблицы. Дополнительно можно задать для таблицы список имён столбцов, тогда статистика будет собираться только по ним.

```sql
ANALYZE [ VERBOSE ] table_name (col_1, ..., col_n);
```

[[DataBase/🟡Base|🟡Base]]