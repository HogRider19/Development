Быстродействие запросов зависит от многих факторов. На некоторые из них могут воздействовать пользователи, а другие фундаментальными особенностями системы.

Для любого запроса разрабатывается план запроса. Выбор правильного плана крайне важен для хорошей производительности, поэтому в системе работает сложный планировщик, задача которого подобрать хороший план. Узнать, какой план был выбран для какого-либо запроса, можно с помощью команды `EXPLAIN`.

Структура плана запроса представляет собой дерево узлов плана. Узлы на нижнем уровне дерева - это узлы сканирования, которые возвращают необработанные данные.
Разным типам доступа к таблице соответствуют разные узлы: последовательное сканирование, сканирование индекса и сканирование битовой карты.

Если запрос требует объединения, агрегатных вычислений, сортировки или других операций с строками, над узлами сканирования появляются узлы, обозначающие это.

В выводе команды `EXPLAIN` для каждого узла в дереве плана отводится одна строка, где показывается базовый тип узла плюс оценка стоимости выполнения данного узла, которую сделал для него планировщик. В самой первой строке выводится общая стоимость выполнения для всего плана; именно его минимизирует планировщик.

Планировщик запросов строит план, основываясь на определенных в нем константах и статических данных таблицы, полученных после последнего выполнения `ANALYZE`.
Комбинация команд `EXPLAIN ANALYZE` выводит план и также выполняет запрос.

В некоторых планах запросов некоторый внутренний узел может выполняться неоднократно. В таких случаях значение `loops` показывает, сколько всего раз выполнялся этот узел, а время и строки вычисляется как среднее по итерациям.

Статические данные пересчитываются не только при явном выполнении анализа, но и также при создании индексов и некоторых командах языка определения данных.

```sql
EXPLAIN query;              // Вывод плана запроса
EXPLAIN ANALYZE query;      // Вывод плана запроса и его реального выполнения

ANALYZE table_name;         // Обновление статических данных таблицы
```

Если планировщик запросов понимает, что составление плана может занять очень много времени, он переключается с полного поиска на алгоритм генетического вероятностного поиска в ограниченном числе вариантов. Генетический поиск выполняется быстрее, но не гарантирует, что найденный план будет наилучшим.

---

При выполнении запроса, планировщик может выбирать разные виды сканирования узла в зависимости от ситуации. Ему доступны следующие виды сканирования: последовательное, индексное, исключительно индексное и по битовой карте.

**==SeqScan==**. Последовательное сканирование является последовательным перебором всех строк таблицы в поисках интересующего значения. В случаях когда запрос является высокоагрегирующим, последовательное сканирование может быть эффективнее индексного, так как оно читает таблицу большими блоками данных.

**==IndexScan==**. Индексное сканирование используется тогда, когда планировщик определяет запрос как низкоагрегирующий. Операция обычно очень быстрая, особенно быстро она отрабатывает в начале, однако, произвольный доступ к данным  гораздо быстрее выполняется при операции последовательного поиска.

**==IndexOnlyScan==**. Это индексное сканирование со всеми его этапами, за исключением доступа к таблице данных. Очень быстрая операция, но может применяться только тогда, когда индекс включает все необходимые для выборки поля, и дополнительный доступ к таблице не требуется. Подробнее описан в заметке с индексами.

**==BitmapScan==**. Сканирование с использованием битовых карт используется, когда при индексном сканировании нужно выбрать много записей за раз. Применяется, кода выборка слишком большая для поиска по индексу, но при этом она содержит достаточно строк для появления издержек последовательного сканирования. 

При чтении битовой карты, планировщик вытаскивает указатели всех интересующих данных из индекса, затем кластеризует их по физическому расположению на диске, а затем выполняет последовательное чтение с диска каждого кластера.

Такой подход гарантирует, что каждая страница в таблице будет прочитано лишь единожды. Однако требует дополнительных ресурсов на поддержание, поэтому не применяется, если запрос эффективно выполнить только индексным сканированием.

Также его планировщик может отказаться от способа чтения битовой карты в случае, если запрос подразумевает сортировку результата, так как такое сканирование вернет строки в порядке их физического расположения на носителе информации.

---

Часто бывает, когда медленное выполнение запросов объясняется плохим выбором плана из-за связанных столбцов по значениям, фигурирующих в условиях запроса. 
Обычно планировщик полагает, что несколько условий не зависят друг от друга, а это предположение оказывается неверным, когда значения этих столбцов коррелируют. 

Обычная статистика, которая строится по отдельным столбцам, не может выявить корреляции между столбцами. Однако PostgreSQL имеет возможность вычислять многовариантную статистику, которая может собирать для этого информацию.

Так как число возможных комбинаций столбцов очень велико, автоматически вычислять многовариантную статистику непрактично. Вместо этого можно создать объекты расширенной статистики, для наборам столбцов, представляющих интерес.

Объекты статистики создаются командой `CREATE STATISTICS`. При создании такого объекта просто добавляется запись в каталоге, выражающая востребованность этой статистики. Собственно сбор данных выполняется процедурой `ANALYZE` .

Объекты расширяющей статистики могут быть разных типов для разных ситуаций. Столбцы связаны функциональной зависимостью, требуется статистика о количестве комбинаций разных столбцов, требуется оценка частых попарных значений в столбцах. 

**==Функциональные зависимости==**. Простейший вид расширенной статистики отслеживает функциональные зависимости. Мы называем столбец один столбец функционально зависимым от второго, если знания значения во втором достаточно для определения значения в первом. В полностью нормализованной базе данных функциональные зависимости должны существовать только в первичных ключах. 

Оценивать степень зависимости между всеми наборами столбцов очень дорого, поэтому сбор данных ограничивается только теми группами столбцов, которые фигурируют вместе в объекте статистики, определённом со свойством `dependencies`. 

При вычислении агрегированности запроса, в котором задействованы функционально зависимые столбцы, планировщик корректирует оценки агрегации, используя коэффициенты зависимостей, чтобы не допустить недооценки размера результата.

```sql
CREATE STATISTICS stat_name (dependencies) ON col_1, col_2 FROM table_name;
```

**==Многовариантные значения==**. Статистика по столбцу содержит число уникальных значений в каждом отдельном столбце. Оценки числа различных значений в сочетании нескольких столбцов например в `GROUP BY a, b`, часто оказываются ошибочными, когда планировщик имеет статистические данные только по отдельным столбцам.

Данные собираются только по тем группам столбцов, которые указаны в определении объекта статистики, создаваемого со свойством `ndistinct`. Данные будут собираться по всем возможным сочетаниям нескольких столбцов из перечисленных.

Объект статистики `ndistinct` рекомендуется создавать только для тех сочетаний столбцов, которые действительно используются при группировке, и только когда неправильная оценка числа групп может привести к выбору плохих планов.

```sql
CREATE STATISTICS stat_name (ndistinct) ON col_1, col_2 FROM table_name;
```

**==Многовариантные списки==**. Ещё один тип статистики, сохраняемой для каждого столбца, представляют списки частых значений MCV. Такие списки позволяют получать очень точную оценку для отдельных столбцов, но для запросов, содержащих условия с несколькими столбцами, полученная по ним оценка может быть значительно искажена.

Для улучшения таких оценок операция `ANALYZE` может собирать списки MCV по комбинациям столбцов. Данные для них собираются только по тем группам столбцов, которые фигурируют в объекте статистики, определённом с указанием `mcv`.

Объекты статистики MCV рекомендуется создавать только для тех сочетаний столбцов, которые действительно используются в условиях вместе, и только когда неправильная оценка числа групп может привести к выбору плохих планов выполнения запросов.

```sql
CREATE STATISTICS stat_name (mcv) ON col_1, col_2 FROM table_name;
```