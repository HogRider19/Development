**DML (Data Manipulation Language)**. Это язык работы с данными. Как правило, применяемые команды нужны для внесения изменений в уже существующие данные, их удаления и сохранения, обновления записей и т.д.

**==INSERT==**. После создания таблицы она не содержит никаких данные. По сути данные добавляются в таблицу по одной строке. При указании значения только некоторых столбцов, создаётся полная строка. Чтобы добавить строку используется команда `INSERT`. В этой команде необходимо указать имя таблицы и значения столбцов.

```sql
INSERT INTO table_name VALUES (val_1, ..., val_n);
INSERT INTO table_name (f_1, ..., f_n) VALUES (val_1, ..., val_n);
```

==**UPDATE**==. Модификация данных, уже сохранённых в БД, называется изменением. Изменить можно все строки таблицы, либо подмножество всех строк, либо только избранные строки. Каждый столбец при этом можно изменять независимо от других.

Для изменения данных в существующих строках используется команда `UPDATE`. Ей требуется следующая информация: имя таблицы и изменяемого столбца, новое значение столбца, критерий отбора изменяемых строк.

```sql
UPDATE table_name SET f_1 = val_1, ..., f_n = val_n WHERE condition;
```

**==DELETE==**. Так же, как добавлять данные можно только целыми строками, так и удалять их можно только по строкам. Для удаления строк используется команда `DELETE`. Если при удалении строк таблицы не указывается условие, тогда удаляются все строки.

```sql
DELETE FROM table_name WHERE condition;
DELETE FROM table_name;
```

**==RETURNING==**. Иногда бывает полезно получать данные из модифицируемых строк в процессе их обработки. Это возможно с использованием предложения `RETURNING`, которое можно задать для команд `INSERT`, `UPDATE` и `DELETE`. 

Применение `RETURNING` позволяет обойтись без дополнительного запроса к базе для сбора данных и это особенно ценно, когда трудно получить изменённые строки.

В предложении `RETURNING` допускается то же содержимое, что и в выходном списке команды `SELECT`. Оно может содержать имена столбцов целевой таблицы команды или значения выражений с этими столбцами.

Использование `RETURNING` вместе с `INSERT` может быть полезно при использовании вычисляемых значений. Например при использовании `serial` и `uuid` полей.

```sql
CREATE TABLE users (id serial primary key, firstname text, lastname text);
INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;
```

---

Процесс или команда получения данных из базы данных называется запросом. В SQL запросы формулируются с использованием зарезервированной команды `SELECT`.

```sql
[WITH] SELECT [DISTINCT] f_1, ..., f_n FROM table_expression [sorting]
```

Табличное выражение вычисляет таблицу. Это выражение содержит команду `FROM`, за которой могут следовать ключевые слова `WHERE`, `GROUP BY` и `HAVING`.

Тривиальные табличные выражения просто ссылаются на физическую таблицу, её называют также базовой, но в более сложных выражениях такие таблицы можно преобразовывать и комбинировать самыми разными способами.

В результате преобразований, которые осуществляются при вычислении табличного выражения запроса, образуется виртуальная таблица, строки которой передаются списку выборки, вычисляющему выходные строки запроса.

**==FROM==**. Команда `FROM` образует таблицу из одной или нескольких ссылок на таблицы, разделённых запятыми. Табличной ссылкой может быть имя таблицы, производная таблица, например подзапрос, соединение таблиц или сложная их комбинация.

Если в предложении `FROM` перечисляются несколько ссылок, для них применяется перекрёстное соединение, то есть декартово перемножение строк.  

Если в табличной ссылке указывается таблица, являющаяся родительской в иерархии, то в результате будут получены строки не только этой таблицы, но и всех её дочерних таблиц. Чтобы выбрать родительскую таблицу, перед её именем нужно добавить `ONLY`.

**==JOIN==**. Соединённая таблица ­­­­­­- это таблица, полученная из двух других реальных или производных от них таблиц в соответствии с правилами соединения конкретного типа.

```sql
table_1 JOIN_TYPE table_2 [JOIN_CONCITION (ON / USING)]
```

Сами аргументы в соединении могут быть результатами соединения. Для однозначного определения порядка соединений предложения `JOIN` можно заключать в скобки. Если скобки отсутствуют, предложения `JOIN` обрабатываются слева направо.

**CROSS JOIN**. Соединённую таблицу образуют все возможные сочетания строк из обоих таблиц то есть их декартово произведение, а набор её столбцов также определяет набор столбцов полученный из первой и второй таблицы.

**INNER JOIN**. Результирующая таблицы будет содержать соединенные строки из двух таблиц, для которых возможно было выполнить соединение.

**LEFT JOIN**. Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из первой таблицы, которым нет соответствия во второй, а вместо значений столбцов второй таблицы подставляется NULL.

**RIGHT JOIN**. Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из второй таблицы, которым нет соответствия в первой, а вместо значений столбцов первой таблицы подставляется NULL.

**FULL JOIN**. Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из обоих таблиц, которым нет соответствия, вместо неопределённых значений полей подставляется NULL .

Предложение `ON` определяет наиболее общую форму условия соединения: в нём указываются выражения логического типа. Пара строк из обоих таблиц будут соответствуют друг другу, если выражение `ON` возвращает для них true.

Также выражение с `ON` можно сократить с использованием `USING`, данное выражение определяет условие равенство двух столбцов `USING(col_1, col_2)` или `USING(col)`. Также это выражение исключаются избыточные столбцы, то есть столбцы по которым вычислялось соединение в таблице, будут объединены в один столбец.

Также и у выражение `USING` есть сокращение в виде `NATURAL`. Это выражение образует соединение из всех имён столбцов, существующих в обеих входных таблицах. Если столбцов с одинаковыми именами нет, то работает как перекрестное соединение.

```sql
SELECT * FROM table_1 CROSS JOIN table_2;
SELECT * FROM table_1 INNER JOIN table_2 ON table_1.f1 = table_2.f2;
SELECT * FROM table_1 LEFT  JOIN table_2 USING(f1, f2);
SELECT * FROM table_1 RIGHT JOIN table_2 USING(f);
SELECT * FROM table_1 FULL  JOIN table_2 NATURAL;
```

**==AS==**. Таблицам и ссылкам на сложные таблицы в запросе можно дать временное имя, по которому к ним можно будет обращаться в рамках запроса. Такое имя называется псевдонимом таблицы. Псевдоним становится новым именем таблицы в рамках текущего запроса, то есть после назначения исходное имя использовать нельзя.

```sql
SELECT * FROM table_link AS new_temp_table_name;
```

В основном псевдонимы используются для удобства, они бывают необходимы, когда таблица соединяется сама с собой или при обращении к подзапросу.

```sql
SELECT * FROM people AS m JOIN people AS c ON m.id = c.mother_id;
SELECT * FROM (table_name AS a CROSS JOIN table_name) AS b;
```

**==SUBQUERY==**. Подзапросом является иной запрос к базе данных, выполненный в рамках текущего запроса, подзапрос должен заключаться в круглые скобки, ему может назначаться псевдоним таблицы или при необходимости псевдоним столбцов.

```sql
FROM [LATERAL] (SELECT * FROM table_name) AS subquery_name;
```

Согласно стандарту SQL подзапросу должен обязательно назначаться псевдоним таблицы. PostgreSQL позволяет опускать `AS` и псевдоним, тем не менее хорошей практикой считается указывать псевдоним в коде SQL.

Перед подзапросами в предложении `FROM` можно добавить ключевое слово `LATERAL`. Это позволит ссылаться в них на столбцы предшествующих элементов списка `FROM`.

**==WHERE==**. После обработки предложения `FROM` каждая строка полученной виртуальной таблицы проходит проверку по условию ограничения. Если результат условия равен true, эта строка остаётся в выходной таблице, а иначе отбрасывается.

```sql
SELECT ... FROM fdt WHERE c1 > 5;
SELECT ... FROM fdt WHERE c1 IN (1, 2, 3);
SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2);
```

**==GROUP BY==**. Строки порождённой входной таблицы, прошедшие фильтр `WHERE`, можно сгруппировать с помощью зарезервированного предложения `GROUP BY`. 

Выражение `GROUP BY` группирует строки таблицы, объединяя их в одну группу при совпадении значений во всех перечисленных столбцах.

Порядок, в котором указаны столбцы, не имеет значения. В результате наборы строк с одинаковыми значениями преобразуются в отдельные строки представляющие группы.

Это может быть полезно для устранения избыточности выходных данных или для вычисления агрегатных функций, применённых к этим группам. При группировке выходную таблицу могут формировать только столбцы к которым применена группировка и столбцы составленные агрегацией других столбцов группы.  

Группировка без агрегатных выражений по сути выдаёт набор различающихся значений столбцов. Этот же результат можно получить с помощью `DISTINCT`.

В стандарте SQL можно группировать только по столбцам исходной таблицы, но расширение PostgreSQL позволяет использовать в группировке столбцы из списка выборки. Также возможна группировка по выражениям, а не просто именам столбцов.

```sql
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
FROM products p LEFT JOIN sales s USING (product_id)
GROUP BY product_id, p.name, p.price;
```

**==HAVING==**. Если таблица была сгруппирована с помощью `GROUP BY`, но интерес представляют только некоторые группы, отфильтровать их можно с помощью предложения `HAVING`, действующего подобно предложению `WHERE`.

В предложении `HAVING` могут использоваться и группирующие выражения, и выражения, не участвующие в группировке, если они агрегируются.

```sql
SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;
```

**==ORDER BY==**. После того как запрос выдал таблицу результатов, её можно отсортировать. Если сортировка не задана, строки возвращаются в неопределённом порядке. Фактический порядок строк в этом случае будет зависеть от плана соединения и сканирования, а также от порядка данных на диске, поэтому полагаться на него нельзя.

Когда указывается несколько выражений, последующие значения позволяют отсортировать строки, в которых совпали все предыдущие значения. 

Сортировку можно дополнить командами `ASC` или `DESC`, которые выбирают сортировку по возрастанию или убыванию. По умолчанию принят порядок по возрастанию (`ASC`). По умолчанию значения NULL считаются больше любых других.

```sql
SELECT a, b FROM table_name ORDER BY a + b ASC, c DESC;
```

**==LIMIT==**. Указания `LIMIT` и `OFFSET` позволяют получить только часть строк из тех, что выдал остальной запрос. Данные команды указываются после оператора сортировки.

Оптимизатор запроса учитывает ограничение LIMIT, строя планы выполнения запросов, поэтому вероятнее всего порядок строк будут меняться при разных аргументах, если результат запроса не был отсортирован оператором сортировки.

Строки, пропускаемые командой `OFFSET`, тем не менее должны вычисляться на сервере. Таким образом, при больших значениях `OFFSET` работает неэффективно.