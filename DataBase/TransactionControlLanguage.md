**TCL (Transaction Control Language)**. Это язык управления транзакциями. TCL запрос используется, когда необходимо объединить несколько команд DML, направленных на изменение данных, в наборы атомарных операций.

---

**Транзакция** - это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объединяет последовательность действий в одну атомарную единицу. Если она не завершится, ни один из результатов этих действий не сохранится в базе данных.

Транзакция определяется набором команд, окружённым командами `BEGIN` и `COMMIT`. Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её, мы можем выполнить команду `ROLLBACK`, и все наши изменения будут отменены.

```sql
BEGIN;
...
COMMIT;
```

Операторами в транзакции можно также управлять н)а более детальном уровне, используя точки сохранения. Точки сохранения позволяют выборочно отменять некоторые части транзакции и фиксировать все остальные. 

Определив точку сохранения с помощью `SAVEPOINT`, при необходимости вы можете вернуться к ней с помощью команды `ROLLBACK TO`. Все изменения в базе данных, произошедшие после точки сохранения и до момента отката, отменяются.

```sql
SAVEPOINT savepoint_name;
ROLLBACK TO savepoint_name;
```

Более того, `ROLLBACK TO` - это единственный способ вернуть контроль над блоком транзакций, оказавшимся в прерванном состоянии из-за ошибки системы, не считая возможности полностью отменить её и начать снова.

---

PostgreSQL предоставляет разработчикам богатый набор средств для управления конкурентным доступом к данным. Внутри он поддерживает целостность данных, реализуя модель MVCC (Multiversion Concurrency Control). 

Это означает, что каждый SQL-оператор видит снимок данных на определённый момент времени, вне зависимости от текущего состояния данных. Это защищает операторы от несогласованности данных, возможной, если другие конкурирующие транзакции внесут изменения в те же строки данных. 

Основное преимущество использования модели MVCC по сравнению с блокированием заключается в том, что блокировки MVCC, полученные для чтения данных, не конфликтуют с блокировками, полученными для записи.

PostgreSQL гарантирует это даже для самого строгого уровня изоляции транзакций, используя инновационный уровень изоляции SSI (Serializable Snapshot Isolation).

Для приложений, которым в принципе не нужна полная изоляция транзакций и которые предпочитают явно определять точки конфликтов, также есть средства блокировки на уровне таблиц и строк.

Однако при правильном использовании MVCC обычно обеспечивает лучшую производительность, чем блокировки. Кроме этого, приложения могут использовать рекомендательные блокировки, не привязанные к какой-либо одной транзакции.

---

Стандарт описывает следующие особые условия, недопустимые для различных уровней изоляции при выполнении конкурентных запросов к базе данных:

**==Грязное чтение==**. Эффект когда одна транзакция читает добавленные или изменённые данные другой транзакции, которая впоследствии не подтвердится (откатится) .

**==Неповторяемое чтение==**. После чтения данных одной транзакцией, вторая транзакция изменяет и согласовывает данные первой транзакции, в результате получается что первая транзакция работает с не валидными данными.

**==Фантомное чтение==**. Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время.

**==Аномалия сериализации==**. Результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди. То есть при одновременном изменении блока данных разными транзакциями теряются все изменения, кроме последнего.

![[Pasted image 20240119231039.png]]

---

В PostgreSQL вы можете запросить любой из четырёх уровней изоляции транзакций, однако внутри реализованы только три различных уровня, то есть режим Read Uncommitted в PostgreSQL действует как Read Committed.

Причина этого в том, что только так можно сопоставить стандартные уровни изоляции с реализованной архитектурой многоверсионного управления конкурентным доступом.

>[!info] Важно
>Поведение некоторых функций и типов данных в транзакциях особое. В частности, изменения автоинкеминтирующих столбцов немедленно видны во всех остальных транзакциях и не откатываются назад, если транзакция прерывается.

**==Read Committed==**.  Уровень изоляции транзакции, выбираемый по умолчанию. В транзакции, работающей на этом уровне, запрос видит только те данные, которые были зафиксированы до начала запроса. Он никогда не увидит незафиксированных данных или изменений, внесённых параллельными транзакциями в процессе запроса.

Однако запрос видит результаты изменений, внесённых ранее в этой же транзакции, даже если они ещё не зафиксированы. Также заметьте, что два последовательных оператора `SELECT` могут видеть разные данные даже в рамках одной транзакции, если какие-то другие транзакции зафиксируют изменения после запуска первого запроса.

**==Repeatable Read==**. В данном уровне видны только те данные, которые были зафиксированы до начала транзакции, но не видны незафиксированные данные и изменения, произведённые другими транзакциями в процессе выполнения текущей.

Однако каждый запрос будет видеть эффекты предыдущих изменений в своей транзакции, несмотря на то, что они не зафиксированы. Это самое строгое требование, которое стандарт SQL вводит для этого уровня изоляции, он предотвращаются все явления, за исключением аномалий сериализации.

Как было сказано выше, это не противоречит стандарту, так как он определяет только минимальную защиту, которая должна обеспечиваться на каждом уровне изоляции.

Этот уровень отличается от Read Committed тем, что запрос в транзакции данного уровня видит снимок данных на момент начала первого оператора в транзакции, а не начала текущего оператора. Таким образом, последовательные команды запроса в одной транзакции видят одни и те же данные. Они не видят изменений, внесённых и зафиксированных другими транзакциями после начала их текущей транзакции.

При взаимном изменении данных с фиксацией может произойти откат текущей выполняемой транзакции. Приложения, использующие этот уровень, должны быть готовы повторить транзакции в случае сбоев сериализации.

Заметьте, что потребность в повторении транзакции может возникнуть, только если эта транзакция изменяет данные. В других случаях, конфликтов сериализации не бывает.

**==Serializable==**. Обеспечивает самую строгую изоляцию транзакций. На этом уровне моделируется последовательное выполнение всех зафиксированных транзакций, как если бы транзакции выполнялись одна за другой, последовательно, а не параллельно. 

Однако, как и на уровне Repeatable Read, на этом уровне приложения должны быть готовы повторять транзакции из-за сбоев сериализации. 

Фактически этот режим изоляции работает так же, как и Repeatable Read, только он дополнительно отслеживает условия, при которых результат выполняемых сериализуемых транзакций может не согласовываться с результатом по очереди.

Это отслеживание не привносит дополнительных препятствий для выполнения, кроме тех, что присущи режиму Repeatable Read, но тем не менее создаёт некоторую добавочную нагрузку, а при выявлении исключительных условий регистрируется аномалия сериализации и происходит сбой сериализации.