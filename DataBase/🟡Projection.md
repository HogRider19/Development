При проектировании реляционной базы данных, данные разных таблиц объединяются с помощью определенных связей. Связи создаются с помощью внешних ключей.  
Внешний ключ является атрибутом или набором атрибутов, которые ссылаются на колонку другой таблицы. Другими словами, это что-то вроде указателя на строку.

Связи в реляционный базе данных разделяются на: `ManyToMany`, `OneToMany`, `OneToOne`.
При этом связи один к одному и один ко многим, могут быть реализованы как с обязательной связью двух таблиц, так и без обязательной связи.

**==OneToMany==**. В типе связей один ко многим одной записи первой таблицы соответствует несколько записей в другой таблице. В таблице, которая будет представлять множественные элементы, создается колонка, которая будет хранить идентификаторы другой таблицы, на нее накладывается ограничение внешнего ключа.

```sql
CREATE TABLE table_1 (
	id serial PRIMARY KEY, 
);

CREATE TABLE table_2 (
	id serial PRIMARY KEY,
	table_1_id int FORIGN KEY REFERENCES table_1(table_1.id),
);
```

**==OneToOne==**. Связь один к одному образуется, когда ключевой столбец идентификатор присутствует в другой таблице, в которой тоже является ключом либо свойствами столбца задана его уникальность. То есть данная связь реализуется также, как и связь один ко многим, но на столбец идентификаторов наложено ограничение уникальности.

```sql
CREATE TABLE table_1 (
	id serial PRIMARY KEY, 
);

CREATE TABLE table_2 (
	id serial PRIMARY KEY,
	table_1_id int FORIGN KEY REFERENCES table_1(table_1.id) UNIQUE,
);
```

На практике связь один к одному наблюдается не часто. Например, она может быть, когда требуется разделить данных одной таблицы на несколько отдельных таблиц.

**==ManyToMany==**. Если нескольким записям из одной таблицы соответствует несколько записей из другой таблицы, то такая связь называется многие ко многим и организовывается посредством связывающей таблицы.

```sql
CREATE TABLE table_1 (id serial PRIMARY KEY);
CREATE TABLE table_2 (id serial PRIMARY KEY)

CREATE TABLE table_12 (
	table_1_id int FORIGN KEY REFERENCES table_1(table_1.id),
	table_2_id int FORIGN KEY REFERENCES table_2(table_2.id),
	PRIMARY KEY (table_1_id, table_2_id),
);
```

---

Нормализация отношений представляет собой процесс минимизации избыточности данных и модификацию структуры отношений таким образом, чтобы процесс работы с ними не был обременён различными посторонними сложностями.

Денормализация в свою очередь представляет собой композицию данных путем понижения уровня нормальной формы с целью оптимизации сложных запросов.

Для описания уровня нормализации, применяется характеристика нормальной формы. Нормальная форма представляет собой свойство отношения, характеризующее его с точки зрения избыточности. Всего существует шесть нормальных форм. На практике  реализуются только три. Каждая нормальная формы требует выполнения предыдущих. 

**==1НФ==**. Отношение находится в первой нормальной форме, если все его атрибуты атомарные, то есть если ни один из его атрибутов нельзя разделить на более простые атрибуты, которые соответствуют каким-то другим свойствам описываемой сущности.

То есть первая нормальная форма утверждает, что сущность должна быть составлена только из скалярных типов. Также она запрещает иметь строки дубликаты в таблице.

**==2НФ==**. Отношение находится во второй нормальной форме тогда и только тогда, когда оно находится в первой нормальной форме, содержит первичный ключ и каждый его не ключевой атрибут неприводимо зависим от первичного ключа.

То есть таблица не должна содержать атрибутов, которые могли бы быть описаны лишь частью составного первичного ключа, а только первичным ключом целиком.
Если первичный ключ простой, то отношение всегда входит во вторую форму.

**==3НФ==**. Отношение находится в третьей нормальной форме, когда удовлетворяет второй  форме и каждый не ключевой атрибут зависит только от первичного ключа.

Проще говоря, поля которые зависят не от первичного ключа, а от одного из других не ключевых полей, следует выносить в отдельные связанные таблицы.

**==4НФ==**. Отношение находится в третьей нормальной форме, когда удовлетворяет третьей форме и в таблицах отсутствуют нетривиальные многозначные зависимости.

В таблицах многозначная зависимость выглядит следующим образом: начнем с того, что таблица должна иметь как минимум три столбца, при этом два из них между собой никак не связаны и не зависят друг от друга, но по отдельности зависят от третьего, и для каждого значения третьего есть множество значений первого и второго.

**==5НФ==**. Переменная отношения находится в пятой нормальной форме тогда и только тогда, когда она удовлетворяет четвертой форме и каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом этого отношения.

И таблица будет находиться в пятой нормальной форме, если при соединении этих трех таблиц, которые были получены декомпозицией таблицы в четвертой форме, будут формироваться ровно те же самые данные, что и в таблице до декомпозиции. 

Однако если этого происходить не будет, то есть данные будут отличаться, то в этом случае возникает так называемая зависимость соединения, то есть какое-то количество данных одного столбца зависит от части данных другого столбца. Таким образом, таблица находится в пятой форме, если она не содержит зависимости соединения.

**==6НФ==**. Отношение находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. То есть отношение находится в шестой нормальной форме тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь.

Каждая переменная отношения, которая находится в шестой нормальной форме, также находится и в пятой нормальной форме исходя их определения.

---

Когда база спроектирована бездумно и без четкого понимания цели,  она не просто не эффективна, но и дальнейшая работа с базой будет мучением, непроходимым лесом для пользователей. Вот несколько советов по конструированию базы данных, которые помогут создать полезный и простой в использовании продукт.

Всегда обращайте внимание, какие поля может редактировать пользователь, прежде чем выбирать их в качестве первичного ключа. Произойти может все что угодно, а вы должны гарантировать уникальность записи в базе данных. 

В идеале помимо суррогатного ключа  `artificial key`, должен присутствовать еще и натуральный или бизнес ключ  `natural key`. Если бизнес-ключ не уникален или он может изменяться, то первичным ключом должен быть суррогатный ключ.

Считается, что если пользователь не может точно идентифицировать запись с использованием бизнес ключа, то такую структуру таблицы стоит пересмотреть.

Чтобы эффективно организовать данные в БД, необходимо следовать набору рекомендаций  и нормализовать базу данных. С помощью нормализации вы избежите избыточности и обеспечите целостность данных, использующихся в приложении.  
  
Как всегда, всего должно быть в меру, даже нормализации. Излишняя нормализация в проектируемой базе данных негативно влияет на производительность системы.

Плохой практикой также считается наличие вычисляемых полей. Их наличие является признаком денормализованной архитектуры. Но в некоторых ситуациях их наличие оправдано, например когда такое поле приводит к росту производительности.

Также следует избегать композитных первичных ключей, так как они могут привести к  деградации производительности. Но во многих ситуациях их использование оправдано.
