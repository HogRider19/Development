**DML (Data Manipulation Language)**. Это язык работы с данными. Как правило, применяемые команды нужны для внесения изменений в уже существующие данные, их удаления и сохранения, обновления записей и т.д.

**==INSERT==**. После создания таблицы она не содержит никаких данные. По сути данные добавляются в таблицу по одной строке. При указании значения только некоторых столбцов, создаётся полная строка. Чтобы добавить строку используется команда `INSERT`. В этой команде необходимо указать имя таблицы и значения столбцов.

```sql
INSERT INTO table_name VALUES (val_1, ..., val_n);
INSERT INTO table_name (f_1, ..., f_n) VALUES (val_1, ..., val_n);
```

==**UPDATE**==. Модификация данных, уже сохранённых в БД, называется изменением. Изменить можно все строки таблицы, либо подмножество всех строк, либо только избранные строки. Каждый столбец при этом можно изменять независимо от других.

Для изменения данных в существующих строках используется команда `UPDATE`. Ей требуется следующая информация: имя таблицы и изменяемого столбца, новое значение столбца, критерий отбора изменяемых строк.

```sql
UPDATE table_name SET f_1 = val_1, ..., f_n = val_n WHERE condition;
```

**==DELETE==**. Так же, как добавлять данные можно только целыми строками, так и удалять их можно только по строкам. Для удаления строк используется команда `DELETE`. Если при удалении строк таблицы не указывается условие, тогда удаляются все строки.

```sql
DELETE FROM table_name WHERE condition;
DELETE FROM table_name;
```

**==RETURNING==**. Иногда бывает полезно получать данные из модифицируемых строк в процессе их обработки. Это возможно с использованием предложения `RETURNING`, которое можно задать для команд `INSERT`, `UPDATE` и `DELETE`. 

Применение `RETURNING` позволяет обойтись без дополнительного запроса к базе для сбора данных и это особенно ценно, когда трудно получить изменённые строки.

В предложении `RETURNING` допускается то же содержимое, что и в выходном списке команды `SELECT`. Оно может содержать имена столбцов целевой таблицы команды или значения выражений с этими столбцами.

Использование `RETURNING` вместе с `INSERT` может быть полезно при использовании вычисляемых значений. Например при использовании `serial` и `uuid` полей.

```sql
CREATE TABLE users (id serial primary key, firstname text, lastname text);
INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;
```

---

Процесс или команда получения данных из базы данных называется запросом. В SQL запросы формулируются с использованием зарезервированной команды `SELECT`.

```sql
[WITH] SELECT f_1, ..., f_n FROM table_expression [sorting]
```

Табличное выражение вычисляет таблицу. Это выражение содержит команду `FROM`, за которой могут следовать ключевые слова `WHERE`, `GROUP BY` и `HAVING`.

Тривиальные табличные выражения просто ссылаются на физическую таблицу, её называют также базовой, но в более сложных выражениях такие таблицы можно преобразовывать и комбинировать самыми разными способами.

В результате преобразований, которые осуществляются при вычислении табличного выражения запроса, образуется виртуальная таблица, строки которой передаются списку выборки, вычисляющему выходные строки запроса.

**==FROM==**. Команда `FROM` образует таблицу из одной или нескольких ссылок на таблицы, разделённых запятыми. Табличной ссылкой может быть имя таблицы, производная таблица, например подзапрос, соединение таблиц или сложная их комбинация.

Если в предложении `FROM` перечисляются несколько ссылок, для них применяется перекрёстное соединение, то есть декартово перемножение строк.  

Если в табличной ссылке указывается таблица, являющаяся родительской в иерархии, то в результате будут получены строки не только этой таблицы, но и всех её дочерних таблиц. Чтобы выбрать родительскую таблицу, перед её именем нужно добавить `ONLY`.

**==JOIN==**. Соединённая таблица ­­­­­­- это таблица, полученная из двух других реальных или производных от них таблиц в соответствии с правилами соединения конкретного типа.

```sql
table_1 JOIN_TYPE table_2 [JOIN_CONCITION (ON / USING)]
```

Сами аргументы в соединении могут быть результатами соединения. Для однозначного определения порядка соединений предложения `JOIN` можно заключать в скобки. Если скобки отсутствуют, предложения `JOIN` обрабатываются слева направо.

**CROSS JOIN**. Соединённую таблицу образуют все возможные сочетания строк из обоих таблиц то есть их декартово произведение, а набор её столбцов также определяет набор столбцов полученный из первой и второй таблицы.

**INNER JOIN**. Результирующая таблицы будет содержать соединенные строки из двух таблиц, для которых возможно было выполнить соединение.

**LEFT JOIN**. Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из первой таблицы, которым нет соответствия во второй, а вместо значений столбцов второй таблицы подставляется NULL.

**RIGHT JOIN**. Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из второй таблицы, которым нет соответствия в первой, а вместо значений столбцов первой таблицы подставляется NULL.

**FULL JOIN**. Сначала выполняется внутреннее соединение. Затем в результат добавляются все строки из обоих таблиц, которым нет соответствия, вместо неопределённых значений полей подставляется NULL .

Предложение `ON` определяет наиболее общую форму условия соединения: в нём указываются выражения логического типа. Пара строк из обоих таблиц будут соответствуют друг другу, если выражение `ON` возвращает для них true.

Также выражение с `ON` можно сократить с использованием `USING`, данное выражение определяет условие равенство двух столбцов `USING(col_1, col_2)` или `USING(col)`. Также это выражение исключаются избыточные столбцы, то есть столбцы по которым вычислялось соединение в таблице, будут объединены в один столбец.

Также и у выражение `USING` есть сокращение в виде `NATURAL`. Это выражение образует соединение из всех имён столбцов, существующих в обеих входных таблицах. Если столбцов с одинаковыми именами нет, то работает как перекрестное соединение.

```sql
SELECT * FROM table_1 CROSS JOIN table_2;
SELECT * FROM table_1 INNER JOIN table_2 ON table_1.f1 = table_2.f2;
SELECT * FROM table_1 LEFT  JOIN table_2 USING(f1, f2);
SELECT * FROM table_1 RIGHT JOIN table_2 USING(f);
SELECT * FROM table_1 FULL  JOIN table_2 NATURAL;
```

**==AS==**. Таблицам и ссылкам на сложные таблицы в запросе можно дать временное имя, по которому к ним можно будет обращаться в рамках запроса. Такое имя называется псевдонимом таблицы. Псевдоним становится новым именем таблицы в рамках текущего запроса, то есть после назначения исходное имя использовать нельзя.

```sql
SELECT * FROM table_link AS new_temp_table_name;
```

В основном псевдонимы используются для удобства, они бывают необходимы, когда таблица соединяется сама с собой или при обращении к подзапросу.

```sql
SELECT * FROM people AS m JOIN people AS c ON m.id = c.mother_id;
SELECT * FROM (table_name AS a CROSS JOIN table_name) AS b;
```

**==SUBQUERY==**. Подзапросом является иной запрос к базе данных, выполненный в рамках текущего запроса, подзапрос должен заключаться в круглые скобки, ему может назначаться псевдоним таблицы или при необходимости псевдоним столбцов.

```sql
FROM [LATERAL] (SELECT * FROM table_name) AS subquery_name;
```

Согласно стандарту SQL подзапросу должен обязательно назначаться псевдоним таблицы. PostgreSQL позволяет опускать `AS` и псевдоним, тем не менее хорошей практикой считается указывать псевдоним в коде SQL.

Перед подзапросами в предложении `FROM` можно добавить ключевое слово `LATERAL`. Это позволит ссылаться в них на столбцы предшествующих элементов списка `FROM`. 