DDL (Data Definition Language) представляет язык определения данных, с помощью которого создается база данных и дается описание ее структуры. DDL запрос позволяет настроить правила размещения различной информации в таблице базы данных.

Для создания таблицы используется команда `CREATE TABLE`. В этой команде вы должны указать как минимум имя новой таблицы и имена и типы данных каждого столбца. Если таблица вам больше не нужна, вы можете удалить её, выполнив команду `DROP TABLE`.

```sql
CREATE TABLE products (
    product_no integer DEFAULT 10,
    name text NOT NULL,
    price numeric
);

DROP TABLE IF EXISTS products;
```

Столбцу можно назначить значение по умолчанию через ключевое слово `DEFAULT`. 
Если значение по умолчанию не объявлено явно, им считается значение NULL. Обычно это имеет смысл, так как можно считать, что NULL представляет неизвестные данные.

Значение по умолчанию может быть выражением, которое в этом случае вычисляется в момент присваивания значения по умолчанию. Например, столбцу `timestamp` в качестве значения по умолчания часто присваивается `CURRENT_TIMESTAMP`.

---

Для некоторых столбцов в таблице нам могу потребоваться ограничения. Типы данных сами по себе ограничивают множество данных, которые можно сохранить в таблице. Однако для многих приложений такие ограничения слишком грубые.

При попытке сохранить в столбце значение, нарушающее ограничения, возникнет ошибка. Ограничения будут действовать, даже если это значение по умолчанию.

==**CHECK**==. Наиболее общий тип ограничений. В его определении вы можете указать, что значение данного столбца должно удовлетворять логическому выражению.

```sql
price numeric CHECK (price > 0),
discounted_price numeric CHECK (discounted_price > 0),
CHECK (price > discounted_price)
```

Первые два ограничения определяются похожим образом, но для третьего используется особый синтаксис. Оно не связано с определённым столбцом, а представлено отдельным элементом в списке. Определения столбцов и такие определения ограничений можно переставлять в произвольном порядке.

==**NOT NULL**.== Ограничение которое просто указывает, что столбцу нельзя присваивать значение NULL. Всегда записывается как ограничение столбца и функционально эквивалентно ограничению ``CHECK (field IS NOT NULL)``, но в PostgreSQL явное ограничение NOT NULL работает более эффективно.

==**UNIQUE**==. Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов уникальны среди всех строк таблицы. Чтобы определить ограничение уникальности для группы столбцов, запишите его в виде ограничения таблицы, перечислив имена столбцов через запятую.

```sql
a integer UNIQUE,
b integer,
c integer,
UNIQUE (b, c)
```

Такое ограничение указывает, что сочетание значений перечисленных столбцов должно быть уникально во всей таблице, тогда как значения каждого столбца по отдельности не должны быть (и обычно не будут) уникальными.

==**PRIMARY KEY**==. Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может быть уникальным идентификатором строк в таблице. Для этого требуется, чтобы значения были уникальными и отличными от NULL.

Первичные ключи могут включать несколько столбцов; синтаксис похож на запись ограничений уникальности:

```sql
a integer PRIMARY KEY,
b integer,
c integer,
PRIMARY KEY (b, c)
```

Таблица может иметь максимум один первичный ключ, в отличии от комбинации ограничений UNIQUE NOT NULL. Теория реляционных баз данных говорит, что первичный ключ должен быть в каждой таблице. В PostgreSQL такого жёсткого требования нет, но обычно лучше ему следовать.

**==FOREIGN KEY==**. Ограничение внешнего ключа указывает, что значения столбца или группы столбцов должны соответствовать значениям в некоторой строке другой таблицы. Это называется ссылочной целостностью двух связанных таблиц.

```sql
CREATE TABLE products (
    product_id integer PRIMARY KEY,
    ...
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    ...
);

CREATE TABLE order_items (
    product_id integer REFERENCES products(product_id),
    order_id integer REFERENCES orders(order_id),
    PRIMARY KEY (product_no, order_id)
);
```

Таблица может содержать несколько ограничений внешнего ключа. Это полезно для связи таблиц в отношении многие-ко-многим. Для объявления внешнего ключа на уровне столбца используется ключевое слово `REFERENCES`, а для объявления на уровне таблицы используется ключевое слово `PRIMARY KEY`.

```sql
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
```

При связи группы таблиц внешними ключами нужно определить порядок действий при удалении одной из связанных строк. Для этого используется команда `ON DELETE`. В качестве параметра принимает: NO ACTION, RESTICT, CASCADE, SET NULL, SET DEFAULT.

Значение `RESTRICT` предотвращает удаление связанной строки, а `NO ACTION` означает, что если зависимые строки продолжают существовать при проверке ограничения, возникает ошибка (это поведение по умолчанию). Главным отличием является то, что `NO ACTION` позволяет отложить проверку в процессе транзакции, а `RESTRICT` - нет.

```sql
product_no integer REFERENCES products ON DELETE RESTRICT,
order_id integer REFERENCES orders ON DELETE CASCADE,
```

Аналогично указанию `ON DELETE` существует `ON UPDATE`, которое срабатывает при изменении заданного столбца. При этом возможные действия те же, кроме того, что для `SET NULL` и `SET DEFAULT` нельзя задать списки столбцов. `CASCADE` в данном случае означает, что изменённые значения будут скопированы в зависимые строки.

Так как команды `DELETE` для строк главной таблицы потребует просканировать подчинённую таблицу и найти строки, ссылающиеся на старые значения, полезно будет иметь индекс и для подчинённых столбцов. Но это нужно не всегда, и создать соответствующий индекс можно по-разному, поэтому объявление внешнего ключа не создаёт автоматически индекс по связанным столбцам.

---

Если вы создали таблицы, а затем изменились требования вашего приложения, вы можете удалить её и создать заново. Но это будет неудобно, если таблица уже заполнена данными, или если на неё ссылаются другие объекты базы данных. Поэтому PostgreSQL предоставляет набор команд для модификации таблиц. 

Все эти действия по обновлению структуры таблицы выполняются с помощью использования команды `ALTER TABLE`.

**==ADD==**. Добавление столбца происходит с использованием ключевого слова `ADD`. Новый столбец заполняется заданным для него значением по умолчанию или значением NULL, если вы не добавите указание `DEFAULT`. Также добавляются ограничения.

```sql
ALTER TABLE table_name ADD COLUMN column_name column_type;
ALTER TABLE table_name ADD CHECK (name <> '');
```

>[!tip] Изменения PostgreSQL 11
>Добавление столбца с значением по умолчанию более не означает, что при выполнении команды ALTER TABLE будут изменены все строки таблицы. Вместо этого установленное значение по умолчанию будет просто выдаваться при следующем обращении к строкам, а сохранится в строках при перезаписи таблицы.

**==DROP==**. Удаление столбца происходит с использованием ключевого слова `DROP`. Данные, которые были в этом столбце, исчезают, как и ограничения столбца. Таким же образом из таблицы удаляются установленные на столбец ограничения.

```sql
ALTER TABLE table_name DROP COLUMN column_name;
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```

Также предоставляется функционал по изменению типа столбца, переименованию таблицы, переименованию столбца и смены значения по умолчанию.

```sql
ALTER TABLE table_name RENAME TO new_table_name;
ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name;
ALTER TABLE table_name ALTER COLUMN column_name TYPE new_type;
ALTER TABLE table_name ALTER COLUMN column_name SET DEFAULT value;
```

---

Кластер баз данных PostgreSQL содержит один или несколько именованных экземпляров баз. На уровне кластера создаются роли и некоторые другие объекты. При этом в рамках одного подключения к серверу можно обращаться к данным только одной базы - той, что была выбрана при установлении соединения.

База данных содержит одну или несколько именованных схем, которые в свою очередь содержат таблицы. Схемы также содержат именованные объекты других видов, включая типы данных и функции. Для обращения используется `schema_name.entity`.

Одно и то же имя объекта можно свободно использовать в разных схемах. Cхемы не ограничивают доступ к данным: пользователи могут обращаться к объектам в любой схеме текущей базы данных, если им назначены соответствующие права.

Схемы обычно применяют для того чтобы одну базу данных могли использовать несколько пользователей, независимо друг от друга, чтобы объединить объекты базы данных в логические группы для облегчения управления ими, чтобы в одной базе сосуществовали разные приложения, и при этом не возникало конфликтов имён.

По умолчанию такие таблицы и другие объекты автоматически помещаются в схему `public`. Она содержится во всех создаваемых базах данных.

```sql
CREATE SCHEMA shema_name;                 // Создание схемы
DROP SCHEMA shema_name;                   // Удаление пустой схемы
CREATE TABLE shema_name.table_name (...); // Создание таблицы в схеме
```

По умолчанию пользователь не может обращаться к объектам в чужих схемах. Чтобы изменить это, владелец схемы должен дать пользователю право `USAGE` для данной схемы. По умолчанию все пользователи имеют это право для схемы `public`.

---

PostgreSQL реализует наследование таблиц, что может быть полезно для проектировщиков баз данных. Стандарт 1999 года и более поздние версии определяют возможность наследования типов, но этот отличается от наследования таблиц.

Наследование в PostgreSQL производится с использованием ключевого слова `INHERITS` в конце определения дочерней таблицы, с указанием родительской таблицы.

```sql
CREATE TABLE cities (
    name            text,
    population      float,
);

CREATE TABLE capitals (
    state           char(2),
) INHERITS (cities);
```

При этом будут созданы две таблицы, дочерняя из которых унаследует поля от родительской. Вставка данных в таблицы работает без изменений, в отличии от чтения данных. При чтении данные ищутся в текущей таблице и во всех ее потомках. Чтобы получить выборку только из текущей таблицы, используется конструкция `FROM ONLY`.

Любые виды ограничений, существующие для родительской таблицы, не наследуются потомком. Для него нужно создавать свои ключи и ограничения. Поэтому например поле id будет уникальным только в пределах родительской таблицы.

Если мы хотим, чтобы при добавлении в родительскую таблицу при определенных критериях данные попадали вместо этого в дочернюю таблицу, то это можно сделать либо с помощью триггеров (**Trigger**), либо с помощью правил (**Rule**).

Таблица может наследоваться от нескольких родительских таблиц, в этом случае она будет объединять в себе все столбцы этих таблиц, а также столбцы, описанные непосредственно в её определении. Если в определениях родительских и дочерней таблиц встретятся столбцы с одним именем, эти столбцы будут объединены.

Родителем может выступать пустая таблица. С помощью таких таблиц можно создавать так называемые партиции (**Partition**), чтобы разнести большие массивы данных по какому-то параметру по разным таблицам для быстрого доступа.

Также можно создавать полные копии таблиц без наследования с помощью команды `LIKE` оператора `CREATE TABLE`. Такая команда создаст новую таблицу с теми же столбцами, что имеются в исходной.  Добавив к предложению `LIKE` параметр `INCLUDING CONSTRAINTS`, также скопируются все ограничения исходной таблицы.

Родительскую таблицу нельзя удалить, пока существуют унаследованные от неё. В запросах к наследникам проверка прав выполняется только в родительской таблице.

[[DataBase/🟡Base|🟡Base]]