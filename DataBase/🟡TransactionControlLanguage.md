**TCL (Transaction Control Language)**. Это язык управления транзакциями. TCL запрос используется, когда необходимо объединить несколько команд DML, направленных на изменение данных, в наборы атомарных операций.

---

**Транзакция** - это фундаментальное понятие во всех СУБД. Суть транзакции в том, что она объединяет последовательность действий в одну атомарную единицу. Если она не завершится, ни один из результатов этих действий не сохранится в базе данных.

Транзакция определяется набором команд, окружённым командами `BEGIN` и `COMMIT`. Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её, мы можем выполнить команду `ROLLBACK`, и все наши изменения будут отменены.

Операторами в транзакции можно также управлять н)а более детальном уровне, используя точки сохранения. Точки сохранения позволяют выборочно отменять некоторые части транзакции и фиксировать все остальные. 

Определив точку сохранения с помощью `SAVEPOINT`, при необходимости вы можете вернуться к ней с помощью команды `ROLLBACK TO`. Все изменения в базе данных, произошедшие после точки сохранения и до момента отката, отменяются.

```sql
SAVEPOINT savepoint_name;
ROLLBACK TO savepoint_name;
```

Более того, `ROLLBACK TO` - это единственный способ вернуть контроль над блоком транзакций, оказавшимся в прерванном состоянии из-за ошибки системы, не считая возможности полностью отменить её и начать снова.

---

Спецификация определяет набор свойств транзакций базы данных, предназначенных гарантировать достоверность данных. Набор этих свойств именуется `ACID`.

**==Atomicity==**. Атомарность гарантирует, что транзакция рассматривается как единая, неделимая единица работы. Это означает, что либо все операции в транзакции завершаются успешно, либо ни одна из них не применяется к базе данных. 

**==Consistency==**. Согласованность гарантирует, что по мере выполнения транзакций, данные переходят из одного согласованного состояния в другое. Система проверяет ограничения целостности транзакции и откатывает транзакцию при нарушении.

**==Isolation==**. Изоляция гарантирует, что изменения, внесенные транзакцией, не видны другим транзакциям до тех пор, пока транзакция не будет зафиксирована. Такая изоляция помогает предотвратить конфликты между параллельными транзакциями. 

**==Durability==**. Долговечность гарантирует, что изменения, зафиксированные транзакцией, являются постоянными и сохраняются после любых последующих сбоев. Система использует технику, называемую протоколированием, чтобы гарантировать, что изменения, внесенные транзакцией, могут быть отменены в случае сбоя.

---

PostgreSQL предоставляет разработчикам богатый набор средств для управления конкурентным доступом к данным. Внутри он поддерживает целостность данных, реализуя модель `MVCC Multiversion Concurrency Control`. 

Это означает, что каждый SQL-оператор видит снимок данных на определённый момент времени, вне зависимости от текущего состояния данных. Это защищает операторы от несогласованности данных, возможной, если конкурирующие транзакции внесут изменения в те же строки данных. 

PostgreSQL гарантирует это даже для самого строгого уровня изоляции транзакций, используя инновационный уровень изоляции SSI (Serializable Snapshot Isolation).

Для приложений, которым в принципе не нужна полная изоляция транзакций и которые предпочитают явно определять точки конфликтов, также есть средства блокировки на уровне таблиц и строк.

Однако при правильном использовании MVCC обычно обеспечивает лучшую производительность, чем блокировки. Кроме этого, приложения могут использовать рекомендательные блокировки, не привязанные к какой-либо одной транзакции.

---

Стандарт описывает следующие особые условия, недопустимые для различных уровней изоляции при выполнении конкурентных запросов к базе данных:

**==Грязное чтение==**. Эффект когда одна транзакция читает добавленные или изменённые данные другой транзакции, которая впоследствии не подтвердится (откатится) .

**==Неповторяемое чтение==**. После чтения данных одной транзакцией, вторая транзакция изменяет и согласовывает данные первой транзакции, в результате получается что первая транзакция работает с не валидными данными.

**==Фантомное чтение==**. Транзакция повторно выполняет запрос, возвращающий набор строк для некоторого условия, и обнаруживает, что набор строк, удовлетворяющих условию, изменился из-за транзакции, завершившейся за это время.

**==Аномалия сериализации==**. Результат успешной фиксации группы транзакций оказывается несогласованным при всевозможных вариантах исполнения этих транзакций по очереди. То есть при одновременном изменении блока данных разными транзакциями теряются все изменения, кроме последнего.

![[Pasted image 20240119231039.png]]

---

В PostgreSQL вы можете запросить любой из четырёх уровней изоляции транзакций, однако внутри реализованы только три различных уровня, то есть режим Read Uncommitted в PostgreSQL действует как Read Committed.

Причина этого в том, что только так можно сопоставить стандартные уровни изоляции с реализованной архитектурой многоверсионного управления конкурентным доступом.

>[!info] Важно
>Поведение некоторых функций и типов данных в транзакциях особое. В частности, изменения автоинкеминтирующих столбцов немедленно видны во всех остальных транзакциях и не откатываются назад, если транзакция прерывается.

**==Read Committed==**.  Уровень изоляции транзакции, выбираемый по умолчанию. В транзакции, работающей на этом уровне, запрос видит только те данные, которые были зафиксированы до начала запроса. Он никогда не увидит незафиксированных данных или изменений, внесённых параллельными транзакциями в процессе запроса.

Однако запрос видит результаты изменений, внесённых ранее в этой же транзакции, даже если они ещё не зафиксированы. Также заметьте, что два последовательных оператора `SELECT` могут видеть разные данные даже в рамках одной транзакции, если какие-то другие транзакции зафиксируют изменения после запуска первого запроса.

**==Repeatable Read==**. В данном уровне видны только те данные, которые были зафиксированы до начала транзакции, но не видны незафиксированные данные и изменения, произведённые другими транзакциями в процессе выполнения текущей.

Однако каждый запрос будет видеть эффекты предыдущих изменений в своей транзакции, несмотря на то, что они не зафиксированы. Это самое строгое требование, которое стандарт SQL вводит для этого уровня изоляции, он предотвращаются все явления, за исключением аномалий сериализации.

Как было сказано выше, это не противоречит стандарту, так как он определяет только минимальную защиту, которая должна обеспечиваться на каждом уровне изоляции.

Этот уровень отличается от Read Committed тем, что запрос в транзакции данного уровня видит снимок данных на момент начала первого оператора в транзакции, а не начала текущего оператора. Таким образом, последовательные команды запроса в одной транзакции видят одни и те же данные. Они не видят изменений, внесённых и зафиксированных другими транзакциями после начала их текущей транзакции.

При взаимном изменении данных с фиксацией может произойти откат текущей выполняемой транзакции. Приложения, использующие этот уровень, должны быть готовы повторить транзакции в случае сбоев сериализации.

Заметьте, что потребность в повторении транзакции может возникнуть, только если эта транзакция изменяет данные. В других случаях, конфликтов сериализации не бывает.

**==Serializable==**. Обеспечивает самую строгую изоляцию транзакций. На этом уровне моделируется последовательное выполнение всех зафиксированных транзакций, как если бы транзакции выполнялись одна за другой, последовательно, а не параллельно. 

Однако, как и на уровне Repeatable Read, на этом уровне приложения должны быть готовы повторять транзакции из-за сбоев сериализации. 

Фактически этот режим изоляции работает так же, как и Repeatable Read, только он дополнительно отслеживает условия, при которых результат выполняемых сериализуемых транзакций может не согласовываться с результатом по очереди.

Это отслеживание не привносит дополнительных препятствий для выполнения, кроме тех, что присущи режиму Repeatable Read, но создаёт некоторую добавочную нагрузку, а при выявлении исключительных условий регистрируется аномалия сериализации и выбрасывается ошибка базы данных о сбое сериализации.

---

На уровнях изоляции `Repeatable Read` и `Serializable` могут выдаваться ошибки с целью предотвращения аномалий сериализации. Приложения, использующие эти уровни, должны быть готовы повторить транзакции, завершившиеся сбоем из-за ошибок сериализации. Текст такого сообщения об ошибке может варьироваться в зависимости от конкретных обстоятельств, но код SQLSTATE всегда будет `40001`.

Также может иметь смысл повторять запросы в случае ошибок взаимоблокировки. Такие ошибки имеют код `40P01`. В некоторых случаях также целесообразно повторять запросы после ошибок уникальности ключа, которые имеют код `23505`. 

Например, если приложение выбирает новое значение для столбца первичного ключа, выяснив, какие значения уже есть, оно может столкнуться с ошибкой уникальности ключа, потому что другой экземпляр одновременно выбрал то же значение.

По сути, это ошибка сериализации, но сервер не обнаруживает её как таковую, потому что он не может видеть связь между добавляемым значением и предыдущим чтением. 

Есть также некоторые особые случаи, когда сервер выдаёт ошибку уникального ключа или нарушения исключения, даже если у него в принципе достаточно информации, чтобы определить, что основной причиной является проблема сериализации.

Тогда как запросы, вызвавшие ошибки `serialization_failure`, рекомендуется просто повторять, это не распространяется на запросы, завершающиеся ошибками с другими кодами, поскольку такие ошибки могут свидетельствовать о постоянных проблемах.

Повторять транзакцию важно целиком, включая всю логику, которая решает, какой SQL выдавать или какие значения использовать. PostgreSQL не предлагает средства автоматического повторения запросов, так как не гарантирует их правильность.