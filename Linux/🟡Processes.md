Процессы в linux можно описать как контейнеры, в которых хранится вся информация о состоянии и выполнении программы. Если программа работает хорошо, то все нормально, но если она зависла или вам нужно настроить ее работу может понадобиться управление процессами в Linux.

Системное программное обеспечение взаимодействует с ядром системы посредством специальных функций — системных вызовов. В редких случаях существует альтернативный API, например, procfs или sysfs, выполненные в виде виртуальных файловых систем.

**PID (Process ID)** - уникальный идентификатор процесса, каждый процесс получает его не случайным образом, а инкрементированием значения PID предыдущего запущенного в системе процесса.

**/proc** - директория содержащая все запущенные процессы

---
### Жизненный цикл процесса

#### 1) Рождение процесса

Только один процесс в системе рождается особенным способом - init. 
Он порождается непосредственно ядром. Все остальные процессы появляются путём дублирования текущего процесса с помощью системного вызова fork(2).

После выполнения fork(2) все ресурсы дочернего процесса - это копия ресурсов родителя. Копировать процесс - дорого, поэтому в ядре Linux используется технология Copy-On-Write.

>[!info] Copy-On-Write
>Все страницы памяти родителя помечаются как read-only и становятся доступны и родителю, и ребёнку.
>
>Как только один из процессов изменяет данные на определённой странице, эта страница не изменяется, а копируется и изменяется уже копия. Оригинал при этом «отвязывается» от данного процесса.
>
>Как только read-only оригинал остаётся «привязанным» к одному процессу, странице вновь назначается статус read-write.

#### 2) Состояние Ready

Сразу после выполнения fork(2) переходит в состояние «Ready».  
Фактически, процесс стоит в очереди и ждёт, когда планировщик (scheduler) в ядре даст процессу выполняться на процессоре.

#### 3) Состояние Performed

Как только планировщик поставил процесс на выполнение, началось состояние «Performed». Процесс может выполняться весь предложенный промежуток (квант) времени, а может уступить место другим процессам, воспользовавшись системным вывозом `sched_yield`.

#### 4) Перерождение в другую программу

В некоторых программах реализована логика, в которой родительский процесс создает дочерний для решения какой-либо задачи. Ребёнок в данном случае решает какую-то конкретную проблему, а родитель лишь делегирует своим детям задачи.  Однако, если нужно запустить другую программу, то необходимо прибегнуть к системному вызову `execve(2)`

В случае успеха управление передаётся загруженной программе и в исходную уже не возвращается. При этом у загруженной программы остаются все поля структуры процесса, кроме файловых дескрипторов, помеченных как `O_CLOEXEC`, они закроются.

#### 5) Состояние «Wait»

Некоторые системные вызовы могут выполняться долго, например, ввод-вывод. В таких случаях процесс переходит в состояние «Wait». Как только системный вызов будет выполнен, ядро переведёт процесс в состояние «Ready».

В Linux так же существует состояние «Wait without interapt», в котором процесс не реагирует на сигналы прерывания. В этом состоянии процесс становится не убиваемым, а все пришедшие сигналы встают в очередь до тех пор, пока процесс не выйдет из этого состояния.  

Ядро само выбирает, в какое из состояний перевести процесс. Чаще всего в состояние «Wait without interapt» попадают процессы, которые запрашивают ввод-вывод. Особенно заметно это при использовании удалённого диска (NFS) с не очень быстрым интернетом.

#### 6) Состояние «Stoped»

В любой момент можно приостановить выполнение процесса, отправив ему сигнал SIGSTOP. Процесс перейдёт в состояние «остановлен» и будет находиться там до тех пор, пока ему не придёт сигнал продолжать работу (SIGCONT) или умереть (SIGKILL). Остальные сигналы будут поставлены в очередь.

#### 7) Завершение процесса

Ни одна программа не умеет завершаться сама. Они могут лишь попросить систему об этом с помощью системного вызова `_exit` или быть завершенными системой из-за ошибки. 

Даже когда возвращаешь число из `main()`, всё равно неявно вызывается `_exit`.  
Хотя аргумент системного вызова принимает значение типа int, в качестве кода возврата берется лишь младший байт числа.

#### 8) Состояние «Zombie»

Сразу после того, как процесс завершился (неважно, корректно или нет), ядро записывает информацию о том, как завершился процесс и переводит его в состояние «Zombie». Иными словами, зомби - это завершившийся процесс, но память о нём всё ещё хранится в ядре.  

Более того, это второе состояние, в котором процесс может смело игнорировать сигнал SIGKILL, ведь что мертво не может умереть ещё раз.

---

**htop** - консольная утилита для управления запущенными процессам

**PID** - идентификатор процесса
**USER** - пользователь, от которого был запущен процесс
**PRI** - приоритет процесса linux на уровне ядра (обычно NI+20)
**NI** - приоритет выполнения процесса от -20 до 19
**S** - состояние процесса
**CPU** - используемые ресурсы процессора
**MEM** - использованная память
**TIME** - время работы процесса
