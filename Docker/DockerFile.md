Утилита `Docker` может автоматически создавать образы, считывая инструкции из  файла. `Dockerfile` представляет собой текстовый документ, содержащий все команды, которые пользователь может вызвать в командной строке для сборки образа.

Инструкции `Dockerfile` не чувствительна к регистру. Однако принято использовать заглавные буквы, чтобы их было легче отличать от аргументов. `Docker` выполняет инструкции в ф по порядку. `Dockerfile` должен начинаться с `FROM` инструкции.
Она может располагаться после директив , комментариев и глобальных `ARG`.

---

Директивы парсера являются необязательными и влияют на способ обработки строк
в файле. Директивы парсера не добавляют слои к сборке и не отображаются как шаги сборки. Директивы парсера записываются как комментарии (`# directive=value`) в специальном формате. Одна директива может быть использована только один раз.

После обработки комментария, пустой строки или инструкции сборщик больше не ищет директивы парсера. Вместо этого он обрабатывает строки начинающееся с `#`,
как комментарии и не пытается проверить, может ли это быть директивой парсера. Поэтому все директивы парсера должны находиться в верхней части `Dockerfile`.

**==Syntax==**. Используется для объявления версии синтаксиса `Dockerfile`, используемой для сборки. Можно присвоить ей значение `docker/dockerfile:1`, что заставит сборщик получать последнюю стабильную версию синтаксиса перед сборкой.

```dockerfile
# syntax=docker/dockerfile:1
```

**==Escape==**. Директива `escape`устанавливает символ, используемый для экранирования символов. Если она не указана, то по умолчанию используется символ `\`.

```dockerfile
# escape=\
```

**==Check==**. Используется для настройки оценки проверок сборки . По умолчанию выполняются все проверки, а неудачи рассматриваются как предупреждения.

Вы можете отключить определенные проверки с помощью `#check=skip=<check-name>`. Чтобы указать несколько проверок, которые нужно пропустить, разделите их запятой.

```dockerfile
# check=skip=all            // Отключение всех проверок
# check=skip=<check-name>   // Отключение проверки check-name
```

---

**==ARG==**. Инструкция `ARG`определяет переменную, которую пользователи могут передавать во время сборки сборщику с помощью `docker build`команды, использующей `--build-arg <varname>=<value>` флаг. 

Данная переменная будет доступна только в момент сборки образа, поэтому
может использоваться в `RUN`, но не может в командах `ENTRYPOINT` и `CMD`.  

>[!warning] Секреты в ARG
>Нельзя использовать аргументы сборки для передачи секретных данных, так как аргументы сборки видны в `docker history`, которая прикрепляются к образу.

Вы можете использовать инструкцию `ARG` или `ENV`для указания переменных, которые доступны инструкции `RUN`. Переменные среды, определенные с помощью `ENV`инструкции, всегда переопределяют `ARG` инструкцию с тем же именем.

```dockerfile
ARG <name>[=<default value>]
```

```sh
docker build --build-arg <var>=<value> .
```

**==ENV==**. Устанавливает переменную окружения. Это значение будет в окружении для всех последующих инструкций на этапе сборки. Кавычки и обратные косые черты в значении можно использовать для включения пробелов в значения.

В отличии от ARG переменных, могут использоваться после сборки образа
уже в работающем контейнере, то есть в командах `ENTRYPOINT` и `CMD`.

```Dockerfile
ENV <key>=<value>
```

**==FROM==**. Инструкция инициализирует новый этап сборки и задает базовый образ для последующих инструкций. Таким образом, `Dockerfile` должен начинаться с `FROM`инструкции. В качестве базового образа можно использовать любой образ.

Инструкция `FROM` может появляться несколько раз в одном `Dockerfile` для создания нескольких образов или использования одного этапа сборки в качестве зависимости для другого. Каждая `FROM`инструкция очищает состояние предыдущих сборок .

Можно дать имя этапу сборки, добавив его `AS name` к `FROM` инструкции. Имя можно использовать в последующих инструкциях `FROM <name>` для ссылки на образ.



