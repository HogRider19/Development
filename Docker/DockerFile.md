Утилита `Docker` может автоматически создавать образы, считывая инструкции из  файла. `Dockerfile` представляет собой текстовый документ, содержащий все команды, которые пользователь может вызвать в командной строке для сборки образа.

Инструкции `Dockerfile` не чувствительна к регистру. Однако принято использовать заглавные буквы, чтобы их было легче отличать от аргументов. `Docker` выполняет инструкции в ф по порядку. `Dockerfile` должен начинаться с `FROM` инструкции.
Она может располагаться после директив , комментариев и глобальных `ARG`.

---

Директивы парсера являются необязательными и влияют на способ обработки строк
в файле. Директивы парсера не добавляют слои к сборке и не отображаются как шаги сборки. Директивы парсера записываются как комментарии (`# directive=value`) в специальном формате. Одна директива может быть использована только один раз.

После обработки комментария, пустой строки или инструкции сборщик больше не ищет директивы парсера. Вместо этого он обрабатывает строки начинающееся с `#`,
как комментарии и не пытается проверить, может ли это быть директивой парсера. Поэтому все директивы парсера должны находиться в верхней части `Dockerfile`.

**==Syntax==**. Используется для объявления версии синтаксиса `Dockerfile`, используемой для сборки. Можно присвоить ей значение `docker/dockerfile:1`, что заставит сборщик получать последнюю стабильную версию синтаксиса перед сборкой.

```dockerfile
# syntax=docker/dockerfile:1
```

**==Escape==**. Директива `escape`устанавливает символ, используемый для экранирования символов. Если она не указана, то по умолчанию используется символ `\`.

```dockerfile
# escape=\
```

**==Check==**. Используется для настройки оценки проверок сборки . По умолчанию выполняются все проверки, а неудачи рассматриваются как предупреждения.

Вы можете отключить определенные проверки с помощью `#check=skip=<check-name>`. Чтобы указать несколько проверок, которые нужно пропустить, разделите их запятой.

```dockerfile
# check=skip=all            // Отключение всех проверок
# check=skip=<check-name>   // Отключение проверки check-name
```

---

**==ARG==**. Инструкция `ARG`определяет переменную, которую пользователи могут передавать во время сборки сборщику с помощью `docker build`команды, использующей `--build-arg <varname>=<value>` флаг. 

Данная переменная будет доступна только в момент сборки образа, поэтому
может использоваться в `RUN`, но не может в командах `ENTRYPOINT` и `CMD`.  

>[!warning] Секреты в ARG
>Нельзя использовать аргументы сборки для передачи секретных данных, так как аргументы сборки видны в `docker history`, которая прикрепляются к образу.

Вы можете использовать инструкцию `ARG` или `ENV`для указания переменных, которые доступны инструкции `RUN`. Переменные среды, определенные с помощью `ENV`инструкции, всегда переопределяют `ARG` инструкцию с тем же именем.

```dockerfile
ARG <name>[=<default value>]
```

```sh
docker build --build-arg <var>=<value> .
```

**==ENV==**. Устанавливает переменную окружения. Это значение будет в окружении для всех последующих инструкций на этапе сборки. Кавычки и обратные косые черты в значении можно использовать для включения пробелов в значения.

В отличии от `ARG` переменных, могут использоваться после сборки образа
уже в работающем контейнере, то есть в командах `ENTRYPOINT` и `CMD`.

```Dockerfile
ENV <key>=<value>
```

**==FROM==**. Инструкция инициализирует новый этап сборки и задает базовый образ для последующих инструкций. Таким образом, `Dockerfile` должен начинаться с `FROM`инструкции. В качестве базового образа можно использовать любой образ.

Инструкция `FROM` может появляться несколько раз в одном `Dockerfile` для создания нескольких образов или использования одного этапа сборки в качестве зависимости для другого. Каждая `FROM`инструкция очищает состояние предыдущих сборок .

Можно дать имя этапу сборки, добавив его `AS name` к `FROM` инструкции. Имя можно использовать в последующих инструкциях `FROM <name>` для ссылки на образ.

```dcokerfile
FROM debian
```

**==RUN==**. Инструкция выполняет любые команды для создания нового слоя поверх образа. Этот слой используется на следующем шаге в `Dockerfile`. `RUN`имеет две формы.

```dockerfile
RUN [OPTIONS] <command> ...              // Shell
RUN [OPTIONS] [ "<command>", ... ]       // Exec
```

Инструкция `Run` выполняется один раз при сборе образа. Она подходит для создания дополнительных директорий в образе или установки зависимостей для приложения.
Данная инструкция может использоваться несколько раз в файле `Dockerfile`.

```dockerfile
RUN mkdir -p /var/www/test
RUN apt-get update && apt-get -y install libmcrypt-dev
```

**==CMD==**. Инструкция `CMD`задает команду, которая будет выполнена при запуске контейнера из образа. В `Dockerfile` может быть только одна `CMD` инструкция.
Если вы перечислите более одной `CMD`, то вступит в силу только последняя.
Образ обязан определять хотя бы одну из команд `CMD` или `ENTRYPOINT`.
Команда `CMD` может быть заменена другой при запуске контейнера.

```dockerfile
CMD ["php", "-S", "0.0.0.0:9095", "-t", "public", "public/index.php"]
CMD ["/nodejs/bin/node", "/app/server.js"]
```

**==ENTRYPOINT==**.  Конфигурирует контейнер так, что он будет запущен как исполняемый файл. Аргументы, указанные при запуске контейнера, передаются в него как аргументы. Это означает, что `ENTRYPOINT` не может быть заменена при запуске, в отличии от `CMD`.

```dockerfile
ENTRYPOINT ["php", "-S", "0.0.0.0:9095", "-t", "public", "public/index.php"]
```

Часто **`ENTRYPOINT`** используется в комбинации с `CMD`, где `ENTRYPOINT`
задает исполняемый файл, а **`CMD`** задает аргументы по умолчанию,
которые могут быть переопределены при запуске контейнера.

```dockerfile
CMD ["-S", "0.0.0.0:9095", "-t", "public", "public/index.php"]
ENTRYPOINT ["php"]
```

**==WORKDIR==**. Инструкция `WORKDIR` устанавливает рабочий каталог для любых инструкций `RUN`, `CMD`, и `ENTRYPOINT`, которые следуют за ней в `Dockerfile`. Если переданной в инструкцию директории не существует, то она будет автоматически создана.

Инструкцию `WORKDIR` можно использовать несколько раз в `Dockerfile`. Если указан относительный путь, он будет относительным к пути предыдущей `WORKDIR` инструкции.

```dockerfile
WORKDIR /code
```

**==COPY==**. Инструкция `COPY` копирует новые файлы или каталоги из `<src>`и добавляет их в файловую систему образа по пути `<dest>`. Файлы и каталоги могут быть скопированы из контекста сборки, этапа сборки, именованного контекста или образа.