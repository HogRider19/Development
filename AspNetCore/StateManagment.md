
Приложение `AspNetCore` может хранить состояние. Это могут быть как какие-то глобальные данные, так и данные, которые непосредственно относятся к запросу и пользователю. 
И в зависимости от вида данных, существуют различные способы для их хранения.

**==HttpContext.Items==**. Один из простейших способов хранения данных представляет объект типа `IDictionary<object, object>`. Эта коллекция предназначена для таких данных, связанных с текущим запросом. После завершения запроса данные из нее удаляются. 

Эта коллекция может применяться например, если у нас обработка запроса вовлекает множество `middleware`, и мы хотим, чтобы для этих компонентов были общие данные.

```c#
app.Use(async (context, next) =>
{
    context.Items["text"] = "Hello from HttpContext.Items";
    await next.Invoke();
});
 
app.Run(async (context) => 
{
	await context.Response.WriteAsync($"Text: {context.Items["text"]}")
});
```

**==Cookies==**. Куки представляют самый простой способ сохранить данные пользователя. Куки хранятся на компьютере пользователя и могут устанавливаться как на сервере, так и на клиенте.  Для оптимизации системы максимальный размер ограничен `4096` байтами.

Для работы с куками можно использовать контекст запроса `HttpContext`. Чтобы получить куки, которые приходят вместе с запросом, надо использовать коллекцию `Request.Cookies` объекта `HttpContext`. Эта коллекция представляет объект `IRequestCookieCollection`, в котором каждый элемент представлен объектом типа `KeyValuePair<string, string>`.

```c#
app.Use(async (context, next) => 
{
	if (context.Request.Cookies.ContainsKey("myCookies"))
	    string name = context.Request.Cookies["myCookies"];
	    
	if (context.Request.Cookies.TryGetValue("myCookies", out string cookies))
	{
		await context.Response.WriteAsync($"Text: {cookies");
	}
	else
	{
		await context.Response.WriteAsync($"Hello, world!");
	}
});
```







---
---
---

Приложение может хранить состояние. Это могут быть как какие-то глобальные данные, так и данные, которые непосредственно относятся к запросу и пользователю. И в зависимости от вида данных, существуют различные способы для их хранения.

---

**==HttpContext.Items==**. Объект типа `IDictionary<object, object>`. Эта коллекция предназначена для таких данных, которые непосредственно связаны с текущим запросом. После завершения запроса все данные из `HttpContext.Items` удаляются. 

Эта коллекция может применяться например, если у нас обработка запроса вовлекает множество компонентов middleware, и мы хотим, чтобы для этих компонентов были доступны общие данные, то как раз можем применить эту коллекцию.

---

**==Cookies==**. Куки представляют самый простой способ сохранить данные пользователя. Куки хранятся на компьютере пользователя и могут устанавливаться как на сервере, так и на клиенте. Из-за накладных расходов максимальный размер ограничен в 4096 байт.

**Request.Cookies** - коллекция IReqestCookieCollection для получения куки.
**Response.Cookies** - коллекция IIResponseCookies для установки куки.

Для работы с куками можно использовать контекст запроса `HttpContext`, который передается в качестве параметра в запрашиваемые компоненты middleware.

Чтобы получить куки, которые приходят вместе с запросом к приложению, нам надо использовать коллекцию `Request.Cookies` объекта `HttpContext`.

Эта коллекция представляет объект` IRequestCookieCollection`, в котором каждый элемент - это объект `KeyValuePair<string, string>`, то есть пару ключ-значение.

Для установки кук, которые отправляются в ответ клиенту, применяется объект `Response.Cookies`, который представляет интерфейс `IResponseCookies`. Этот интерфейс определяет два метода: `Append(string key, string value)`, `Delete(string key)`.

```c#
app.Run(async (context) =>
{
    if (context.Request.Cookies.ContainsKey("name"))
    {
        string? name = context.Request.Cookies["name"];
        await context.Response.WriteAsync($"Hello {name}!");
    }
    else
    {
        context.Response.Cookies.Append("name", "Tom");
        await context.Response.WriteAsync("Hello World!");
    }
});
```

---

Сессия представляет собой ряд последовательных запросов, совершенных в одном браузере в течение некоторого времени от имени одного пользователя.

Для хранения состояния сессии на сервере создается словарь или хеш-таблица, которая хранится в кэше и которая существует для всех запросов из одного браузера в течение некоторого времени. На клиенте хранится идентификатор сессии в куки.

Этот идентификатор посылается на сервер с каждым запросом. Сервер использует этот идентификатор для извлечения нужных данных из сессии. Эти куки удаляются только при завершении сессии. Но если сервер получает куки, которые установлены уже для истекшей сессии, то для этих кук будет создается новая сессия приложения.

Сервер хранит данные сессии в течение ограниченного промежутка времени после последнего запроса. По умолчанию этот промежуток равен 20 минутам.

Следует учитывать, что данные сессии специфичны для одного браузера и не разделяются между браузерами. То есть для каждого браузера своя сессия.

Все сессии работают поверх объекта `IDistributedCache`, и AspNetCore предоставляет встроенную реализацию `IDistributedCache`, которую мы можем использовать.

**Services.AddDistributedMemoryCache()** - добавление хранилища для сессии.
**Services.AddSession()** - добавление сервиса поддержки сессий.
**app.UseSession()** - добавление middleware для работы с сессиями.

Компонент `UseSession` должен находится перед любым обращением к свойству сессии в других компонентах, иначе будет получено исключение `InvalidOperationException`. 

После вызова `app.UseSession()` мы сможем управлять сессиями через свойство `HttpContext.Session`, которое представляет объект интерфейса `ISession`.

**HttpContext.Session** - объект ISession для работы с сессиями, который предоставляет следующие методы для взаимодействия с хранилищем пользователя:

**Clear()** - очищает сессию.
**Keys** - представляющее список строк со всеми ключами.
**Get(string key)** - получает по ключу key значение в byte[].
**GetInt32(string key)** - получает по ключу key значение int32.
**GetString(string key)** - получает по ключу key значение string.
**Set(string key, byte[] value)** - устанавливает по ключу key значение.
**SetInt32(string key, int value)** - устанавливает по ключу значение.
**SetString(string key, string value)** - устанавливает по ключу значение.
**Remove(string key)** - удаляет значение по ключу.

Для определения сессий для них устанавливается идентификатор. Каждая сессия имеет свой идентификатор, который сохраняется в куках. С названием `.AspNet.Session`.

Также по умолчанию куки имеют настройку `CookieHttpOnly=true`, поэтому они не доступны для клиентских скриптов из браузера. Но мы можем переопределить ряд настроек сессии с помощью свойств объекта `SessionOptions`, который передается как параметр в делегат, принимаемый одной из перегрузок метода `UseSession()`.

Зачастую сессии хранят простые строки. Если надо сохранить какой-то сложный объект, то его надо сериализовать, а при получении обратно десериализовать. Как правило, для этого определяются методы расширения для объекта `ISession`.

```c#
var builder = WebApplication.CreateBuilder();
 
builder.Services.AddDistributedMemoryCache(); // добавляем IDistributedMemoryCache
builder.Services.AddSession();                // добавляем сервисы сессии
 
var app = builder.Build();
 
app.UseSession();                             // добавляем middleware для сессий
 
app.Run(async (context) =>
{
    if (context.Session.Keys.Contains("name"))
    {
	    var name = context.Session.GetString("name")};
	    await context.Response.WriteAsync($"Hello {name}!");
    }
    else
    {
        context.Session.SetString("name", "Tom");
        await context.Response.WriteAsync("Hello World!");
    }
});
 
app.Run();
```

[[AspNetCore/🟡Base|🟡Base]]
