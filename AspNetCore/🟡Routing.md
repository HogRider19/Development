Система маршрутизации отвечает за сопоставление входящих запросов с маршрутами и на основании результатов сопоставления выбирает для обработки запроса определенную конечную точку приложения. 

Конечная точка или endpoint представляет некоторый код, который обрабатывает запрос. По сути конечная точка объединяет шаблон маршрута, которому должен соответствовать запрос, и обработчик запроса по этому маршруту.

По умолчанию предоставляется простой и удобный функционал для создания конечных точек. Ключевым типом в этом функционале является интерфейс Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.

Он определяет ряд методов для добавления конечных точек в приложение. И поскольку класс WebApplication также реализует данный интерфейс, то соответственно все методы интерфейса мы можем вызывать и у объекта WebApplication.

Для использования системы маршрутизации в конвейер обработки запроса добавляются два встроенных компонента middleware:

- **EndpointMiddleware** добавляет в конвейер обработки запроса конечные точки. Добавляется в конвейер с помощью метода `UseEndpoints()`

- **EndpointRoutingMiddleware** добавляет сопоставления запросов и маршрутов. Данный middleware выбирает конечную точку, для обработки запроса. Добавляется в конвейер с помощью метода `UseRouting()`

Причем обычно не требуется явным образом подключать эти два компонента middleware. Объект WebApplicationBuilder автоматически сконфигурирует конвейер таким образом, чтобы они добавились при использовании конечных точек.

---

**app.Map(pattern, ReqDel)** - добавляет конечные точки для обработки запросов. Является самым простым способом определения конечной точки в приложении, реализован как метод расширения для типа IEndpointRouteBuilder. 

В всех реализациях этот метод в качестве параметра `pattern` принимает шаблон маршрута, которому должен соответствовать запрос. 

Последний параметр представляет действие, которое будет обрабатывать запрос. Это может быть делегат типа RequestDelegate, либо делегат Delegate.

>[!info] Одноименный метод Map
>Стоит отметить, что не стоит путать этот метод с одноименным методом Map(), который реализован как метод расширения для типа IApplicationBuilder. И служит для не терминального компонента middleware в конвейер обработки запроса.

Также интерфейс IEndpointRouteBuilder определяет еще два метода MapGet и MapPost, которые помимо сопоставления паттерна проверяют еще и тип запроса.

---

При построении паттерна маршрута мы можем извлекать из него определенный параметры. Для этого имя элемента маршрута должно быть заключено в фигурные скобки. Затем значение элемента можно будет получить как параметр в обработчике.

При обработке запроса система маршрутизации на основании шаблон маршрута автоматически извлекает из строки запроса значения для параметров маршрута вне зависимости от содержимого этих значений. 

Однако это не всегда бывает удобно. Например, мы хотим, чтобы какой-то параметр представлял только числа, а другой параметр начинался строго с определенного символа. И для этого необходимо задать ограничения маршрута (route constraints).

Для создания ограничения параметра маршрута нужно после имени элемента через двоеточие указать тип принимаемого значения. При несоответствии типов параметров маршрута, сервер автоматически пропустит обработчик запроса при обработке.

Хотя фреймворк ASP.NET Core по умолчанию предоставляет большой набор встроенных ограничений, их может быть недостаточно. И в этом случае мы можем определить свои пользовательские ограничения маршрутов.

Для создания собственного ограничения маршрута нужно реализовать интерфейс IRouteConstraint с одним единственным методом Match. Далее ограничение можно добавить через конфигурацию сервиса RouteOptions.

---

Сопоставление адреса URL или URL matching представляет процесс сопоставления запроса с конечной точкой. Данный процесс основывается на пути запроса и полученных в запросе заголовках. Данный процесс проходит ряд этапов:

1. Сначала выбираются все конечные точки, шаблон маршрута которых совпадает с путем запроса.
    
2. Далее из полученного на предыдущем этапе набора конечных точек удаляются те, которые не соответствуют ограничениям маршрута.
    
3. Затем из полученного на предыдущем этапе набора конечных точек удаляются те, которые не удовлетворяют политике объекта MatcherPolicy (вкратце: класс MatcherPolicy позволяет определить порядок сравнения конечных точек).
    
4. И в самом конце применяется объект EndpointSelector для выбора из полученного на предыдущем этапе списка конечной точки, которая и будет обрабатывать запрос.

При обработке запроса в приоритет ставится тот обработчик, который более точно описывает маршрут запроса. Если в конечном счете осталось несколько обработчиков с равными приоритетами, которые соответствуют адресу, то генерируется исключение.

---

Кроме конечных точек запрос могут обрабатывать и другие компоненты middleware. При этом надо учитывать общий процесс обработки запроса и вызова конечных точек.

Так, если приложение содержит конечные точки, то система маршрутизации на основе процесса сопоставления адреса URL с шаблонами маршрута выбирает для обработки определенную конечную точку.

Если в приложении есть такая конечная точка, которая соответствует запросу, то компонент EndpointRoutingMiddleware устанавливает у объекта HttpContext конечную точку для будущей обработки запроса, получаемую через `HttpContext.GetEndpoint()`.

Однако конечная точка начинает обрабатывать запрос только после того, как все middleware в конвейере начнут обработку запроса. 