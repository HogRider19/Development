Важное место в приложении занимает аутентификация и авторизация. Аутентификация представляет процесс определения пользователя, а авторизация процесс определения, имеет ли пользователь право доступа к некоторому ресурсу. ASP.NET Core имеет встроенную поддержку аутентификации и авторизации.

---

Для выполнения аутентификации в конвейере обработки запроса отвечает специальный компонент middleware - `AuthenticationMiddleware`. Для встраивания этого middleware в конвейер применяется метод расширения `UseAuthentication()`.

Для выполнения аутентификации этот компонент использует сервисы аутентификации, в частности, сервис IAuthenticationService, которые регистрирует `AddAuthentication()`

В качестве параметра вторая версия метода `AddAuthentication()` принимает схему аутентификации в виде строки. Третья версия метода `AddAuthentication` принимает делегат, который устанавливает опции аутентификации - объект `AuthenticationOptions`.

Какую бы мы версию метода не использовали, для аутентификации необходима установить схему аутентификации. Две наиболее расcпространенные схемы аутентификации:` Cookies` на основе куков и `Bearer` на основе jwt токена.

Схема аутентификации позволяет выбирать определенный обработчик аутентификации. Обработчик аутентификации собственно и выполняет аутентификацию пользователей на основе данных запроса.

Например, для аутентификации с помощью куки будет выбираться встроенный обработчик `Microsoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler`, а для jwt токенов `Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler`.

При чем в ASP.NET Core мы не ограничены встроенными схемами аутентификации и можем создавать собственные схемы и под них своих обработчиков аутентификации.

Кроме применения схемы аутентификации необходимо подключить и сами сервисы аутентификации определенного типа. Они реализованы как методы расширения для типа `AuthenticationBuilder`, который возвращается методом `AddAuthentication()`:

**AddCookie()** - подключает и конфигурирует аутентификацию с помощью куки.
**AddJwtBearer()** - подключает и конфигурирует аутентификацию с помощью jwt-токенов (для этого метода необходим Nuget-пакет Microsoft.AspNetCore.Authentication.JwtBearer)

```c#
var builder = WebApplication.CreateBuilder();
builder.Services.AddAuthentication("Bearer").AddJwtBearer();

var app = builder.Build();
app.UseAuthentication();
```

---

Авторизация представляет процесс определения прав пользователя в системе, к каким ресурсам приложения он имеет право доступа и при каких условиях.

Хотя авторизация представляет отдельный независимый процесс, тем не менее для нее также необходимо, чтобы приложение также применяло аутентификацию.

Для подключения авторизации необходимо встроить `AuthorizationMiddleware`. Для этого применяется встроенный метод расширения UseAuthorization().

Кроме того, для применения авторизации необходимо зарегистрировать сервисы авторизации с помощью метода `AddAuthorization()`. Вторая версия метода принимает делегат, который с помощью `AuthorizationOptions` сконфигурирует авторизацию.

Ключевым элементом механизма авторизации является атрибут `AuthorizeAttribute`, который позволяет ограничить доступ к ресурсам приложения.

---

Одной из задач аутентификации в приложении ASP.NET Core является установка пользователя, который представлен в приложении свойством `User`класса HttpContext.
Данное свойство представляет из себя объект класса `ClaimsPrincipal`.

**HttpContext.User** - получение объекта ClaimsPrincipal текущего пользователя.

Непосредственно данные, которые идентифицируют пользователя хранятся в свойстве `Identity` класса `ClaimPrincipal`. Это свойство представляет основную идентичность текущего пользователя. Но поскольку с одним пользователем может быть связан набор идентичностей, то также в классе определено свойство `Identities`.

**ClaimsPrincipal.Identity** - получение объекта ClaimsIdentity текущего пользователя.

Свойство Identity представляет интерфейс `IIdentity`, и, как правило, в качестве такой реализации применяется класс `ClaimsIdentity`.

Объект `IIdentity`, в свою очередь, предоставляет информацию о текущем пользователе через следующие свойства:

**AuthenticationType** - тип аутентификации в строковом виде.
**IsAuthenticated** - возвращает `true`, если пользователь аутентифицирован.
**Name** - возвращает имя пользователя, как правило логин пользователя.

Для создания объекта ClaimsIdentity можно применять ряд конструкторов, но, для того, чтобы пользователь был аутентифицирован, необходимо, как минимум, предоставить тип аутентификации, которая передается через конструктор. Тип аутентификации представляет произвольную строку, которая описывает способ аутентификации.

Для установки идентичности пользователя объект ClaimsIdentity можно передать в ClaimsPrincipal либо через конструктор, либо через метод `AddIdetity()`. После чего,  ClaimsPrincipal можно зарегистрировать через `context.SignInAsync(claimsPrincipal)`.

---

### Аутентификация

**AuthenticationMiddleware** - это компонент middleware который отвечает за выполнения аутентификации в конвейере обработки запроса. Его подключает метод расширения app.UseAuthentication(). При этом должен встраиваться до всех конвейеров с аутентификацией.

**builder.AddAuthentication()** - регистрирует сервис аутентификации
**app.UseAuthentication()** - добавляет конвейер аутентификации

Перегруженная версия метода AddAuthentication принимает делегат, который устанавливает опции аутентификации, используя объект AuthenticationOptions

Схема аутентификации позволяет выбирать определенный обработчик аутентификации. Обработчик аутентификации собственно и выполняет непосредственную аутентификацию пользователей на основе данных запросов и исходя из схемы аутентификации

**authBuilder.AddCookie()** - подключает аутентификацию куки
**authBuilder.AddJwtBearer()** - подключает jwt-токены (NuGet)

## Встроенные схемы аутентификации:

1. **Cookies:** аутентификация на основе куки. Хранится в константе CookieAuthenticationDefaults.AuthenticationScheme
2. **Bearer:** аутентификация на основе jwt-токенов. Хранится в константе JwtBearerDefaults.AuthenticationScheme

---

### Авторизация

**AuthorizationMiddleware** - это компонент middleware который отвечает за выполнения авторизации в конвейере обработки запроса. Его подключает метод расширения app.UseAuthorization().

**builder.AddAuthorization()** - регистрирует сервис авторизации
**app.UseAuthorization()** - добавляет конвейер авторизации

Ключевым элементом механизма авторизации является атрибут AuthorizeAttribute, который позволяет ограничить доступ к ресурсам

---

### ClaimPrincipal, ClaimsIdentity и Claim

**ClaimsPrincipal** - это класс, который представляет личность пользователя, сделавшего запрос к веб-приложению. Он содержит набор утверждений, которые представляют собой фрагменты информации о пользователе

**ClaimsIdentity**- это класс, который представляет личность пользователя, но в более узкой форме. ClaimsPrincipal может содержать несколько ClaimsIdentity, когда, например, пользователь является членом нескольких групп и требует доступа к ресурсам каждой из них

**Сlaim** - это объект, который представляет некоторую информацию о пользователе, которую мы можем использовать для авторизации в приложении. Например, у пользователя может быть определенный возраст, город, страна проживания и прочие признаки

---

**HttpContext.User** - свойство ClaimsPrincipal пользователя 
**HttpContext.User.Identity** - данные для идентификации пользователя

Для создания объекта ClaimsIdentity можно применять ряд конструкторов, но, для того, чтобы пользователь был аутентифицирован, необходимо, как минимум, предоставить тип аутентификации, которая передается через конструктор. Тип аутентификации представляет произвольную строку, которая описывает некоторым образом способ аутентификации

Поскольку объект HttpContext доступен через механизм внедрения зависимостей в любой точке приложения, то мы можем через этот объект получить пользователя, как в примере выше. Однако, если нам нужно только свойство User, а не весь объект HttpContext, то мы можем также через механизм внедрения зависимостей получить сервис ClaimsPrincipal, который будет аналогичен свойству context.User

Если мы динамически решим добавить новый claim или удалить существующий, то после изменения claim необходимо заново пересоздавать объект ClaimsPrincipal и перезаписывать аутентификационные куки или jwt-токен, где эти данные хранятся

## Методы и свойства ClaimsPrincipal:

1. **Claims:** свойство, которое возвращает набор объектов claim
2. **FindAll(type) / FindAll(predicate):** возвращает все объекты claim, которые соответствуют определенному типу или условию
3. **FindFirst(type) / FindFirst(predicate):** возвращает первый объект claim, который соответствуют определенному типу или условию
4. **HasClaim(type, value) / HasClaim(predicate):** возвращает true, если пользователь имеет claim определенного типа с значением
5. **IsInRole(name):** возвращает значение true, если пользователь принадлежит роли с названием name

## Методы и свойства ClaimsIdentity:

1. **Claims:** свойство, которое возвращает набор объектов claim
2. **AddClaim(claim):** добавляет для пользователя объект claim
3. **AddClaims(claims):** добавляет набор объектов claim
4. **RemoveClaim(claim):** удаляет объект claim
5. **TryRemoveClaim(claim):** true если удалось удалить объект claim
6. **HasClaim(predicate):** возвращает значение true, если пользователь имеет claim, соответствующий определенному условию
7. **FindAll(type) / FindAll(predicate):** возвращает все объекты claim, которые соответствуют определенному типу или условию
8. **FindFirst(type) / FindFirst(predicate):** возвращает первый объект claim, который соответствуют определенному типу или условию

## Свойства Claim:

1. **Issuer:** издатель или название системы, которая выдала claim
2. **Subject:** возвращает информацию пользователя как ClaimsIdentity
3. **Type:** возвращает тип объекта claim
4. **Value:** возвращает значение объекта claim

## Свойства ClaimsPrincipal.Identity:

1. **AuthenticationType:** тип аутентификации в строковом виде
2. **IsAuthenticated:** true, если пользователь аутентифицирован
3. **Name:** возвращает имя пользователя для входа

---

### Role и Policy

Атрибут Authorize легко позволяет разграничить доступ по ролям, однако для создания авторизации функциональности ролей бывает недостаточно.

Собственно авторизация на основе ролей фактически представляет частный случай авторизации на основе claims, так как роль это тот же объект Claim, имеющий тип ClaimsIdentity.DefaultRoleClaimType

Все применяемые политики добавляются в приложение с помощью метода authorizationOptions.AddPolicy(). Этот метод устанавливает политики с помощью объекта AuthorizationOptions

**Policy(Политика)** - представляет набор ограничений, которым должен соответствовать пользователь для доступа к ресурсу

## Методы AuthorizationOptions для Policy:

1. **AddPolicy(name, policyBuilder):** добавляет политику
2. **GetPolicy(name):** возвращает политику по имени
3. **DefaultPolicy:** возвращает политику по умолчанию, которая используется, когда атрибут Authorize применяется без параметров

## Методы AuthorizationPolicyBuilder:

1. **RequireRole(roles):** пользователь должен иметь одну из ролей
2. **RequireUserName(name):** должен иметь логин name
3. **RequireAuthenticatedUser():** пользователь обязательно должен быть аутентифицирован для соответствия политике
4. **RequireClaim(type):** для пользователя должен быть установлен claim с типом type. Причем не важно, какое значение будет у claim
5. **RequireClaim(type, values):** для пользователя должен быть установлен claim с типом type. Но теперь claim должен в качестве значения иметь одно из значений из массива values.
6. **RequireAssertion(handler):** запрос должен соответствовать условию, которое устанавливается с помощью делегата handler
7. **AddRequirements(requirement):** позволяет добавить пользовательское ограничение, если имеющихся недостаточно

---

### Пользовательские ограничения

Класс ограничения должен реализовать интерфейс IAuthorizationRequirement из пространства имен Microsoft.AspNetCore.Authorization.

Сам класс ограничения только устанавливает некоторые лимиты, больше он ничего не делает. Чтобы его использовать при обработке запроса, нам надо добавить специальный класс - обработчик.

Класс обработчика должен наследоваться от класса AuthorizationHandler. Вся обработка производится в методе HandleRequirementAsync(). Этот метод вызывается системой авторизации при доступе к ресурсу, к которому применяется ограничение, используемое обработчиком.

В качестве параметров метод HandleRequirementAsync() получает объект применяемого ограничения и контекст авторизации AuthorizationHandlerContext, который содержит информацию о запросе. В частности, через свойство User он возвращает объект ClaimPrincipal, представляющий текущего пользователя.

А методы класса AuthorizationHandlerContext позволяют управлять авторизацией. Так, метод Succeed(requirement) вызывается, если запрос соответствует ограничению requirement. И наоборот, метод Fail(), если запрос не соответствует ограничению