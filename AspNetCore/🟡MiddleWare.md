Основная задача приложения это обработка входящих запросов. Обработка запроса в `AspNetCore` устроена по принципу конвейера цепочки обязанностей, который состоит
из компонентов. Подобные компоненты конвейера цепочки называются `middleware`.

При получении запроса сначала данные запроса получает первый компонент в конвейере. После обработки запроса компонент `middleware` он может закончить обработку запроса такой компонент еще называется терминальным компонентом. Либо он может передать данные запроса для обработки далее по конвейеру. После обработки запроса последним компонентом, данные запроса возвращаются к предыдущему компоненту обратно.

![[Pasted image 20231209160752.png]]

Компоненты middleware встраиваются с помощью методов расширений `Run`, `Map` и `Use`
интерфейса `IApplicationBuilder`. Класс `WebApplication` реализует этот интерфейс и поэтому позволяет добавлять компоненты `middleware` с помощью данных методов.

Каждый компонент `middleware` может быть определен как метод встроенный 
`inline` компонент, либо может быть вынесен в отдельно объявленный класс.
Компоненты создаются один раз и существуют в течение всего жизненного цикла приложения. То есть для обработки запросов используются одни и те же компоненты.

При получении запроса сервер формирует на его основе объект `HttpContext`, который содержит всю необходимую информацию о запросе и ответе. Эта информация посредством объекта `HttpContext` передается по цепочке всем компонентам `middleware` в приложении.

Для создания компонентов `middleware` используется делегат `RequestDelegate`, который выполняет некоторое действие и принимает контекста запроса `HttpContext`. В качестве результата данный делегат `RequestDelegate` возвращает экземпляр задачи `Task`.  То 
есть обработчик можно либо создать асинхронным либо вернуть `Task.FromResult`.

---

У интерфейса `IApplicationBuilder` есть набор методов расширений, для встраивания компонентов `middleware`, которые применяются уже к собранному приложению. 

**==Run(ReqDel)==**. Добавляет терминальный компонент, который завершает обработку запроса. Поэтому соответственно он не вызывает никакие другие компоненты и обработку запроса дальше. Следующим в конвейере `middleware` компонентам не передает управление.

>[!info] Run
> Не стоит путать метод Run(), который определен в классе WebApplication и который запускает приложение, и метод расширения Run(), который встраивает компонент middleware. Это два разных метода, которые выполняют разные задачи.

```c#
app.Run(async (context) => await context.Response.WriteAsync("Hello, world"));
```

**==Use(RedDel)==**. Добавляет компонент `middleware`, который позволяет передать обработку запроса далее следующим в конвейере компонентам через метод `next.Invoke()`. Такой компонент может выступать в роли терминального, если запишет ответ без вызова `next`.

>[!info] Next.Invoke();
> Метод Use может принимать в качестве параметра RequestDelegate и Func<\Task>. Вариант с RequestDelegate требует передачу контекста при вызове next.Invoke(context). Такой вариант считается устроившим и остался в качестве обратной совместимости.

Первый параметр делегата `Func`, который передается в метод `Use()`, представляет объект `HttpContext`. Этот объект позволяет получить данные запроса. Второй параметр делегата представляет другой делегат `Func<Task>` или `RequestDelegate`. Этот делегат представляет следующий в конвейере компонент `middleware`, которому будет передаваться запрос.

При использовании метода `Use` и передаче выполнения следующему делегату следует учитывать, что не рекомендуется вызывать метод `next.Invoke` после записи ответа. 

Компонент `middleware` должен либо генерировать ответ, либо вызывать следующий
делегат посредством `next.Invoke`, но не выполнять оба этих действия одновременно. Так как согласно документации последующие изменения объекта `Response` могут привести
к нарушению протокола передачи, например, будет послано больше байт, чем указано.

```c#
app.Use(async (context, next) =>
{
    Console.WriteLine("Начало обработки запроса");
    await next.Invoke();
    Console.WriteLine("Конец обработки запроса");
});
```

**==Map(path, appBuilder=>)==**. Применяется для создания ветки конвейера, которая
будет обрабатывать запрос по определенному пути. Этот метод реализован как метод расширения для типа `IApplicationBuilder` и имеет ряд перегруженных версий.

В качестве параметра `path` метод принимает путь запроса, с которым будет сопоставляться ветка. А второй параметр представляет делегат, получающий объект `IApplicationBuilder`
и в котором будет описано создание советующей ветки конвейера с компонентами.

Ветка конвейера, которая создается в методе `Map()`, может иметь вложенные ветки, которые обрабатывают подзапросы. При этом путь для дочерних веток конвейера будет обрабатываться относительно пути родительской ветки компонентов `middleware`. 

```c# 
app.Map("/home", appBuilder =>
{
    appBuilder.Map("/index", appBuilder => {...}); // "/home/index"
    appBuilder.Map("/about", appBuilder => {...}); // "/home/about"
    appBuilder.Run(async (c) => await c.Response.WriteAsync("Home Page"));
});

app.Run(async(context) => await context.Response.WriteAsync("Page Not Found"));
```

**==UseWhen(cond, appBuilder=>)==**. Создает `middleware`, которое на основании некоторого условия позволяет создать ответвление конвейера при обработке запроса компонентов.

В качестве параметра он принимает делегат `Func<HttpContext, bool>`, представляющий некоторое условие, которому должен соответствовать запрос. В этот делегат передается объект `HttpContext`. Если запрос соответствует условию, то он должен вернуть `true`.

Стоит отметить, что создание ветки происходит один раз при запуске приложения.
То есть код в делегате второго параметра будет выполнен лишь один раз при старте.

```c#
app.UseWhen(context => context.Request.Path == "/time",
    appBuilder =>
    {
        appBuilder.Use(async (context, next) =>
        {
            var time = DateTime.Now.ToShortTimeString();
            Console.WriteLine($"Time: {time}");
            await next();
        });
 
        appBuilder.Run(async context =>
        {
            var time = DateTime.Now.ToShortTimeString();
            await context.Response.WriteAsync($"Time: {time}");
        });
});
```

**==MapWhen(context=>bool, buider=>)==**. Аналогичен  методу расширения`UseWhen`, но в отличии от него не может передавать контекст в основную ветку конвейера выполнения.

Основным отличием этих методов расширения является то, что если метод `UseWhen` не содержит в себе терминального компонента, то в конце выполнения он передаст управление в основную ветку, в то время как `MapWhen` завершит обработку.

```c#
app.UseWhen(context => cond, appBuilder => ...);
```

---

В прошлых случаях используемые компоненты `middleware` фактически представляют из себя методы, то есть так называемые `inline middleware`. Однако также система `AspNetCore` позволяет определять компоненты `middleware` в виде отдельных специальных классов.

Класс компонента должен иметь конструктор, который принимает `RequestDelegate`. 
Через этот параметр можно получить следующий в конвейере  делегат запроса.

Также в классе должен быть определен утинотипизированный метод, который должен называться `Invoke` или `InvokeAsync`. Причем этот метод должен возвращать объект
`Task`,  принимать в качестве параметра контекст запроса и обрабатывать запрос.

```c#
app.UseMiddleware<NameMiddleware>();

public class NameMiddleware
{
    private readonly RequestDelegate next;
  
    public TokenMiddleware(RequestDelegate next)
    {
        this.next = next;
    }
  
    public async Task InvokeAsync(HttpContext context)
    {
		await next.Invoke(context);
    }
}
```


---

Стоит отметить, что `AspNetCore` уже по умолчанию предоставляет ряд встроенных компонентов `middleware`, которые применяются для часто встречающихся задач:

==**Authorization**== - предоставляет поддержку авторизации приложения.
==**Authentication**== - предоставляет поддержку аутентификации приложения.
==**Cookie Policy**== - отслеживает согласие пользователя на хранение информации.
==**CORS**== - обеспечивает поддержку кросс доменных запросов политики `CORS`.
==**DeveloperExceptionPage** ==- генерирует веб страницу с информацией об ошибке.
==**Diagnostics** ==- набор `middleware`, для диагностики при разработке приложения.
==**HealthCheck**== - проверяет работоспособность приложения на определенном url.
==**HTTPSRedirection**== - перенаправляет все запросы `HTTP` на `HTTPS` протоколов.

==**MVC**== - обеспечивает функционал фреймворка `MVC`.
==**RequestLocalization**== - обеспечивает поддержку локализации.
==**ResponseCaching**== - позволяет кэшировать результаты запросов.
==**ResponseCompression**== - обеспечивает сжатие ответа клиенту.
==**URLRewrite**== - предоставляет функциональность `URL Rewriting`.
==**EndpointRouting**== - предоставляет механизм маршрутизации.
==**Session**== - предоставляет поддержку сессий.
==**StaticFiles**== - предоставляет поддержку обработки статических файлов.
==**WebSockets**== - добавляет поддержку протокола `WebSockets`.

Для встраивания этих компонентов в конвейер обработки запроса для интерфейса `IApplicationBuilder` определены методы расширения с именем типа `UseXXX`.

[[AspNetCore/🟡Base|🟡Base]]
