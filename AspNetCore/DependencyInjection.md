Dependency injection (DI) или внедрение зависимостей представляет процесс предоставления внешней зависимости программному компоненту. Является специфичной формой инверсии управления. Делает объекты слабо связными.

Такие объекты связаны между собой через абстракции, например, через интерфейсы, что делает всю систему более гибкой, более адаптируемой и расширяемой.

Для уменьшения связности объектов системы, сами объекты заменяются на некоторые абстрактные зависимости. Тем не менее остается проблема управления подобными зависимостями, особенно если это касается больших приложений.

Нередко для установки зависимостей в подобных системах используются специальные контейнеры - IoC-контейнеры (Inversion of Control). Такие контейнеры служат своего рода фабриками, которые устанавливают зависимости между абстракциями и конкретными объектами и, как правило, управляют созданием этих объектов.

Фреймворк уже по умолчанию имеет встроенный контейнер внедрения зависимостей, который представлен интерфейсом `IServiceProvider`. А сами зависимости еще называются сервисами. Этот контейнер отвечает за сопоставление зависимостей с конкретными типами и за внедрение зависимостей в различные объекты.

**WebApplicationBuilder.Services** - получение объекта IServiceProvider.

Cервис в коллекции `IServiceCollection` представляет объект `ServiceDescriptor`, который несет некоторую информацию. В частности: `ServiceType` - тип сервиса, `ImplementationType` - тип реализации сервиса, `Lifetime` - жизненный цикл сервиса.

---

Кроме ряда подключаемых по умолчанию сервисов имеется еще ряд встроенных сервисов, которые мы можем подключать в приложение при необходимости.

Все сервисы и компоненты middleware, которые предоставляются ASP.NET по умолчанию, регистрируются в приложение с помощью методов расширений интерфейса `IServiceCollection`, имеющих общую форму `AddName()`.

После добавления сервиса его можно получить в любой части приложения. Для получения сервиса могут применяться различные способы в зависимости от ситуации.

Например можно использовать свойство `Services` объекта `WebApplication`, которое предоставляет провайдер сервисов - объект `IServiceProvider`.

Для получения сервиса у провайдера сервиса вызывается обобщенный метод `GetService()` или `GetRequiredService()`, которые типизируются типом сервиса.

**Services.GetService()** - возвращает сервис обобщенного типа или null.
**Services.GetRequiredService()** - возвращает сервис обобщенного типа или исключение.

Мы можем получить добавленные в приложения сервисы различными способами:

- Через конструктор другого класса сервиса.
- Через свойство Services объекта WebApplication.
- Через свойство RequestServices контекста запроса HttpContext.
- Через параметр метода Invoke компонента middleware.
- Через свойство Services объекта WebApplicationBuilder.

---

Система позволяет управлять жизненным циклом внедряемых в приложении сервисов. С точки зрения жизненного цикла сервисы могут представлять один из типов:

**==Transient==**. Жизненный цикл при котором, при каждом обращении к сервису создается новый объект сервиса. В течение одного запроса может быть несколько обращений к сервису, соответственно при каждом обращении будет создаваться новый объект. 

**==Scoped==**. Для каждого запроса создается свой объект сервиса. То есть если в течение одного запроса есть несколько обращений к одному сервису, то при всех этих обращениях будет использоваться один и тот же объект сервиса.

**==Singleton==**. Такой объект сервиса создается при первом обращении к нему, все последующие запросы используют один и тот же ранее созданный объект сервиса.

---

По умолчанию при внедрении зависимостей в ASP.NET Core одна зависимость сопоставляется с одним типом. Однако бывают ситуации, когда требуется отойти от этой привязки один к одному. Первая ситуация: для одной зависимости необходимо зарегистрировать сразу несколько конкретных реализаций. Вторая ситуация: для нескольких зависимостей необходимо зарегистрировать один и тот же объект.

При регистрации под одной абстракцией нескольких реализаций сервиса, коллекцию реализация можно получить через внедрение `IEnumerable<IType>`.

В обратной ситуации, когда для нескольких абстракций зарегистрирована одна реализация, получение сервиса происходит через стандартный механизм внедрения интерфейса. Но стоит учитывать, что при регистрации данных сервисов как `Singleton`, для каждой абстракции будет создан свой объект реализации. Данную проблему можно обойти передав уже созданный объект как параметр в метод `AddSingleton()`.  

[[AspNetCore/Base|Base]]

