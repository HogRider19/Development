Кэширование представляет собой сохранение данных в специальном месте для более быстрого доступа к ним в будущем. Применение кэширование может значительно повысить производительность приложения ASP.NET, существенно уменьшая количество обращений к источникам данных, например, к базам данных.

---

Определяют две стратегии кеширования, это **Pre-caching** и **On-demand caching**.

**Pre-caching**. Определяется наиболее часто запрашиваемые. Подобные данные кэшируются при старте приложения. Затем после запуска приложения берет подобные данные из кэша вместо запрашивания из внешнего источника.

Минус подобного подхода - необходимость синхронизации с внешним источником данных в случае их обновления, особенно когда приложение и база данных управляются разными командами разработчиков/разными компаниями.

**On-demand caching**. Когда данные необходимы, приложение обращается в кэш, если кэше найдены соответствующие данные, то они используются. Если данные в кэше отсутствуют, то они извлекаются из базы данных и кэшируют. Минус стратегии - необходимость делать периодические запросы к источнику данных.

---

Самым простым способом кэширования в ASP.NET Core представляет использование объекта `Microsoft.Extensions.Caching.Memory.IMemoryCache`, который позволяет сохранять данные в кэше на сервере. IMemoryCache определяет методы схожие с интерфейсом работы с обычным словарём в виде пар ключ значение.

**MemoryCache** - предоставляет встроенную реализацию интерфейса IMemoryCache, который используется как реализация по умолчанию для сервиса IMemoryCache и который инкапсулирует все объекты кэша в виде словаря Dictionary.

Для кеширования дынных таким способом требуется зарегистрировать сервис кеширования в приложении через вызов `AddMemoryCache` объекта `ServiceCollection`. Затем внедрить сервис `IMemoryCache` в требуемый класс и пользоваться функционалом.

При установке объекта в кэше, ему можно задать определенные параметры хранения, передавая при сохранении данных объект MemoryCacheEntryOptions. Данные опции позволяют настроить время кеширования и определить callback метод при их удалении.

---

Одну из форм форм кэширования представляет распределенное кэширование. Распределенный кэш - это кэш, общий для нескольких серверов приложений. 

Распределенный кэш обладает такими преимуществами, как согласованность данных между запросами нескольких приложений с разных серверов, независимость от приложения, его запуска, перезапуска и процесса развертывания, отсутствия влияния на локальную память. Соответственно применение распределенного кэша может повысить производительность и масштабируемость приложения.

В .NET распределенный кэш представлен интерфейсом IDistributedCache. Для управления кэшем этот тип предоставляет ряд методов схожих с словарём.

Объекты IDistributedCache позволяют сохранять данные только в виде массива байт или в виде строки, поэтому данные требуют сериализации перед сохранением. 

В качестве распределённого хранилища данных зачастую используют Redis. Есть пакет для удобной интеграции с Redis в качестве распределенного хранилища. 

**Microsoft.Extensions.Caching.StackExchangeRedis** - пакет для интеграции Redis в приложение в качестве распределенного хранилища данных. 

---

Компрессия или сжатие ответа представляет один из инструментов, которые позволяют уменьшить объем отправляемых клиенту данных без потери самих данных.

Для компрессии ответа в рамках ASP.NET Core мы можем использовать либо внутренние средства конкретного веб-сервера: Dynamic Compression module в IIS,  mod_deflate в Apache или инструменты компрессии в Nginx.

Однако эти инструменты не всегда бывают доступны, особенно когда приложение напрямую хостится в рамках таких веб-серверов как HTTP.sys или Kestrel. И в этом случае мы можем воспользоваться специальным компонентом middleware.

**Microsoft.AspNetCore.ResponseCompression** - стандартный компонент middleware для сжатия ответа, который отправляется клиенту серверным приложением. 

Для подключения сжатия нужно добавиться сервис сжатия ответа через вызов метода `AddResponseCompression` объекта `IServiceCollection`, передовая делегат с опциями. Также нужно добавить сам компонент вызовом `app.UseResponseCompression()`.

При регистрации сервиса сжатия ответа, также можно настроить, используемых провайдеров сжатия, по умолчанию используются провайдеры `Brotli` и `gzip`.

Следует учитывать, что для протокола HTTPS по умолчанию отключено сжатие, поэтому в вызове данного метода подключается сжатие и для HTTPS.

```c#
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddResponseCompression(options => options.EnableForHttps = true);
var app = builder.Build();
 
app.UseResponseCompression(); // Подключаем компонент сжатия ответа
app.Run();
```

Затраты на компрессию могут превосходить выгоду от уменьшения объема данных. Поэтому, для объемов меньше 1 кб не очень рационально применение компрессии.

При использования компрессии при отправке ответа нам обязательно надо установить MIME-тип отправляемых данных. В большинстве случаев заголовок типа ответа устанавливался автоматически, например при использовании конечных точек, MVC или Razor Pages. Однако не все компоненты в конвейере автоматически устанавливают заголовки. Например, метод `Run` требует установки заголовков в ручном режиме.

Механизм компрессии на уровне протокола HTTP сосредоточен вокруг двух заголовков. Вначале клиент в запросе посылает заголовок `Accept-Encoding`, в котором уведомляет сервер, какие форматы сжатия он поддерживает.

Сервер, получив запрос, использует этот заголовок для выбора формата сжатия и затем посылает вместе с ответом клиенту заголовок `Сontent-Encoding`, в котором указывает использованный формат сжатия. Если клиент поддерживает сжатие в формат `Brotli`, то по умолчанию используется этот формат, если нет, то используется сжатие `gzip`.

---

Кроме кэширования результатов действий контроллера для оптимизации работы приложения можно применять кэширование статического контента.

Для кэширования статических файлов при их отправке следует установить соответствующие заголовки. Для этого `StaticFilesMiddleware` передается объект `StaticFileOptions`, у которого устанавливается свойство `OnPrepareResponse`:

```c#
app.UseStaticFiles(new StaticFileOptions()
{
    OnPrepareResponse = ctx =>
    {
	    ctx.Context.Response.Headers.Add("Cache-Control", "public,max-age=600");
	}
});
```

Свойство `OnPrepareResponse` представляет делегат, который в качестве параметра принимает объект `StaticFileResponseContext`. Через этот объект можно установить заголовки ответа, который будут посылаться вместе со статическими файлами.

В частности, в данном случае устанавливается заголовок `Cache-Control`, который  задает параметры кэширования. Так, значение `public` указывает, что файл будет кэшироваться как в кэше браузера, так и на промежуточных прокси-серверах.

У кэширования есть недостаток: если мы изменим содержимое файла css или javascript, то при повторном обращении к приложению браузер продолжит извлекать нужные файлы из кэша (если срок кэширования не истек).

Для решения этой проблемы можно добавлять к статическим файлам версию и при каждом изменении файла соответственно менять версию файла:

```html
<link rel="stylesheet" href="/css/site.css?v=123" />
<script src="app.js?v=123"></script>
```

---

ASP.NET позволяет кэшировать ответ приложения, и для этого применяет сервис `IOutputCacheStore` и компонент middleware `OutputCacheMiddleware`. 

Для кэширования ответа приложения следует выполнить два шага. Прежде всего, добавить в коллекцию сервисов приложения все необходимые сервисы с помощью метода `AddOutputCache()`.  Во-вторых, надо добить в конвейер приложения middleware `OutputCacheMiddleware` с помощью метода `UseOutputCache()`. 

Далее для применения кеширования ответа, у конечных точек нужно просто вызвать по цепочке метод расширения `CacheOutput()`, который закэширует ответ. Либо добавить атрибут `CacheOutputAttribute` к обработчику конечной точки:

```c#

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddOutputCache();  // добавляем сервисы кэширования
 
var app = builder.Build();
app.UseOutputCache();  // добавляем OutputCacheMiddleware
 
app.MapGet("/", [CacheOutput]() => {});   // применяем кэширование
app.Run();
```

