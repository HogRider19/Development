Важную роль в приложении играет конфигурация, которая определяет базовые настройки приложения. Приложение может получать конфигурационные настройки из следующих источников: Аргументы командной строки, Переменные среды окружения, Объекты .NET в памяти, Файлы JSON, Azure, или также из пользовательских источников.

**IConfiguration** - интерфейс определяющий конфигурацию приложения.
**IConfigurationRoot** - интерфейс для агрегатора конфигураций.
**IConfigurationSection** - интерфейс секции конфигурации.

В приложении настройки конфигурации хранятся в свойстве `Configuration` объекта `WebApplication`. Соответственно через это свойство мы можем установить или получить настройки конфигурации. Он имеет следующую сигнатуру.

**GetChildren()** - возвращает набор подсекций текущей секции конфигурации.
**GetSection(string key)** - возвращает секцию конфигурации по ключу key.
**GetConnectionString(name)** - получение значения строки подключения к БД.
**GetReloadToken()** - возвращает токен для отслеживания изменения конфигурации.

Конфигурация приложения в виде объекта `IConfiguration` представляет один из сервисов. Соответственно всю конфигурацию приложения мы можем получить как и любой другой сервис через механизм внедрения зависимостей приложения.

```c#
app.Configuration["name"] = "Tom";
app.Configuration["age"] = "37";
 
app.Run(async (context) =>
{
    string name = app.Configuration["name"];
    string age = app.Configuration["age"];
    await context.Response.WriteAsync($"{name} - {age}");
});
```

---

В самом простом случае, интерфейс `IConfiguration` позволяет управлять конфигурацией приложения, как обычным словарем, где по строковому ключу записываются значения. Но если настроек много или если они имеют сложную структуру, гораздо проще установить их через внешний источник конфигураций.

Для добавления источника конфигурации можно применять свойство `Configuration` объекта `WebApplicationBuilder`. Это свойство представляет класс `ConfigurationManager`, для которого определен ряд методов расширений для добавления конфигурации.

Как правило, для хранения конфигурации в приложении используются файлы` json`. Для работы с файлами `json` применяется провайдер `JsonConfigurationProvider`, а для загрузки конфигурации из `json` применяется метод расширения `AddJsonFile(path)`.

```c#
builder.Configuration.AddJsonFile("config.json");
builder.Configuration.AddInMemoryCollection(dictionaryConfig);
```

По умолчанию в проекте уже есть файл конфигурации `appsettings.json`, а также `appsettings.Development.json`, которые загружаются по умолчанию в приложении и которые мы можем использовать для хранения конфигурационных настроек.

При определении настроек в файле `json` нам надо учитывать, что они должны иметь уникальные ключи. Но при этом мы можем использовать для конфигурации более чем одного файла. И если во втором файле есть настройки, которые имеют тот же ключ, что и настройки первого файла, то происходит переопределение настроек.

---

Если конфигурационный файл содержит иерархию настроек, то получение дочерних значений происходит через обращение к элементу `IConfiguration` по ключу, где полный ключ составлен из пути ключей до значения, разделенных двоеточием.

```c# 
app.Configuration["section1:section2:value"]
```

Но такой способ не всегда удобный, намного правильнее обращаться к секциям конфигурации через отдельный метод `GetSection(name)` интерфейса `IConfiguration`. 

Каждая отдельная секция представляет объект `IConfigurationSection`. Если секция содержит другие секции, то также можем вызвать у ней метод `GetSection()`. Если же секция содержит только значение, то оно доступно через свойство `Value`.

Этот метод никогда не возвращает `null`. Если соответствующий подраздел с указанным ключом не найден, возвращается пустой `IConfigurationSection` раздел.

```c#
app.Map("/", (IConfiguration appConfig) =>
{
    IConfigurationSection connStrings = appConfig.GetSection("ConnectionStrings");
    string defaultConnection = connStrings.GetSection("DefaultConnection").Value;
    return defaultConnection;
});
```

У интерфейса конфигурации и всех его секций есть метод `Get<T>()`, который позволяет создавать объекты с спроецированными на них данными конфигурации.

---

Фреймворк реализует паттерн `Options`, который позволяет передавать конфигурацию не просто как набор настроек в виде пар, а как объекты определенных классов.

Для применения этого паттерна в приложении у объекта `IServiceCollection`, который представляет коллекцию сервисов приложения, определен метод `Configure()`.

Этот метод реализован как метод расширения для типа `IServiceCollection`. Он типизируются типом, объект которого надо передавать через механизм внедрения зависимостей. И в качестве параметра принимает объект `IConfigration`.

И также все версии метода принимают в качестве одного из параметров объект конфигурации, на основе которой будет создаваться объект `TOptions`.

После чего через механизм внедрения зависимостей мы можем получить созданный объект через сервис `IOptions<T>`, которые типизируется тем же типом, что и `Configure`.

```c#
builder.Services.Configure<Person>(builder.Configuration);
app.Map("/", (IOptions<Person> options) => options.Value);
```

Также метод `Configure` имеет ряд перегрузок, которые позволяют переопределять ранее установленные параметры. Одна из таких перегрузок принимает делегат, который на вход получает экземпляр типизированного объекта для изменения.

```c#
builder.Services.Configure<Person>(builder.Configuration);
builder.Services.Configure<Person>(opt => opt.Age = 22);
```

---

Для взаимодействия с окружением, в котором запущено приложение, предоставлен интерфейс `IWebHostEnvironment`. Этот интерфейс предлагает ряд свойств, с помощью которых мы можем получить информацию об окружении приложения:

**ApplicationName** - хранит имя условное имя приложения.
**EnvironmentName** - название окружения, в которой запущено приложение.
**ContentRootPath** - хранит путь к корневой папке приложения.
**WebRootPath** - хранит путь к папке, в которой хранится статический контент.

При разработке мы можем использовать эти свойства. Но наиболее часто при разработке придется сталкиваться со свойством `EnvironmentName`.

По умолчанию имеются три варианта значений для этого свойства: `Development`, `Staging` и `Production`. Свойство задается через установку переменной среды `ASPNETCORE_ENVIRONMENT`. Текущее значение задается в файле `launchSettings.json`.

**app.Environment** - получение объекта IWebHostEnvironment 
**context.HostingEnvironment** - получение объекта IWebHostEnvironment

**Env.IsEnvironment(string envName)** - true, если совпадает EnvName
**Env.IsDevelopment()** - возвращает true, если имя среды - Development 
**Env.IsStaging()** - возвращает true, если имя среды - Staging 
**Env.IsProduction()** - возвращает true, если имя среды - Production

---

Приложение может получать конфигурационные настройки из следующих источников: Аргументы командной строки, Переменные среды окружения, Объекты в памяти, Файлы,
`Azure`, Cвои источники данных с созданными провайдеры конфигурации приложения.


```c#
builder.Configuration.AddJsonFile("Path.json", true, true)
	.AddEnvironmentVariables(prefix: "MyApp_")
	.AddInMemoryCollection(dict_str_str);
	.AddCommandLine(args)
	
```

Все записанные ключи конфигурации можно будет в последующем получить через экземпляр билдера с использованием синтаксиса словаря, где в качестве ключа
передаётся путь к значению с разделителями в виде символа двоеточия `:`.

Также типизированное значение можно получать через метод `GetValue<T>`.
Если ключ не будет найден, то из индексатора вернется значение `null`. 

```c#
string value1 = builder.Configuration["root:name"] ?? default_value;
int value2 = builder.Configuration.GetValue<int>("Root:name", default_value);
```

Также с конфигурацией можно работать в виде секций `IConfigurationSection`.
Получить их можно методами `GetSection(path)` и `GetRequiredSection(path)`

```c#
var section1 = builder.Configuration.GetSection("Root");
var section2 = builder.Configuration.GetRequiredSection("Root");
```


[[AspNetCore/🟡Base|🟡Base]]
