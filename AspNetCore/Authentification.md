### Аутентификация

**AuthenticationMiddleware** - это компонент middleware который отвечает за выполнения аутентификации в конвейере обработки запроса. Его подключает метод расширения app.UseAuthentication(). При этом должен встраиваться до всех конвейеров с аутентификацией.

**builder.AddAuthentication()** - регистрирует сервис аутентификации **app.UseAuthentication()** - добавляет конвейер аутентификации

Перегруженная версия метода AddAuthentication принимает делегат, который устанавливает опции аутентификации, используя объект AuthenticationOptions

Схема аутентификации позволяет выбирать определенный обработчик аутентификации. Обработчик аутентификации собственно и выполняет непосредственную аутентификацию пользователей на основе данных запросов и исходя из схемы аутентификации

**authBuilder.AddCookie()** - подключает аутентификацию куки **authBuilder.AddJwtBearer()** - подключает jwt-токены (NuGet)

## Встроенные схемы аутентификации:

1. **Cookies:** аутентификация на основе куки. Хранится в константе CookieAuthenticationDefaults.AuthenticationScheme
2. **Bearer:** аутентификация на основе jwt-токенов. Хранится в константе JwtBearerDefaults.AuthenticationScheme

---

### Авторизация

**AuthorizationMiddleware** - это компонент middleware который отвечает за выполнения авторизации в конвейере обработки запроса. Его подключает метод расширения app.UseAuthorization().

**builder.AddAuthorization()** - регистрирует сервис авторизации **app.UseAuthorization()** - добавляет конвейер авторизации

Ключевым элементом механизма авторизации является атрибут AuthorizeAttribute, который позволяет ограничить доступ к ресурсам

---

### ClaimPrincipal, ClaimsIdentity и Claim

**ClaimsPrincipal** - это класс, который представляет личность пользователя, сделавшего запрос к веб-приложению. Он содержит набор утверждений, которые представляют собой фрагменты информации о пользователе

**ClaimsIdentity**- это класс, который представляет личность пользователя, но в более узкой форме. ClaimsPrincipal может содержать несколько ClaimsIdentity, когда, например, пользователь является членом нескольких групп и требует доступа к ресурсам каждой из них

**Сlaim** - это объект, который представляет некоторую информацию о пользователе, которую мы можем использовать для авторизации в приложении. Например, у пользователя может быть определенный возраст, город, страна проживания и прочие признаки

---

**HttpContext.User** - свойство ClaimsPrincipal пользователя **HttpContext.User.Identity** - данные для идентификации пользователя

Для создания объекта ClaimsIdentity можно применять ряд конструкторов, но, для того, чтобы пользователь был аутентифицирован, необходимо, как минимум, предоставить тип аутентификации, которая передается через конструктор. Тип аутентификации представляет произвольную строку, которая описывает некоторым образом способ аутентификации

Поскольку объект HttpContext доступен через механизм внедрения зависимостей в любой точке приложения, то мы можем через этот объект получить пользователя, как в примере выше. Однако, если нам нужно только свойство User, а не весь объект HttpContext, то мы можем также через механизм внедрения зависимостей получить сервис ClaimsPrincipal, который будет аналогичен свойству context.User

Если мы динамически решим добавить новый claim или удалить существующий, то после изменения claim необходимо заново пересоздавать объект ClaimsPrincipal и перезаписывать аутентификационные куки или jwt-токен, где эти данные хранятся

## Методы и свойства ClaimsPrincipal:

1. **Claims:** свойство, которое возвращает набор объектов claim
2. **FindAll(type) / FindAll(predicate):** возвращает все объекты claim, которые соответствуют определенному типу или условию
3. **FindFirst(type) / FindFirst(predicate):** возвращает первый объект claim, который соответствуют определенному типу или условию
4. **HasClaim(type, value) / HasClaim(predicate):** возвращает true, если пользователь имеет claim определенного типа с значением
5. **IsInRole(name):** возвращает значение true, если пользователь принадлежит роли с названием name

## Методы и свойства ClaimsIdentity:

1. **Claims:** свойство, которое возвращает набор объектов claim
2. **AddClaim(claim):** добавляет для пользователя объект claim
3. **AddClaims(claims):** добавляет набор объектов claim
4. **RemoveClaim(claim):** удаляет объект claim
5. **TryRemoveClaim(claim):** true если удалось удалить объект claim
6. **HasClaim(predicate):** возвращает значение true, если пользователь имеет claim, соответствующий определенному условию
7. **FindAll(type) / FindAll(predicate):** возвращает все объекты claim, которые соответствуют определенному типу или условию
8. **FindFirst(type) / FindFirst(predicate):** возвращает первый объект claim, который соответствуют определенному типу или условию

## Свойства Claim:

1. **Issuer:** издатель или название системы, которая выдала claim
2. **Subject:** возвращает информацию пользователя как ClaimsIdentity
3. **Type:** возвращает тип объекта claim
4. **Value:** возвращает значение объекта claim

## Свойства ClaimsPrincipal.Identity:

1. **AuthenticationType:** тип аутентификации в строковом виде
2. **IsAuthenticated:** true, если пользователь аутентифицирован
3. **Name:** возвращает имя пользователя для входа

---

### Role и Policy

Атрибут Authorize легко позволяет разграничить доступ по ролям, однако для создания авторизации функциональности ролей бывает недостаточно.

Собственно авторизация на основе ролей фактически представляет частный случай авторизации на основе claims, так как роль это тот же объект Claim, имеющий тип ClaimsIdentity.DefaultRoleClaimType

Все применяемые политики добавляются в приложение с помощью метода authorizationOptions.AddPolicy(). Этот метод устанавливает политики с помощью объекта AuthorizationOptions

**Policy(Политика)** - представляет набор ограничений, которым должен соответствовать пользователь для доступа к ресурсу

## Методы AuthorizationOptions для Policy:

1. **AddPolicy(name, policyBuilder):** добавляет политику
2. **GetPolicy(name):** возвращает политику по имени
3. **DefaultPolicy:** возвращает политику по умолчанию, которая используется, когда атрибут Authorize применяется без параметров

## Методы AuthorizationPolicyBuilder:

1. **RequireRole(roles):** пользователь должен иметь одну из ролей
2. **RequireUserName(name):** должен иметь логин name
3. **RequireAuthenticatedUser():** пользователь обязательно должен быть аутентифицирован для соответствия политике
4. **RequireClaim(type):** для пользователя должен быть установлен claim с типом type. Причем не важно, какое значение будет у claim
5. **RequireClaim(type, values):** для пользователя должен быть установлен claim с типом type. Но теперь claim должен в качестве значения иметь одно из значений из массива values.
6. **RequireAssertion(handler):** запрос должен соответствовать условию, которое устанавливается с помощью делегата handler
7. **AddRequirements(requirement):** позволяет добавить пользовательское ограничение, если имеющихся недостаточно

---

### Пользовательские ограничения

Класс ограничения должен реализовать интерфейс IAuthorizationRequirement из пространства имен Microsoft.AspNetCore.Authorization.

Сам класс ограничения только устанавливает некоторые лимиты, больше он ничего не делает. Чтобы его использовать при обработке запроса, нам надо добавить специальный класс - обработчик.

Класс обработчика должен наследоваться от класса AuthorizationHandler. Вся обработка производится в методе HandleRequirementAsync(). Этот метод вызывается системой авторизации при доступе к ресурсу, к которому применяется ограничение, используемое обработчиком.

В качестве параметров метод HandleRequirementAsync() получает объект применяемого ограничения и контекст авторизации AuthorizationHandlerContext, который содержит информацию о запросе. В частности, через свойство User он возвращает объект ClaimPrincipal, представляющий текущего пользователя.

А методы класса AuthorizationHandlerContext позволяют управлять авторизацией. Так, метод Succeed(requirement) вызывается, если запрос соответствует ограничению requirement. И наоборот, метод Fail(), если запрос не соответствует ограничению