Система маршрутизации отвечает за сопоставление входящих запросов с маршрутами 
и на основании результатов сопоставления выбирает для обработки запроса конечную точку приложения. Конечная точка или `endpoint` представляет некоторый код, который обрабатывает запрос. По сути конечная точка объединяет шаблон маршрута, которому должен соответствовать запрос, и обработчик запроса по этому указанному маршруту.

Платформа `AspNetCore` по умолчанию предоставляет простой и удобный функционал
для создания конечных точек. Ключевым типом в этом функционале является интерфейс  `IEndpointRouteBuilder`. Он определяет ряд методов для добавления конечных точек в приложение. И поскольку класс `WebApplication` также реализует данный интерфейс, то соответственно все методы интерфейса мы можем вызывать и у объекта `WebApplication`.

Для использования системы маршрутизации в конвейер обработки запроса добавляются два встроенных компонента `middleware`. `EndpointMiddleware` добавляет в конвейер обработки запроса конечные точки. Добавляется в конвейер с помощью метода `UseEndpoints()`.

```c#
app.UseRouting(); // EndpointRoutingMiddleware

app.UseEndpoints(endpoints =>
{
    endpoints.MapGet("/hello", () => "Hello World!");
    endpoints.MapGet("/users/{id}", (int id) => $"User ID: {id}");
});
```

А также `EndpointRoutingMiddleware` добавляет в конвейер обработки функциональность сопоставления запросов и маршрутов. Данный `middleware` выбирает конечную точку, советующую запросу для обработки. Добавляется с помощью метода `UseRouting()`.

```c#
app.UseEndpoints(endpoints =>
{
    endpoints.MapGet("/admin", () => "Admin Panel")
        .RequireAuthorization(); // Добавляет проверку авторизации перед выполнением endpoint

    endpoints.MapPost("/upload", async (HttpRequest req) => 
    {
        var file = req.Form.Files.GetFile("file");
        await ProcessFile(file);
        return "File uploaded!";
    });
});
```

Компонент `UseRouting` только выбирает нужный `endpoint`,  а `UseEndpoints` только выполняет `endpoint` и может включать дополнительную логику например, авторизацию.
Эти компоненты логически связаны, но разделены для регистрации между ними дополнительных компонентов например, аутентификацию, `CORS`, логирование.

Причем обычно не требуется явным образом подключать эти два компонента `middleware`. Объект `WebApplicationBuilder` автоматически сконфигурирует конвейер таким образом, что эти два компонента `middleware` добавляются при использовании конечных точек.

**==Map(pattern, ReqDel)==**. Самым простым способом определения конечной точки в приложении является метод Map, который реализован как метод расширения для типа `IEndpointRouteBuilder`. Он добавляет конечные точки для обработки запросов типа `GET`.

В всех реализациях этот метод в качестве первого параметра `pattern` принимает
шаблон маршрута, которому должен соответствовать запрос для сопоставления. 
Второй параметр представляет действие, которое будет обрабатывать запрос.
Это может быть делегат типа `RequestDelegate`, либо делегат типа `Delegate`.

>[!info] Одноименный метод Map
>Стоит отметить, что не стоит путать этот метод с одноименным методом Map(), который реализован как метод расширения для типа IApplicationBuilder. И служит для не терминального компонента middleware в конвейер обработки запроса.

```c#
var pattern = RoutePatternFactory.Parse("/hello/{name}");
app.Map(pattern, (string name) => $"Hello, {name}!");
```

```c#
app.Map("/hello", async context =>
{
    await context.Response.WriteAsync("Hello from RequestDelegate!");
});
```

```c#
app.Map("/hello/{name}", (string name) => $"Hello, {name}!");
app.Map("/hello/{name}", (string name) => Results.Ok($"Hello, {name}!"));
app.Map("/user", () => new Person("Tom", 37));
```

При использовании конечной точки с обычным делегатом, мы можем в качестве возвращаемого значения вернуть примитивный тип или объект. `AspNetCore` сам
разберется как его отправить клиенту. Также мы можем явно управлять ответом,
используя [[ResultsApi]] или ничего не возвращать, тогда будет пустой `200` ответ.

Также обработчики маршрута могут принимать сервисы из провайдера сервисов через `DI`.
При этом `AspNetCore` сначала пытается получить параметр из параметров маршрута, а если не находит, то ищет его в `DI`. Но это можно задать и явно через `FromRoute` `FromServices`.

```c#
app.Map("/{value}", ([FromRoute] string value,
	[FromServices] IConfiguration conf) =>
{
    return $"Val: {value}, Hash: {conf.GetHashCode()}";
});
```

Также интерфейс `IEndpointRouteBuilder` определяет еще два метода `MapGet` и `MapPost`, которые помимо сопоставления паттерна маршрута проверяют еще и тип `HTTP` запроса.

---

Шаблон маршрута, который сопоставляется с конечной точкой, может иметь параметры. Параметры имеют имя и определяются в шаблоне маршрута внутри скобок: `{param_name}`.

Если маршрут принимает параметр, то в делегате обработчике маршрута мы можем получить значение этого параметра, через объявление параметра с тем же именем.

Следует учитывать, что если параметры маршрута определяются подряд, то между ними должен располагаться разделитель. Обычно в качестве разделителя выступает слеш, который оформляет отдельный сегмент в пути запроса. Но это необязательно. В 
качестве разделителя могут применяться и другие символы, например дефис.

```c#
app.Map("/u", () => "Users Page");
app.Map("/u/{id}", (string id) => $"User Id: {id}");
app.Map("/u/{id}/{name}",  (string id, string name) => $"{id}, {name}");
app.Map("/u/{id}and{name}",  (string id, string name) => $"{id}, {name}");
```

Параметры маршрута могут быть необязательными. Чтобы определить параметр как необязательный, после его названия указывается знак вопроса. Необязательные параметры  следует помещать в конце шаблона маршрута. К примеру `/users/{id?}/{name}` не будет работать корректно, если мы для параметра `id` при вызове не передадим значение.

```c#
app.Map("/users/{id?}", (string? id) => $"User Id: {id ?? "Undefined"}");
```

Параметрам маршрута также можно назначить значения по умолчанию на случай, если у них нет значений. Для этого в определение параметра нужно передать значение через равно.

```c#
app.Map(
    "{controller=Home}/{action=Index}/{id?}", 
    (string controller, string action, string? id) =>
        $"Controller: {controller} \nAction: {action} \nId: {id}"
);
```

Мы можем обозначить любое количество сегментов в запросе, чтобы не быть жестко привязанным к числу сегментов с помощью параметра со специальным знаком `*` и `**`.

```c#
// users/Bob -> info = Bob
// users/Bob/41 -> info = Bob/41
app.Map("users/{**info}", (string info) => $"User Info: {info}");
```

---
---
---

Конечная точка или `endpoint` представляет некоторый код, который обрабатывает запрос. По сути конечная точка объединяет шаблон маршрута, которому должен соответствовать запрос, и обработчик запроса по этому маршруту.

По умолчанию предоставляется простой и удобный функционал для создания конечных точек. Ключевым типом в этом функционале является интерфейс `Microsoft.AspNetCore.Routing.IEndpointRouteBuilder`.

Он определяет ряд методов для добавления конечных точек в приложение. И поскольку класс `WebApplication` также реализует данный интерфейс, то все методы интерфейса мы можем непосредственно вызывать и у объекта `WebApplication`.

Для использования системы маршрутизации в конвейер обработки запроса добавляются два встроенных компонента middleware:

==**EndpointMiddleware**==. Компонент который добавляет в конвейер обработки запроса конечные точки. Добавляется в конвейер с помощью метода `UseEndpoints()`.

**==EndpointRoutingMiddleware==**. Добавляет сопоставления запросов и маршрутов. Он выбирает конечную точку, для обработки запроса. Добавляется через `UseRouting()`.

Причем обычно не требуется явным образом подключать эти два компонента middleware. Объект `WebApplicationBuilder` автоматически сконфигурирует конвейер таким образом, чтобы они добавились при использовании конечных точек.

---

**==Map(pattern, ReqDel)==**. Добавляет конечные точки для обработки запросов. Является самым простым способом определени


я конечной точки, реализован как метод расширения для типа `IEndpointRouteBuilder`, применяется к объекту продолжения. 

В всех реализациях этот метод в качестве параметра `pattern` принимает шаблон маршрута, которому должен соответствовать запрос для сопоставления. 

Последний параметр представляет действие, которое будет обрабатывать запрос. Это может быть делегат типа `RequestDelegate`, либо делегат типа `Delegate`.

>[!info] Одноименный метод Map
>Стоит отметить, что не стоит путать этот метод с одноименным методом Map(), который реализован как метод расширения для типа IApplicationBuilder. И служит для не терминального компонента middleware в конвейер обработки запроса.

Также интерфейс `IEndpointRouteBuilder` определяет еще два метода `MapGet` и `MapPost`, которые помимо сопоставления паттерна проверяют еще и тип HTTP запроса.

---

При построении паттерна маршрута мы можем извлекать из него определенный параметры. Для этого имя элемента маршрута должно быть заключено в фигурные скобки. Затем значение элемента можно будет получить как параметр в обработчике.

Система на основании шаблона маршрута автоматически извлекает из строки запроса значения для параметров маршрута вне зависимости от содержимого этих значений. 

Однако это не всегда бывает удобно. Например, мы хотим, чтобы какой-то параметр представлял только числа, а другой параметр начинался строго с определенного символа. И для этого необходимо задать ограничения маршрута (`route constraints`).

Для создания ограничения параметра маршрута нужно после имени элемента через двоеточие указать тип принимаемого значения. При несоответствии типов параметров маршрута, сервер автоматически пропустит обработчик запроса при обработке.

Хотя фреймворк ASP.NET Core по умолчанию предоставляет большой набор встроенных ограничений, их может быть недостаточно. И в этом случае мы также можем определить свои пользовательские ограничения маршрутов.

Для создания ограничения маршрута нужно создать класс реализовывающий интерфейс `IRouteConstraint` с одним единственным методом `Match`. Далее ограничение можно добавить через конфигурацию сервиса `RouteOptions`.

```c#
public class SecretCodeConstraint : IRouteConstraint
{
    public bool Match(HttpContext? httpContext, IRouter? route, string routeKey,              RouteValueDictionary values, RouteDirection routeDirection)
    {
        return true;
    }
}

builder.Services.Configure<RouteOptions>(options =>
    options.ConstraintMap.Add(name, typeof(SecretCodeConstraint)));

app.Map("{token:secretcode(123466)}/", (int token) => "");
```

---

Сопоставление адреса (`URL matching`) представляет процесс сопоставления запроса с конечной точкой. Данный процесс основывается на пути запроса и полученных в запросе заголовках. Данный процесс проходит ряд определенных этапов:

1. Сначала выбираются все конечные точки, шаблон маршрута которых совпадает с маршрутом по которому выполняется запрос к серверному приложению.
    
2. Далее из полученного на предыдущем этапе набора конечных точек удаляются те, которые не соответствуют ограничениям маршрута конечной точки.
    
3. Затем из полученного на предыдущем этапе набора конечных точек удаляются те, которые не удовлетворяют политике порядка сравнения `MatcherPolicy`.
    
4. И в самом конце применяется объект `EndpointSelector` для выбора из полученного на предыдущем этапе списка конечной точки, которая и будет обрабатывать запрос.

При обработке запроса в приоритет ставится тот обработчик, который более точно описывает маршрут запроса. Если в конечном счете осталось несколько обработчиков с равными приоритетами, которые соответствуют адресу, то генерируется исключение.

---

Кроме конечных точек запрос могут обрабатывать и другие компоненты middleware. При этом надо учитывать общий процесс обработки запроса и вызова конечных точек.

Так, если приложение содержит конечные точки, то система маршрутизации на основе  сопоставления адреса выбирает для обработки определенную конечную точку.

Если в приложении есть такая конечная точка, которая соответствует запросу, то компонент `EndpointRoutingMiddleware` устанавливает у объекта `HttpContext` конечную точку для будущей обработки запроса, получаемую через `HttpContext.GetEndpoint()`.

Однако конечная точка начинает обрабатывать запрос только после того, как все middleware в конвейере начнут обработку запроса, но еще не начнут ее заканчивать. 

[[AspNetCore/🟡Base|🟡Base]]
