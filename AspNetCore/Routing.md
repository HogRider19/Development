Система маршрутизации отвечает за сопоставление входящих запросов с маршрутами и на основании результатов сопоставления выбирает для обработки выходящего запроса определенную конечную точку, которая определяется приложением. 

Конечная точка или `endpoint` представляет некоторый код, который обрабатывает запрос. По сути конечная точка объединяет шаблон маршрута, которому должен соответствовать запрос, и обработчик запроса по этому маршруту.

По умолчанию предоставляется простой и удобный функционал для создания конечных точек. Ключевым типом в этом функционале является интерфейс `Microsoft.AspNetCore.Routing.IEndpointRouteBuilder`.

Он определяет ряд методов для добавления конечных точек в приложение. И поскольку класс `WebApplication` также реализует данный интерфейс, то все методы интерфейса мы можем непосредственно вызывать и у объекта `WebApplication`.

Для использования системы маршрутизации в конвейер обработки запроса добавляются два встроенных компонента middleware:

==**EndpointMiddleware**==. Компонент который добавляет в конвейер обработки запроса конечные точки. Добавляется в конвейер с помощью метода `UseEndpoints()`.

**==EndpointRoutingMiddleware==**. Добавляет сопоставления запросов и маршрутов. Он выбирает конечную точку, для обработки запроса. Добавляется через `UseRouting()`.

Причем обычно не требуется явным образом подключать эти два компонента middleware. Объект `WebApplicationBuilder` автоматически сконфигурирует конвейер таким образом, чтобы они добавились при использовании конечных точек.

---

**==Map(pattern, ReqDel)==**. Добавляет конечные точки для обработки запросов. Является самым простым способом определения конечной точки, реализован как метод расширения для типа `IEndpointRouteBuilder`, применяется к объекту продолжения. 

В всех реализациях этот метод в качестве параметра `pattern` принимает шаблон маршрута, которому должен соответствовать запрос для сопоставления. 

Последний параметр представляет действие, которое будет обрабатывать запрос. Это может быть делегат типа `RequestDelegate`, либо делегат типа `Delegate`.

>[!info] Одноименный метод Map
>Стоит отметить, что не стоит путать этот метод с одноименным методом Map(), который реализован как метод расширения для типа IApplicationBuilder. И служит для не терминального компонента middleware в конвейер обработки запроса.

Также интерфейс `IEndpointRouteBuilder` определяет еще два метода `MapGet` и `MapPost`, которые помимо сопоставления паттерна проверяют еще и тип HTTP запроса.

---

При построении паттерна маршрута мы можем извлекать из него определенный параметры. Для этого имя элемента маршрута должно быть заключено в фигурные скобки. Затем значение элемента можно будет получить как параметр в обработчике.

Система на основании шаблона маршрута автоматически извлекает из строки запроса значения для параметров маршрута вне зависимости от содержимого этих значений. 

Однако это не всегда бывает удобно. Например, мы хотим, чтобы какой-то параметр представлял только числа, а другой параметр начинался строго с определенного символа. И для этого необходимо задать ограничения маршрута (`route constraints`).

Для создания ограничения параметра маршрута нужно после имени элемента через двоеточие указать тип принимаемого значения. При несоответствии типов параметров маршрута, сервер автоматически пропустит обработчик запроса при обработке.

Хотя фреймворк ASP.NET Core по умолчанию предоставляет большой набор встроенных ограничений, их может быть недостаточно. И в этом случае мы также можем определить свои пользовательские ограничения маршрутов.

Для создания ограничения маршрута нужно создать класс реализовывающий интерфейс `IRouteConstraint` с одним единственным методом `Match`. Далее ограничение можно добавить через конфигурацию сервиса `RouteOptions`.

```c#
public class SecretCodeConstraint : IRouteConstraint
{
    public bool Match(HttpContext? httpContext, IRouter? route, string routeKey,              RouteValueDictionary values, RouteDirection routeDirection)
    {
        return true;
    }
}

builder.Services.Configure<RouteOptions>(options =>
    options.ConstraintMap.Add(name, typeof(SecretCodeConstraint)));

app.Map("{token:secretcode(123466)}/", (int token) => "");
```

---

Сопоставление адреса (`URL matching`) представляет процесс сопоставления запроса с конечной точкой. Данный процесс основывается на пути запроса и полученных в запросе заголовках. Данный процесс проходит ряд определенных этапов:

1. Сначала выбираются все конечные точки, шаблон маршрута которых совпадает с маршрутом по которому выполняется запрос к серверному приложению.
    
2. Далее из полученного на предыдущем этапе набора конечных точек удаляются те, которые не соответствуют ограничениям маршрута конечной точки.
    
3. Затем из полученного на предыдущем этапе набора конечных точек удаляются те, которые не удовлетворяют политике порядка сравнения `MatcherPolicy`.
    
4. И в самом конце применяется объект `EndpointSelector` для выбора из полученного на предыдущем этапе списка конечной точки, которая и будет обрабатывать запрос.

При обработке запроса в приоритет ставится тот обработчик, который более точно описывает маршрут запроса. Если в конечном счете осталось несколько обработчиков с равными приоритетами, которые соответствуют адресу, то генерируется исключение.

---

Кроме конечных точек запрос могут обрабатывать и другие компоненты middleware. При этом надо учитывать общий процесс обработки запроса и вызова конечных точек.

Так, если приложение содержит конечные точки, то система маршрутизации на основе  сопоставления адреса выбирает для обработки определенную конечную точку.

Если в приложении есть такая конечная точка, которая соответствует запросу, то компонент `EndpointRoutingMiddleware` устанавливает у объекта `HttpContext` конечную точку для будущей обработки запроса, получаемую через `HttpContext.GetEndpoint()`.

Однако конечная точка начинает обрабатывать запрос только после того, как все middleware в конвейере начнут обработку запроса, но еще не начнут ее заканчивать. 

[[AspNetCore/Base|Base]]
