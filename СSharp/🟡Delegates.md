**Делегат** - типобезопасный указатель на группу методов.
**Ковариантность делегата** - возвращаемым типом может быть производный тип
**Контравариантность** - типом параметра может быть более универсальный тип

Компилятор превращает каждый такой тип-делегат в одноименный класс и все экземпляры данного делегата по факту являются экземплярами этого класса.

Каждый такой класс наследует тип MulticastDelegate от которого ему достаются методы Combine и Remove, конструктор с двумя аргументами target(Object) и methodPtr(IntPtr), поле invocationList(Object) и три собственных метода Invoke, BeginInvoke, EndInvoke.

Объявляя делегат мы жестко определяем сигнатуру допустимых методов, которыми могут быть инициализированы экземпляры такого делегата. Это влияет на сигнатуру автогенерируемых методов Invoke, BeginInvoke, EndEnvoke, поэтому эти методы и не наследуются от базового типа а определяются отдельно.

В поле target записывается ссылка на владельца метода, для работы с полями в теле делегата. А в methodPtr ссылка на метод. Если метод статический то записываются в поля target и methodPtr будут записаны null и ссылка на метод соответственно.

Метод Combine класса Delegate возвращает ссылку на новый делегат в котором поля target и methodPtr пусты, но invocationList, который содержит две ссылки на делегаты.  
  
При выполнении такого делегата все его методы будут выполнены по очереди. Если есть возвращаемое значение, то получим значение последнего в списке метода.

---
**Анонимный метод** - один из способов создания безымянного блока кода, связанного с конкретным экземпляром делегата. Для создания анонимного метода достаточно указать кодовый блок после ключевого слова delegate.

Анонимные методы, если они не используют свое лексическое окружение, компилируются в приватные методы вызывающего класса. Этот метод может быть статическим, если в его теле нет обращаться к полям и методам своего экземпляра.

В случае если анонимный метод замыкает локальные переменные, компилятор сгенерирует вспомогательный класс, который будет хранить значения локальных переменных и сам анонимный метод. 

Так как время жизни делегата неизвестно, то переменные, захваченные в замыкание, приходится переносить в кучу (в поля вспомогательного класса), при этом все обращения к локальным переменным заменяются на обращения к полям вспомогательного класса, для реализации возможности изменения локальных переменных внутри тела делегата.

Если два различных анонимных метода замыкаю общие локальные переменные, то тогда для них будет создан один общий вспомогательный класс. Это приведет к тому что локальные переменные не будут высвобождены до момента пока оба анонимных метода не выйдут из контекста, что может привести к неожиданным утечкам памяти. 

Анонимный метод разрешает опускать список параметров, если они вам не нужны внутри метода(в отличии от лямбд). В этом случае, анонимный метод может быть преобразован к делегату с различной сигнатурой.

**Лямбда выражения** - упрощенная запись анонимных методов. Так же как и анонимные методы могут быть скомпилированы в приватные метод экземпляра или вспомогательные классы. Также в зависимости от контекста лямбда выражения могут быть скомпилированы в Expressio\<TDelegate>, то есть в дерево выражений.

На этапе компиляции каждое такое выражение превращается в анонимный private метод с именем начинающимся на "<" что исключает возможность вызова такого метода напрямую. Этот метод всегда является членом типа в котором вы используете данное лямбда выражение, и передается в конструктор делегата явно в CIL коде.

Компилятор анализирует содержит ли выражение в своем теле операции с  полями владеющего типа. Если нет, то метод будет статическим. Это исключает накладные расходы вызова метода, связанными с лишней передачей параметра this.

---

**Action<T1..T16>** - представляет некоторое действие, которое ничего не возвращает. Данный делегат имеет ряд перегруженных версий. Каждая версия принимает разное число параметров. Таким образом можно передать до 16 значений в метод.

**Predicate<\T>** - принимает один параметр и возвращает значение типа bool. Как правило, используется для сопоставления объекта T определенному условию.

**Func<T1..T16, TRes>** - возвращает результат действия и может принимать параметры. Он также имеет различные формы. Последним типом всегда передается тип результата.









