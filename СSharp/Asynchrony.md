Асинхронность сама по себе далеко не нова. Как правило, асинхронность подразумевает выполнение операции в стиле, не подразумевающем блокирование вызвавшего потока,
то есть запуск некоторых программных единиц работы без ожидания ее завершения.

Асинхронность понятие весьма обширное и может достигаться многими путями. Например она может быть реализована с использованием многопоточности или возврате управления.  
В `c#` асинхронность может быть реализована с использованием `EAP`,  `APM` и также `TAP`.

**==EAP (EventAsyncPattern)==**. Представляет поход основанный на событиях, которые срабатывают по завершении операции выполнения определенного метода.

**==APM(AsyncProgramModel)==**. Подход основанный на методах `BeginSmth`, который
возвращает `IAsyncResult` и методе `EndSmth` принимающем `IAsyncResult`. 

**==TAP(TaskAsyncPattern)==**. Подход основанный на синтаксическом сахаре `async/await`
с использованием класса `Task`. Именно этот подход используется в новых версиях.

Для написания асинхронного метода нужно создать метод с возвращаемым значением 
`Task`, `Task<T>`, `ValueTask`, `void`, `IAsyncEnumerable<T>`, `IAsyncEnumerator<T>` или
любой другой объект с методом `GetAwaiter`. Также метод должен быть помечен
ключевым словом `async`, а внутри тела содержать вызов оператора `await`.

Ключевое слово `await` указывает на необходимость асинхронного ожидания выполнения некоторой задачи, которую представляет тот объект задачи, к которому оно применяется.  
Объект задачи должен иметь публичный метод `GetAwaiter()`, который возвращает объект ожидания в виде `INotifyCompletion`. Интерфейс ожидания обязывает реализовать метод `OnCompleted(Action)`, свойство `IsCompleted` и метод возврата результата `GetResult()`.

>[!info] Утиная типизация
>Возможность ожидания типа определяется при развертке синтаксического сахара,
> то есть с использованием утиной типизации. Это позволяет реализовать метод GetAwaiter в методе расширения для любого типа, даже для обычного int.


Асинхронный метод преобразовывается компилятором в метод заглушку, в которой происходит инициализация сгенерированного класса машины состояний. Далее она
запускается, а из метода заглушки возвращается связанный с нею объект `Тask`.  
  
Особый интерес представляет метод `MoveNext` машины состояний. Он выполняет то, что было до преобразования в асинхронном методе. Он разбивает код на части между каждым вызовом `await`. Каждая часть выполняется при определенном состоянии машины. Сам метод `MoveNext` присоединяется к объекту ожидания в качестве продолжения.

Важно понимать, что все локальные переменные в асинхронном методе будут перенесены
в поля класса машины состояний, что может вызвать дополнительный расход памяти в куче.

Асинхронная операция может пойти и по синхронному пути выполнения. Главное условие для того, чтобы текущий асинхронный метод выполнялся синхронно, то есть не меняя поток выполнения это завершенность асинхронной операции на момент вызова оператора `await`.

Выполнение ожидания в машине состояний приводит к вызову продолжения через контекст синхронизации `SynchronizationContext.Current`, если при ожидании не было указано что нам не важно в каком контексте выполнять продолжение через `ConfigureAwait(false)`.

Если текущий контекст не указан при вызове метода или при ожидании мы указываем `ConfigureAwait(false)`, то продолжение выполнится потоком из пула. В `AspNetCore` запросы не имеют контекста, так что ожидание не имеет смысла конфигурировать.

Зачастую в веб приложениях зачастую, каждый поступающий запрос порождает вытягивание нового потока из `ThreadPool` для обработки. В случае, когда запросов
много, потоков на всех может не хватать, и все новые запросы будут ставиться в очередь
на обработку. Но в случае использования асинхронных контроллеров, поток при ожидании можно вернуть в пул, где он может быть использован для обработки новых запросов.
Таким образом существенно увеличивается пропускная способность сервера.

---

Асинхронность представляет концепцию выполнения программ, которая позволяет компьютеру одновременно выполнять несколько задач, не ожидая завершения каждой отдельной задачи. Это достигается путем выполнения задач в различных потоках или процессах. Также может быть реализована на возврате управления из задачи.

Асинхронность позволяет вынести отдельные задачи из основного потока в специальные асинхронные методы и при этом более экономно использовать потоки. 

Асинхронные методы выполняются в отдельных потоках. При выполнении долгой блокирующей операции поток асинхронного метода возвратится в пул потоков.

Когда блокирующая операция завершается, для асинхронного метода опять выделяется поток из пула потоков, и асинхронный метод продолжает свою работу.

При работе с асинхронностью мы оперируем задачами библиотеки `TPL`. Одна задача может выполняться многими потоками, а один поток может выполнять много задач.

Для асинхронного выполнения метода, метод должен содержать модификатор `async`, и иметь вызов `await`. Такой метод при вызове вернет экземпляр запущенной задачи.

В качестве возвращаемого типа используется один из следующих: `void`, `Task`, `Task<T>` и `ValueTask<T>`. Асинхронный метод, как и обычный, может использовать любое количество параметров. Однако не может определять параметры с `out`, `ref` и `in`.

Использование типа `ValueTask<T>` во многом аналогично применению `Task<T>` за исключением некоторых различий в работе с памятью, поскольку представляет собой структуру, которая содержит большее количество полей. Поэтому применение этой структуры приводит к копированию большего количества данных.

В свою очередь преимуществом `ValueTask` перед `Task` является то, что данный тип позволяет избежать дополнительных выделений памяти в управляемой куче . Например, иногда требуется синхронно возвратить некоторое значение. При необходимости можно преобразовать `ValueTask` в объект `Task` с помощью `AsTask()`.

```c#
var result1 = await AddAsync1(4, 5);
var result2 = await AddAsync2(4, 5);
 
Task<int> AddAsync1(int a, int b) => Task.FromResult(a + b);
ValueTask<int> AddAsync2(int a, int b) => new ValueTask<int>(a + b);;
```

[[СSharp/🟡Base|🟡Base]]