Сборка мусора представляет собой высокоуровневую абстракцию, избавляющую разработчиков от необходимости заботиться об освобождении управляемой памяти. В окружениях, снабженных механизмом сборки мусора, выделение памяти производится в момент создания объектов, а освобождение происходит, когда в программе исчезает последняя ссылка на объект. Кроме того, сборщик мусора предоставляет интерфейс финализации для неуправляемых ресурсов за пределами управляемой памяти.

**==Управление свободным списком==**. Представляет механизм управления распределением памяти в стандартной библиотеке языка `C`, который также по умолчанию используется функциями управления памятью в `C++`, то есть `new` и `delete`. Это детерминированный диспетчер памяти, при использовании которого вся ответственность за выделение и освобождение памяти ложится на плечи разработчика. Свободные блоки памяти хранятся в виде связанного списка, откуда изымаются и возвращаются.

![[{3916BD0C-1D70-4515-9679-C9577CA5CFC4}.png]]

Он изымает блоки из списка при выделении памяти и возвращает их обратно при освобождении. Приложение обычно получает блоки памяти, хранящие их размеры в служебной области. Механизм управления памятью на основе списка не свободен от тактических и стратегических решений, влияющих на производительность приложения.

Поиск блока, соответствующего параметрам запроса, требует времени. Кроме того, блоки часто разбиваются на несколько частей. В многопроцессорных системах неизбежно возникает конкуренция за список и необходимость синхронизации операций, если только в приложении используется несколько списков.

Возврат блока в список требует времени, и здесь снова возникает проблема синхронизации конкурирующих операций освобождения памяти.

**==Подсчет ссылок==**. Сборщик мусора, опирающийся на подсчет ссылок, связывает каждый объект с целочисленной переменной счетчиком ссылок. В момент создания объекта счетчик ссылок инициализируется значением 1. Когда приложение создает новую ссылку на объект, его счетчик ссылок увеличивается на 1. Когда приложение удаляет ссылку на существующий объект, его счетчик ссылок уменьшается на 1. Когда счетчик ссылок достигает значения 0, объект можно уничтожить и освободить его память.

![[{76975A56-E1D0-4882-B1BB-368FC78BB4CC}.png]]

Когда создается или уничтожается ссылка на объект, необходимо обновлять счетчик ссылок. Это означает, что к стоимости обновления прибавляются накладные расходы.

Счетчик ссылок на объект должен храниться в памяти объекта. Это увеличивает объем памяти объекта, что делает механизм нецелесообразным для легковесных объектов.

При управлении памятью на основе подсчета ссылок возникает проблема утилизации объектов с циклическими ссылками. Если приложение больше не ссылается на пару объектов, но каждый из них хранит ссылки на друг друга, возникает утечка памяти.

**==На основе трассировки==**. Сборка мусора на основе трассировки применяется для управления динамической памятью в `NetCLR`, `JavaVM` и в других управляемых окружениях. В этих окружениях никак не используются счетчики ссылок.

Разработчику не требуется явно освобождать память, об этом позаботится сборщик мусора. При использовании сборки мусора на основе трассировки в объекты не добавляются счетчики ссылок, и обычно освобождение памяти не будет
выполняется, пока уровень ее использования не достигнет порога.

Когда запускается цикл сборки мусора, он начинается с фазы маркировки, в ходе которой выявляются все объекты, на которые существуют ссылки в приложении.
После определения множества живых объектов, сборщик приступает к выполнению фазы чистки, в ходе которой он освобождает память, занимаемую неиспользуемыми объектами. В заключение выполняется фаза дефрагментации, в которой сборщик мусора перемещает живые объекты так, чтобы они располагались друг за другом.

Стоимость выделения памяти сопоставима с выделением кадра на стеке, потому что отсутствует необходимость предусматривать сохранение какой-либо информации, для освобождении объекта. Выделение памяти заключается в наращивании указателя.

Сборка мусора выполняется циклически, а не распределяется примерно равномерно по всему времени выполнения приложения. Это имеет свои как преимущества так и недостатки, в частности для ситуаций, когда требуется низкое время задержки.

Поиск объектов по ссылкам требует значительных затрат от среды выполнения. Ссылки на объекты могут храниться в статических переменных, локальных переменных потока выполнения, передаваемых как указатели в неуправляемый код, и в других местах. Трассировка всех возможных ссылок на каждый доступный объект далеко не тривиальная задача, и часто сопряжена с затратами на итерации коллекций.

Перемещение объектов в памяти требует времени, что может оказаться невозможным для очень больших объектов. С другой стороны, устранение пустых, неиспользуемых пространств между объектами способствует локальности ссылок, потому что объекты, создававшиеся одновременно, наверняка окажутся в памяти рядом по соседству.

