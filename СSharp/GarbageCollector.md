Сборка мусора представляет собой высокоуровневую абстракцию, избавляющую разработчиков от необходимости заботиться об освобождении управляемой памяти. В окружениях, снабженных механизмом сборки мусора, выделение памяти производится в момент создания объектов, а освобождение происходит, когда в программе исчезает последняя ссылка на объект. Кроме того, сборщик мусора предоставляет интерфейс финализации для неуправляемых ресурсов за пределами управляемой памяти.

**==Управление свободным списком==**. Представляет механизм управления распределением памяти в стандартной библиотеке языка `C`, который также по умолчанию используется функциями управления памятью в `C++`, то есть `new` и `delete`. Это детерминированный диспетчер памяти, при использовании которого вся ответственность за выделение и освобождение памяти ложится на плечи разработчика. Свободные блоки памяти
хранятся в виде связанного списка, откуда изымаются и возвращаются.

![[{3916BD0C-1D70-4515-9679-C9577CA5CFC4}.png]]

Он изымает блоки из списка при выделении памяти и возвращает их обратно при освобождении. Приложение обычно получает блоки памяти, хранящие их размеры в служебной области. Механизм управления памятью на основе списка не свободен от тактических и стратегических решений, влияющих на производительность приложения.

Поиск блока, соответствующего параметрам запроса, требует времени. Кроме того, блоки часто разбиваются на несколько частей. В многопроцессорных системах неизбежно возникает конкуренция за список и необходимость синхронизации операций, если только в приложении используется несколько списков. Возврат блока в список требует времени, и здесь снова возникает проблема синхронизации операций освобождения памяти.

**==Подсчет ссылок==**. Сборщик мусора, опирающийся на подсчет ссылок, связывает каждый объект с целочисленной переменной счетчиком ссылок. Когда приложение создает новую ссылку на объект, его счетчик ссылок увеличивается. Когда приложение удаляет ссылку на существующий объект, его счетчик ссылок уменьшается. Когда счетчик ссылок
достигает значения 0, объект можно уничтожить и освободить его память.

![[{76975A56-E1D0-4882-B1BB-368FC78BB4CC}.png]]

Когда создается или уничтожается ссылка на объект, необходимо обновлять счетчик ссылок. Это означает, что к стоимости обновления прибавляются накладные расходы.

Счетчик ссылок на объект должен храниться в памяти объекта. Это увеличивает объем памяти объекта, что делает механизм нецелесообразным для легковесных объектов.

При управлении памятью на основе подсчета ссылок возникает проблема утилизации объектов с циклическими ссылками. Если приложение больше не ссылается на пару объектов, но каждый из них хранит ссылки на друг друга, возникает утечка памяти.

**==На основе трассировки==**. Сборка мусора на основе трассировки применяется для управления динамической памятью в `NetCLR`, `JavaVM` и в других управляемых окружениях. В этих окружениях сборщик мусора никак не используем механизм подсчета ссылок.

Разработчику не требуется явно освобождать память, об этом позаботится сборщик мусора. При использовании сборки мусора на основе трассировки обычно освобождение памяти не будет выполняется, пока уровень ее использования не достигнет определенного порога.

Когда запускается цикл сборки мусора, он начинается с фазы маркировки, в ходе которой выявляются все объекты, на которые существуют ссылки в приложении. После определения множества живых объектов, сборщик приступает к выполнению фазы чистки, в ходе которой он освобождает память, занимаемую неиспользуемыми объектами. Затем может запуститься фаза дефрагментации, в которой сборщик перемещает объекты в общий плотный кластер.

Стоимость выделения памяти сопоставима с выделением кадра на стеке, потому что отсутствует необходимость предусматривать сохранение какой-либо информации, для освобождении объекта. Выделение памяти заключается в наращивании указателя.

Сборка мусора выполняется циклически, а не распределяется примерно равномерно по всему времени выполнения приложения. Это имеет свои как преимущества так и недостатки.

Поиск объектов по ссылкам требует значительных затрат от среды выполнения. Ссылки на объекты могут храниться в статических переменных, локальных переменных потоков и так далее. Трассировка всех возможных ссылок на каждый доступный объект далеко не тривиальная задача, и часто сопряжена с затратами на итерации через коллекции.

Перемещение объектов в памяти требует времени, что может оказаться невозможным
для очень больших объектов. С другой стороны, устранение пустых пространств между объектами способствует локальности ссылок, потому что объекты, создававшиеся одновременно, наверняка окажутся в памяти рядом по соседству.

---

На этапе маркировки, сборщик мусора выполняет обход графа всех объектов, на которые ссылается приложение. Для успешного обхода графа и предотвращения ошибок первого и второго рода, сборщику мусора необходимо множество опорных точек, откуда можно будет начать обход ссылок. Эти отправные точки называют корнями дерева графа ссылок. 

После определения множества корней, остальные операции, выполняемые сборщиком мусора на этапе маркировки, просты и понятны. Он просматривает каждое внутреннее ссылочное поле в каждом корне и выполняет обход, пока не посетит все объекты.
Поскольку допускается создавать циклические ссылки, сборщик мусора маркирует посещенные им объекты, чтобы впредь не задерживаться на их обработке.

Наиболее типичными представителями корней являются локальные переменные, единственная локальная переменная может быть корнем целого графа объектов.
Всякая локальная переменная, которая потенциально может хранить ссылку на
объект, считается активным корнем, пока кадр стека метода не будет разрушен.

Сборщик мусора понятия не имеет, когда локальная переменная выходит из употребления в пределах метода. Эта информация записывается в специальные таблицы `JIT` компилятором в процессе компиляции метода. Для каждой локальной переменной компилятор записывает в таблицу адрес самой первой и самой последней инструкции, где локальная переменная остается активным корнем. Таблица используется сборщиком в процессе обхода ссылок. 

Локальные переменные могут храниться не только на стеке, но и в регистрах
процессора, и таблицы `JIT` компилятора должны знать об этой особенности.

Из этого следует, что объект с ссылкой в локальной переменной, может быть удален, до выхода из фрейма стека. Это поведение может быть не желательным, например при создании таймера. Чтобы этого избежать можно было бы использовать статическую переменную или метод `GC.KeepAlive()`, гарантирующий сохранность ссылки.

```c#
static void Main(string[] args)
{
	Timer timer = new Timer(OnTimer, null, 0, 1000);
	Console.ReadLine();
	GC.KeepAlive(timer);
}

static void OnTimer(object state)
{
	Console.WriteLine(DateTime.Now.TimeOfDay);
	GC.Collect();
}
```

Метод `GC.KeepAlive` устроен очень просто, по факту это просто пустой метод с
запретом на оптимизацию встраиванием, служить лишь для сохранения ссылки.

Еще одной разновидностью корней являются статические переменные. Статические члены типов создаются в момент их загрузки и считаются активными корнями на протяжении всего времени выполнения приложения. Статические переменные самые частые причины утечек.

Две категории корней, описанные выше, являются наиболее распространенными, однако существуют и другие категории. Например, дескрипторы сборщика `GCHandle`. Очередь объектов, готовых к завершению, объекты ожидающие финализации. Знание различных категорий корней может пригодиться при отладке утечек памяти в приложениях.

Фаза маркировки в цикле сборки мусора является фазой преимущественно для чтения, в процессе выполнения которой не производится перемещение объектов в памяти или их удаление. Тем не менее, эта фаза оказывает существенное влияние скорость работы.

В процессе маркировки сборщик мусора должен посетить каждую ссылку на объект. Это может приводить к ошибкам чтения страниц памяти, если они вытеснены в файл подкачки.

Обработка неиспользуемых объектов оказывается менее дорогостоящей на этом этапе, поэтому производительность фазы маркировки пропорциональна коэффициенту эффективности сборки: отношению используемых и неиспользуемых объектов.

Производительность фазы маркировки зависит также от количества объектов в графе, но не зависит от объема памяти, занимаемой объектами. А это означает, что производительность фазы прямо пропорциональная количеству живых объектов, управляемых компилятором.

---

В фазах чистки и сжатия сборщик мусора освобождает память, перемещая живые объекты так, чтобы они располагались в памяти последовательно, друг за другом в кластере.

Выделение памяти выполняется простым наращиванием указателя, который всегда ссылается на следующий свободный блок памяти. Он называется `newObjectPointer` 
и инициализируется при передаче динамической памяти при запуске приложения.

![[{E242D612-55EF-433B-B5C0-F115862646F0}.png]]

Выделение памяти в этой модели выполняется чрезвычайно быстро: достаточно просто выполнить единственную атомарную операцию увеличения указателя. Но в конкурентных системах будут возникать конкуренция за право доступа к указателю `newObjectPointer`.

Если бы память была неисчерпаемым ресурсом, запросы на выделение памяти можно было бы удовлетворять до бесконечности, просто увеличивая указатель на следующий объект. Однако  в некоторый момент времени будет достигнут определенный порог, за которым последует принудительный запуск процедуры сборки мусора. Все пороговые значения являются динамическими и доступны для настройки через чреду выполнения `CLR`.

В фазе сжатия сборщик мусора перемещает живые объекты в памяти, размещая 
их рядом друг с другом. Это способствует локальности ссылок, потому что объекты, создававшиеся одновременно, наверняка окажутся в памяти по соседству. С другой 
стороны, перемещение объектов влечет за собой две проблемы производительности.

Перемещение объектов означает необходимость копирования блоков памяти, что для крупных объектов не эффективно. Поэтому большие объекты обслуживаются иначе.

При перемещении объектов необходимо обновлять ссылки на них соответственно их новому местоположению. Для широко используемых объектов, обновление большого количества ссылок может оказаться медленной и очень дорогостоящей операцией.

Вопреки распространенному мнению, сборщик мусора не всегда перемещает объекты, даже если они не закреплены и между ними есть свободное пространство. Сборщик мусора определенным образом оценивает ситуацию и выбирает один из вариантов.

![[{2E71FB78-4BE7-4A29-A64E-99E4B26C4390}.png]]

Дефрагментация объектов может быть проблемой, если мы хотим передать ссылку на управляемый объект не управляемому коду. В таком случае мы могли бы на это время отключать сборщик, но это влечет гигантские накладные расходы. Вместо этого мы может воспользоваться специальной операцией закрепления объекта в памяти среды выполнения.

Сама операция закрепления стоит не очень дорого. Существует несколько механизмов, выполняющих ее очень быстро. Наиболее явным способом закрепления объекта является создание дескриптора сборщика мусора с флагом `GCHandleType.Pinned`. В результате создается новый корень в таблице дескрипторов, сообщающий сборщику мусора, что объект должен оставаться прикрепленным к определенному адресу в памяти. 

В число альтернатив входят магическая приправа, добавляемая маршалером `P/Invoke`, и механизм закрепленных указателей, предоставляемый языком в виде ключевого слова `fixed`, который опирается на специальную маркировку локальных переменных.