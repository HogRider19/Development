Сборка мусора представляет собой высокоуровневую абстракцию, избавляющую разработчиков от необходимости заботиться об освобождении управляемой памяти. В окружениях, снабженных механизмом сборки мусора, выделение памяти производится в момент создания объектов, а освобождение происходит, когда в программе исчезает последняя ссылка на объект. Кроме того, сборщик мусора предоставляет интерфейс финализации для неуправляемых ресурсов за пределами управляемой памяти.

**==Управление свободным списком==**. Представляет механизм управления распределением памяти в стандартной библиотеке языка `C`, который также по умолчанию используется функциями управления памятью в `C++`, то есть `new` и `delete`. Это детерминированный диспетчер памяти, при использовании которого вся ответственность за выделение и освобождение памяти ложится на плечи разработчика. Свободные блоки памяти хранятся в виде связанного списка, откуда изымаются и возвращаются.

![[{3916BD0C-1D70-4515-9679-C9577CA5CFC4}.png]]

Он изымает блоки из списка при выделении памяти и возвращает их обратно при освобождении. Приложение обычно получает блоки памяти, хранящие их размеры в служебной области. Механизм управления памятью на основе списка не свободен от тактических и стратегических решений, влияющих на производительность приложения.

Поиск блока, соответствующего параметрам запроса, требует времени. Кроме того, блоки часто разбиваются на несколько частей. В многопроцессорных системах неизбежно возникает конкуренция за список и необходимость синхронизации операций, если только в приложении используется несколько списков.

Возврат блока в список требует времени, и здесь снова возникает проблема синхронизации конкурирующих операций освобождения памяти.

**==Подсчет ссылок==**. Сборщик мусора, опирающийся на подсчет ссылок, связывает каждый объект с целочисленной переменной счетчиком ссылок. В момент создания объекта счетчик ссылок инициализируется значением 1. Когда приложение создает новую ссылку на объект, его счетчик ссылок увеличивается на 1. Когда приложение удаляет ссылку на существующий объект, его счетчик ссылок уменьшается на 1. Когда счетчик ссылок достигает значения 0, объект можно уничтожить и освободить его память.

![[{76975A56-E1D0-4882-B1BB-368FC78BB4CC}.png]]

Когда создается или уничтожается ссылка на объект, необходимо обновлять счетчик ссылок. Это означает, что к стоимости обновления прибавляются накладные расходы.

Счетчик ссылок на объект должен храниться в памяти объекта. Это увеличивает объем памяти объекта, что делает механизм нецелесообразным для легковесных объектов.

При управлении памятью на основе подсчета ссылок возникает проблема утилизации объектов с циклическими ссылками. Если приложение больше не ссылается на пару объектов, но каждый из них хранит ссылки на друг друга, возникает утечка памяти.

**==На основе трассировки==**. Сборка мусора на основе трассировки применяется для управления динамической памятью в `NetCLR`, `JavaVM` и в других управляемых окружениях. В этих окружениях никак не используются счетчики ссылок.

Разработчику не требуется явно освобождать память, об этом позаботится сборщик мусора. При использовании сборки мусора на основе трассировки в объекты не добавляются счетчики ссылок, и обычно освобождение памяти не будет
выполняется, пока уровень ее использования не достигнет порога.

Когда запускается цикл сборки мусора, он начинается с фазы маркировки, в ходе которой выявляются все объекты, на которые существуют ссылки в приложении.
После определения множества живых объектов, сборщик приступает к выполнению фазы чистки, в ходе которой он освобождает память, занимаемую неиспользуемыми объектами. В заключение выполняется фаза дефрагментации, в которой сборщик мусора перемещает живые объекты так, чтобы они располагались друг за другом.

Стоимость выделения памяти сопоставима с выделением кадра на стеке, потому что отсутствует необходимость предусматривать сохранение какой-либо информации, для освобождении объекта. Выделение памяти заключается в наращивании указателя.

Сборка мусора выполняется циклически, а не распределяется примерно равномерно по всему времени выполнения приложения. Это имеет свои как преимущества так и недостатки, в частности для ситуаций, когда требуется низкое время задержки.

Поиск объектов по ссылкам требует значительных затрат от среды выполнения. Ссылки на объекты могут храниться в статических переменных, локальных переменных потока выполнения, передаваемых как указатели в неуправляемый код, и в других местах. Трассировка всех возможных ссылок на каждый доступный объект далеко не тривиальная задача, и часто сопряжена с затратами на итерации коллекций.

Перемещение объектов в памяти требует времени, что может оказаться невозможным для очень больших объектов. С другой стороны, устранение пустых, неиспользуемых пространств между объектами способствует локальности ссылок, потому что объекты, создававшиеся одновременно, наверняка окажутся в памяти рядом по соседству.

---

На этапе маркировки, сборщик мусора выполняет обход графа всех объектов, на которые ссылается приложение. Для успешного обхода графа и предотвращения ошибок первого и второго рода, сборщику мусора необходимо множество опорных точек, откуда можно будет начать обход ссылок. Эти отправные точки называют корнями `roots`. Они образуют корни ориентированных графов ссылок.

После определения множества корней, остальные операции, выполняемые сборщиком мусора на этапе маркировки, просты и понятны. Он просматривает каждое внутреннее ссылочное поле в каждом корне и выполняет обход, пока не посетит все объекты. Поскольку допускается создавать циклические ссылки, сборщик мусора маркирует посещенные им объекты, чтобы впредь не задерживаться на их обработке.

Наиболее типичными представителями корней являются локальные переменные, единственная локальная переменная может быть корнем целого графа объектов.
Всякая локальная переменная, которая потенциально может хранить ссылку на
объект, считается активным корнем, пока кадр стека метода не будет разрушен.

Сборщик мусора понятия не имеет, когда локальная переменная выходит из употребления в пределах метода. Эта информация записывается в специальные таблицы `JIT` компилятором в процессе компиляции метода. Для каждой локальной переменной `JIT` компилятор записывает в таблицу адрес самой первой и самой последней инструкции, где локальная переменная остается активным корнем. Эта таблица используется сборщиком мусора в процессе обхода ссылок на стеке.
Локальные переменные могут храниться не только на стеке, но и в регистрах процессора, и таблицы `JIT` компилятора должны знать об этой особенности.

Из этого следует, что объект с ссылкой в локальной переменной, может быть удален, до выхода из фрейма стека. Это поведение может быть не желательным, например при создании таймера. Чтобы этого избежать можно было бы использовать статическую переменную или вызвать метод `GC.KeepAlive()`, гарантирующий сохранность ссылки.

```c#
static void Main(string[] args)
{
	Timer timer = new Timer(OnTimer, null, 0, 1000);
	Console.ReadLine();
	GC.KeepAlive(timer);
}

static void OnTimer(object state)
{
	Console.WriteLine(DateTime.Now.TimeOfDay);
	GC.Collect();
}
```

Метод `GC.KeepAlive` устроен очень просто, по факту это просто пустой метод с запретом на оптимизацию встраиванием, служить лишь для сохранения ссылки.

Еще одной разновидностью корней являются статические переменные. Статические члены типов создаются в момент их загрузки и считаются активными корнями на протяжении всего времени выполнения приложения. Фактически, одной из наиболее типичных причин утечек памяти является сохранение ссылок в статических полях.

Две категории корней, описанные выше, являются наиболее распространенными, однако существуют и другие категории. Например, дескрипторы сборщика `GCHandle`. Очередь объектов, готовых к завершению, объекты ожидающие финализации, все еще считаются досягаемыми для сборщика мусора. Знание различных категорий корней может пригодиться при отладке утечек памяти в приложениях для написанных на `C#`.

Фаза маркировки в цикле сборки мусора является фазой преимущественно для чтения, в процессе выполнения которой не производится перемещение объектов в памяти или их удаление. Тем не менее, эта фаза оказывает существенное влияние скорость работы.

В процессе маркировки сборщик мусора должен посетить каждую ссылку на объект. Это может приводить к ошибкам чтения страниц памяти, если они оказываются вытеснены в файл подкачки, а также к промахам кеша и перезаписи кеша.

Обработка неиспользуемых объектов оказывается менее дорогостоящей на этом этапе, поэтому производительность фазы маркировки пропорциональна коэффициенту эффективности сборки: отношению используемых и неиспользуемых объектов.

Производительность фазы маркировки зависит также от количества объектов в графе, но не зависит от объема памяти, занимаемой этими объектами. Большие объекты, содержащие мало ссылок, влекут меньше накладных расходов. А это означает, что производительность фазы прямо пропорциональная количеству живых объектов.

---




