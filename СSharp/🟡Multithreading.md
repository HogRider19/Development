Одним из ключевых аспектов в современном программировании является многопоточность. Ключевым понятием при работе с многопоточностью является поток. Поток представляет некоторую часть кода программы.

При выполнении программы каждому потоку выделяется определенный квант времени. И при помощи многопоточности мы можем выделить в приложении несколько потоков, которые будут выполнять различные задачи одновременно. 

**System.Threading.Thread** - класс абстрагирующий поток
**Thread.CurrentThread** - получение текущего потока выполнения
## Методы и свойства Thread:

1. **Start** - запускает поток
2. **Name** - содержит имя потока
3. **IsAlive** - указывает, работает ли поток в текущий момент
4. **IsBackground** - указывает, является ли поток фоновым
5. **ExecutionContext** - возвращает контекст выполняется потока
6. **ManagedThreadId** - возвращает числовой идентификатор потока
7. **Priority** - хранит приоритет потока значение перечисления
8. **ThreadState** - возвращает состояние потока
9. **Sleep()** - останавливает поток на количество миллисекунд
10. **Interrupt()** - прерывает поток из состояния WaitSleepJoin
11. **Join()** - блокирует выполнение вызвавшего его потока до тех пор, пока не завершится поток, для которого был вызван данный метод

---

## Проблемы параллельного выполнения:

1. **Deadlock** - ситуация при которой потоки взаимно блокируют друг друга
    
2. **RaceCondition** - cитуация, в которой поведение и результат вычислений, выполняемых программой, зависит от работы планировщика потоков
    
3. **BusyWait** - проблема, при которой программа потребляет ресурсы процессора не для вычислений, а для ожидания
    
4. **ThreadStarvation** - проблема, при которой в программе слишком много одновременно работающих CPU потоков. При этом процессор тратит очень много времени на переключение контекстов


**Monitor** - критическая секция, то есть код, написанный между вызовами Monitor.Enter, Monitor.Exit на одном ресурсе может быть выполнен в один момент времени лишь одним потоком. Оператор lock (locker) является синтаксическим сахаром вокруг вызовов Enter/Exit обернутых в try-finally

**Mutex** -  как и Monitor, предоставляет монопольный доступ к общему ресурсу только одному потоку. Если поток получает мьютекс, второй поток, который хочет получить этот мьютекс, приостанавливается до тех пор, пока первый поток не выпустит мьютекс. Работает медленнее чем monitor, но дает доступ из внешних процессов, так как реализован на уровне операционной системы.

**Semaphore** - является еще одним инструментом, который предлагает нам платформа .NET для управления синхронизацией. Семафоры позволяют ограничить количество потоков, которые имеют доступ к ресурсам

**monitorObj.Enter()** - указывает на вход в критическую секцию  
**monitorObj.Exit()** - указывает на выход из критической секции

**mutexObj.WaitOne()** - останавливает роток до получение mutex  
**mutexObj.ReleaseMutex()** - высвобождает зарезервированный mutex  

**SemaphoreObj.WaitOne()** - ожидает получения свободного места  
**SemaphoreObj.Release()** - освобождает место в семафоре