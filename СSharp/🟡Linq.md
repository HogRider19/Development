Стандартная библиотека содержит встроенный язык запросов к источнику данных. 
Такой механизм называется `LINQ (Language-Integrated Query)`. Источником данных выступает объект, реализующий интерфейс `IEnumerable`. Но вне зависимости от типа источника позволяется применить ко всем один и тот же подход для выборки данных.

---

Средства LINQ позволяют разработчикам единообразно работать как с коллекциями объектов находящихся в памяти, так и с объектами, хранящимися в базе данных..

Обеспечить такое поведение позволяет интерфейс `IQueryable`, предназначенный для создания провайдеров к внешним источникам данных. Данный интерфейс является наследником `IEnumerable`, но иным образом реализует методы расширения.

Методы расширения `IQueryable` не содержат логики обработки данных. Вместо этого они просто формируют синтаксическую структуру с описанием запроса, добавляя в ее новую информацию о вызовах при каждом новом вызове метода в цепочке.

При вызове же агрегатных методов или при перечислении описание запроса передается на выполнение провайдеру, инкапсулированному внутри конкретной реализации `IQueryable`, а тот уже преобразует запрос в язык источника данных.

---

По умолчанию все элементы коллекции в `LINQ` обрабатываются последовательно, но  был добавлен класс `ParallelEnumerable`, который инкапсулирует функциональность `Parallel` и позволяет выполнять обращения к коллекции в параллельном режиме.

При обработке коллекции `PLINQ` использует возможности всех процессоров в системе. Источник данных разделяется на сегменты, и каждый сегмент обрабатывается в отдельном потоке. Это позволяет произвести запрос на многоядерных машинах.

В то же время по умолчанию `PLINQ` выбирает последовательную обработку данных. Переход к параллельной обработке осуществляется, если это приведет к ускорению. 

Однако, как правило, при параллельных операциях возрастают дополнительные издержки. Поэтому если параллельная обработка потенциально требует больших затрат ресурсов, то `PLINK` в этом случае может выбрать последовательную обработку.

Также следует учитывать, что при доступе к общему разделяемому состоянию в параллельных операциях будет неявно использоваться синхронизация, чтобы избежать взаимоблокировки. Это позволяет безопасно использовать его при общем доступе.

Затраты на синхронизацию ведут к снижению производительности, поэтому желательно избегать применения в параллельных операциях разделяемых ресурсов.

Переход к параллельному выполнению осуществляется через вызов `AsParallel`. Он позволяет распараллелить запрос к источнику данных. Он реализован как метод расширения LINQ у массивов и коллекций. При вызове данного метода источник данных разделяется на части и над каждой частью отдельно производятся операции.

Также существует метод расширения `ForAll`, который принимает ссылку на метод и выполняет этот метод для каждого элемента в его собственно потоке. 

```c#
var result = collection.AsParallel().Select().Where().ForAll(method);
```

---

**==Проекция данных==**. Проекция данных позволяет преобразовать объект одного типа в объект другого типа. Для описании проекции данных используется оператор `select`. 

```c#
var result = source.Select(s => newObject(s));
```

Также определяется метод `SelectMany`, который позволяет свести набор коллекций в одну коллекцию, составленную из исходной коллекции источника.

```c#
var companies = new List<Company> {new Company(...), new Company(...),};
var employees = companies.SelectMany(c => c.Staff);
```

**==Фильтрация==**. Для выбора элементов из некоторого набора по условию используется метод `Where`, принимающий элемент коллекции и возвращающий значение `bool`.

```c#
string[] people = { "Tom", "Alice", "Bob", "Sam", "Tim", "Tomas", "Bill" };
var selectedPeople = people.Where(p => p.Length == 3);
```

**==Сортировка==**. Для сортировки набора данных можно применять метод `OrderBy`, который принимает критерий сортировки. Для обратной сортировки последовательности применяется метод `OrderByDescending`.

В наборах сложных объектов иногда встает ситуация, когда надо отсортировать не по одному, а сразу по нескольким полям. Для этого применяется метод `ThenBy`, который должен идти сразу же после вызова метода расширения сортировки.

```c#
var result = source.OrderBy(s => s.field_1).ThenByDescending(s => s.field_2);
```

**==Объединение==**. Предоставляется несколько методов для работы с коллекциями как с множествами, а именно находить их разность, объединение и пересечение.

Разность двух последовательностей реализуется методом расширения `Except`.
Пересечение двух последовательностей реализуется методом расширения `Intersect`.
Объединение двух последовательностей реализуется методом расширения `Union`.
Удалить дубликаты из последовательности можно используя метод `Distinct`.

```c#
string[] soft = { "Microsoft", "Google", "Apple"};
string[] hard = { "Apple", "IBM", "Samsung"};

var result1 = soft.Except(hard);
var result2 = soft.Intersect(hard);
var result3 = soft.Union(hard);

var uniqueResult = result3.Distinct();
```

**==Агрегация==**. К агрегатным операциям относят различные операции над выборкой, например, получение числа элементов, получение минимального, максимального и среднего значения в выборке, а также суммирование значений выборки.

Метод `Aggregate` выполняет общую агрегацию элементов коллекции в зависимости от указанного выражения. Он принимает выражение, которое принимает два соседних элемента выборки и должно вернуть результат операции дат этими элементами.

Для получения числа элементов в выборке используется метод расширения `Count`.
Для получения суммы значений выборки применяется метод расширения `Sum`.
Для нахождения минимального значения применяется метод расширения `Min`.
Для нахождения максимального значения применяется метод расширения `Max`.
Для нахождения среднего значения применяется метод расширения `Average`.

```c#
int[] numbers = { 1, 2, 3, 4, 5};
int querySum = numbers.Aggregate((x, y) => x + y);
```

**==Срезы==**. Ряд методов расширения позволяют получить часть коллекции, в частности, применяются для этого такие методы как `Skip`, `Take`, `SkipWhile`, `TakeWhile`.

Метод `Skip()` пропускает определенное количество элементов. Количество пропускаемых элементов передается в качестве параметра в метод.

Метод `SkipWhile()` пропускает цепочку элементов, начиная с первого элемента, пока они удовлетворяют определенному условию. Метод принимает это условие.

Метод `Take()` извлекает определенное число элементов. Количество извлекаемых элементов передается в метод в качестве параметра.

Метод `TakeWhile()` выбирает цепочку элементов, начиная с первого элемента, пока они удовлетворяют определенному условию. Метод принимает это условие.

```c#
var result1 = source.Skip(3).Take(2);            // Два элемента начиная с третьего
var result2 = source.SkipWhile(s => s.Item > 5); // Пропускает пока Item > 5
var result2 = source.TakeWhile(s => s.Item > 5); // Извлекает пока Item > 5
```

**==Группировка==**. Для группировки данных по определенным параметрам применяется оператор метод расширения `GroupBy`. Принимает критерий проведения группировки.

Результатом оператора группировки является выборка, которая состоит из групп. Каждая группа представляет объект `IGrouping<K, V>`. Параметр `K` указывает на тип ключа, то есть тип свойства, по которому идет группировка. А `V` представляет тип группируемых объектов. К группе также применимы все методы расширения.

Каждая группа имеет ключ, который мы можем получить через свойство `Key`. Ключ будет представлять одно из уникальных значений группируемого столбца.

После оператора группировки может применятся оператор проекции данных, для того чтобы создать новые объекты представляющие каждую из уникальных групп.

```c#
var groupResult = sorce.GroupBy(s => s.field)
	.Select(g => new { Name = g.Key, Count = g.Count() });
```

**==Соединение==**. Соединение используется для объединения двух разнотипных наборов в один. Для соединения используется оператор метод `Join()`. Как правило, данная операция применяется к двум наборам, которые имеют один общий критерий.

```c#
record class Person(string Name, string Company);
record class Company(string Title, string Language);

var employees = people.Join(companies, // второй набор
    p => p.Company,                    // первый селектор
    c => c.Title,                      // второй  селектор
    (p, c) => new { Name = p.Name, Company = c.Title, Language = c.Language });
```

**==Проверка и получение==**. Ряд методов  позволяют проверить наличие элементов в коллекции и получить их. Они включают `All`, `Any`, `Contains`, `First`, `Last` и так далее.

Метод `All` проверяет, соответствуют ли все элементы условию, возвращая bool.
Метод `Any` проверяет, соответствуют ли хотя бы один элемент переданному условию.
Метод `Contains` возвращает `true`, если коллекция содержит определенный элемент.

Метод `First` возвращает первый элемент последовательности, удовлетворяющий переданному условию, если такого элемента нет, то выбрасывается исключение.

Метод `FirstOrDefault` возвращает первый элемент последовательности, по переданному условию, если элемента нет, то возвращает значение по умолчанию.

Также есть методы `Last` и `LastOrDefault`, которые работают аналогично со своими аналогами, но предоставляют доступ к последним элементам по условию.

---


**Select** - определяет проекцию выбранных значений.
**Distinct** - удаляет дублирующийся элементы из коллекции.
**Where** - определяет фильтр выборки по условию.

**AsParallel** - производит преобразование коллекции до ParallelEnumerable.
**ForAll** - выполняет параллельно метод для всех элементов коллекции.

**OrderBy** - упорядочивает элементы по возрастанию.
**ThenBy** - задает дополнительные критерии для упорядочивания.
**OrderByDescending** - упорядочивает элементы по убыванию.
**ThenByDescending** - дополнительные критерии для упорядочивания.

**Except** - возвращает разность двух коллекцию.
**Intersect** - возвращает пересечение двух коллекций.
**Union** - объединяет две однородные коллекции.
**Zip** - объединяет две коллекции по условию.
**Concat** - объединяет две коллекции.

**Join** - соединяет две коллекции по определенному признаку.
**Aggregate** - применяет ко всем элементам агрегатную функцию. 
**GroupBy** - группирует элементы по ключу.

**Reverse** - располагает элементы в обратном порядке.
**Count** - количество элементов коллекции по условию.
**Sum** - подсчитывает сумму числовых значений в коллекции.
**Average** - подсчитывает cреднее значение в коллекции.

**Min** - находит минимальное значение.
**Max** - находит максимальное значение.
**Take** - выбирает определенное количество элементов.
**Skip** - пропускает определенное количество элементов.

**All** - удовлетворяют ли все элементы условию.
**Any** - удовлетворяют хотя бы один элемент условию.
**Contains** - определяет, содержит ли коллекция определенный элемент.

**First** - выбирает первый элемент коллекции.
**FirstOrDefault** - выбирает первый элемент по умолчанию.
**Single** - выбирает единственный элемент коллекции.
**SingleOrDefault** - выбирает единственный элемент или по умолчанию. 
**Last** - выбирает последний элемент коллекции.
**LastOrDefault** - выбирает последний элемент или по умолчанию.

**ElementAt** - выбирает элемент последовательности по индексу.
**ElementAtOrDefault** - по индексу или или по умолчанию.

[[🟡ExecutionModel]]