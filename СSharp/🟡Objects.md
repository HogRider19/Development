Все классы в системе, даже те, которые мы сами создаем, а также базовые типы, являются неявно производными от класса `Object`. Даже если мы не указываем данный класс в качестве базового, он всегда неявно стоит на вершине иерархии наследования.

Кроме того, переменная типа `object` может ссылаться на любой массив, поскольку в C# массивы реализуются как объекты. Формально имя `object` считается псевдонимом
класса `System.Object`, входящего в библиотеку классов для среды `DotNet`.

Значимые базовые типы также могут быть преобразованы к базовому классу, но такой механизм потребует упаковки. Базовый класс определяет ряд базовых методов. 

**==ToString==**. Возвращает символьную строку, содержащую описание того объекта, для
которого он вызывается. Он автоматически вызывается при выводе объекта в терминал.

**==GetType==**. Этот метод возвращает экземпляр класса, унаследованный от `System.Type`. Этот объект может предоставить большой объем информации о классе, членом которого является ваш объект, включая базовый тип, его методы и свойства для рефлексии.

**==GetHashCode==**. Возвращает идентификатор объекта. Идентификатор можно использовать в любом алгоритме, где хеширование применяется в качестве средства доступа к хранимым объектам. Следует, иметь в виду, что стандартная реализация не пригодна на все случаи.

Что качается `GetHashCode`, стандартная реализация этого метода ведёт себя как генератор уникального идентификатора. Проблема подхода в том, что одинаковые семантически объекты, могут возвращать разные идентификаторы. Также стандартная реализация ещё
и низко производительна. Грамотная реализация этого метода весьма проблематична.

**==Equals==**. По умолчанию определяет, равенство ссылок, то есть эквивалентность объектов. Он может быть также переопределен в создаваемых классах. Это позволяет выяснить, что же означает равенство объектов для создаваемого класса. Например, метод `Equals` можно определить таким образом, чтобы в нем сравнивалось содержимое двух объектов.

Язык предлагает множество способов сравнить объекты, как экземпляры классов, так
и структуры. Способов так много, что без упорядочения этих способов и понимания их грамотного использования и имплементации, их использование становится сложным.

```c#
public static bool operator == (Foo left, Foo right);

public static bool ReferenceEquals(object objA, object objB)
{
    return objA == objB;
}

public static bool Equals(object objA, object objB)
{
    return objA == objB || (objA != null && objB != null && objA.Equals(objB));
}

public virtual bool Equals(object obj)
{
    return RuntimeHelpers.Equals(this, obj);
}
```

Не статическая версия `Equals` по умолчанию ведёт себя точно также как `ReferenceEquals`. Для значимых типов он переопределяется как побитовое сравнение через рефлексию. Данная реализация очень медленная, поэтому при использовании значимых типов, необходимо переопределить этот метод. Для ссылочных типов, без нужды сравнения
двух экземпляров на манер значимых типов, переопределять этот метод необязательно.

Оператор сравнения для значимых типов всегда следует переопределять, как и `Equals`. Для ссылочных типов лучше не переопределять ибо, по умолчанию многие стандартные классы стандартной библиотеки на ссылочных типах ожидают поведение как у `ReferenceEquals`.

Вместе с `Equals` также следует переопределять `GetHashCode`, так как эти два метода логически связаны. Если объекты имеют одинаковые `Hash`, то они должны быть равны через `Equals`, так же верно и обратное. Эту логическую связь не следует нарушать.

---

Любой объект ссылочного типа хранит ряд служебных полей: `8` байт с индексом объекта синхронизации, `8` байт на указатель на таблицу методов, этот указатель на таблицу, также называют указателем на тип. Далее поочередно идут все значения полей текущего объекта.

В `32` разрядных системах, объекты размещаются в динамической памяти по адресам, кратным `4`.  В `64` разрядных системах объекты размещаются в динамической памяти по адресам, кратным `8`. Это означает, что объект как минимум, будет занимать `24` байта.

Поле указателя на таблицу методов ссылается на структуру `CLR` под названием таблица методов, которая в свою очередь ссылается на другую внутреннюю структуру `EEClass`. Вместе, таблица методов и `EEClass`, содержат информацию, необходимую для выбора виртуального метода, метода интерфейса, статической переменной, определения типа объекта во время выполнения, доступа к методам базового класса и других целей.

Таблица методов содержит часто используемую информацию, требуемую для выполнения операций такими механизмами, как механизм выбора виртуального метода, а `EEClass` содержит информацию, используемую реже, например механизмом рефлексии.

Размещение статических полей определяется структурой `EEClass`. Поля простых типов сохраняются в динамически выделенных областях, в памяти загрузчика, а экземпляры пользовательских типов в виде косвенных ссылок на области в динамической памяти.

Чтобы получить доступ к статическому полю, необязательно обращаться к таблице методов или к  `EEClass`. `JIT` компилятор зашивает адреса статических полей в генерируемый код. Массив ссылок на статические поля фиксируется так, что его адрес не может быть изменен сборщиком мусора, кроме того, статические поля простых типов размещаются внутри таблицы методов, которая не затрагивается сборщиком мусора. Это гарантирует, что
для доступа к таким полям можно без опаски использовать жестко зашитые адреса.

В отличие от таблиц указателей на виртуальные функции в `C++`, таблицы методов в `CLR` содержат адреса для всех методов, включая и не виртуальные.  Адреса в таблице методов генерируются на лету. `JIT` компилятор компилирует методы при первом обращении к ним, если они не были скомпилированы инструментом `NGEN`. В момент создания таблицы, она заполняется специальными заглушками, содержащими единственную инструкцию `call`, вызывающую процедуру компиляции соответствующего метода. После компиляции заглушка заменяется инструкцией `jmp` на уже скомпилированный код метода.

Заголовок таблицы методов содержит несколько интересных флагов, позволяющих динамически исследовать ее структуру, в том числе: количество виртуальных методов и количество реализованных интерфейсов. Также таблица содержит указатель на таблицу методов базового класса, указатель на модуль и указатель на структуру `EEClass`. Также содержится список таблиц методов интерфейсов, которые реализует класс таблицы.

Если у экземпляра класса `B`, который является наследником класса `A`, вызвать виртуальный метод, то нужная реализация метода будет найдена, потому что экземпляр класса `B`, в какой форме бы он не был представлен, будет хранить указатель на таблицу методов класса `B`. 

Поле встраиваемое во все экземпляры ссылочных типов это заголовок синхронизации. В отличие от указателя на таблицу методов, это поле используется для самых разных целей, таких как синхронизация, хранение служебной информации сборщика мусора, финализация и хранение хеш кода. Некоторые биты поля определяют, какая информация в нем хранится.

Чтобы обеспечить исключительную блокировку, механизм синхронизации можно связать
с любым объектом. Поскольку инициализация механизма синхронизации для каждого объекта слишком дорого, она выполняется только, когда объект впервые используется
для синхронизации. Когда требуется, `CLR` создаст структуру, которая называется блоком синхронизации, в глобальном массиве, называемом таблицей блоков синхронизации.

Блок синхронизации содержит обратную слабую ссылку на объект, владеющий блоком и также, ссылку на механизм синхронизации, называемый монитором, реализация которого основана на событиях `Win32`. Числовой индекс блока будет сохранен в заголовка объекта. При последующих попытках синхронизации будет использован тот же индекс и монитор.

---

**==Преобразования типов==**. Объекты производного типа  в то же время неявно представляют и базовый тип. Преобразование к базовому типу называется восходящим `Upcasting`. Кроме восходящих преобразований есть нисходящие `Downcasting`, то есть от базового типа к производному. Нисходящее преобразование требует явного указания, так как ведь не каждый экземпляр родительского класса является его дочерним экземпляром.

Во избежание ошибок при нисходящем преобразовании, существует несколько способов. Во-первых, можно использовать ключевое слово `as`. Оно преобразовывает выражение к определенному типу, при этом не выбрасывает исключение. В случае попытки неудачного преобразования выражение будет возвращать в качестве результата  значение `null`.

Второй способ заключается в проверке допустимости преобразования с помощью ключевого слова `is`. Оно проверяет возможность приведения типов. Причем оно позволяет автоматически преобразовать значение, если это возможно.

```c#
Child? chaild = parent as Child;
bool success = parent is Child chaild;
```

---

**==Переопределение методов==**. При наследовании нередко возникает необходимость изменить в наследнике функционал метода, который был унаследован от базового класса. В этом случае наследник может переопределять или скрыть методы базового класса.

Переопределяются только виртуальные методы, то есть с модификатором `virtual`.
При переопределении метод в наследнике, определяется с модификатором `override`. Переопределенный метод в классе наследнике должен иметь тот же набор входных параметров, что и сигнатура виртуального метода определенная в базовом классе.

Средствами языка определяется именно тот вариант виртуального метода, который следует вызывать, исходя из типа объекта, к которому происходит обращение по ссылке, причем
эта операция производится во время выполнения, а не во время компиляции в `IL`. 

При ссылке на разные типы объектов выполняются разные варианты виртуального метода. То есть вариант виртуального метода выбирается по типу объекта, а не по типу ссылки.
Дочерние классы также могут скрывать реализацию методов базового класса, для этого применяется ключевое слово `new`. Реализация родительского остается при преобразовании.

Для запрета наследования от класса применяется `sealed` при его объявлении. Так же это ключевое слово, примененное к виртуальному методу, запрещает его переопределение.

---

**==Инициализаторы==**. Для инициализации объектов можно использовать инициализаторы. Инициализаторы представляют передачу в фигурных скобках значений доступным полям
и свойствам объекта при создании экземпляра класса. Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей, то значения в конструкторе, перепишутся значениями инициализатора.

```c#
ObjectClass obj = new ObjectClass { filed_1 = val_1, filed_2 = val_2 };
```

---

**==Деконструкторы==**. Деконструкторы позволяют выполнить декомпозицию объекта на отдельные части. Для этого в классе должен быть публичный метод `Deconstruct`, который принимает параметры через `out`. Объекты такого класса деконструируются в картеж.

При получении значений из деконструктора нам необходимо предоставить столько переменных, сколько реконструктор возвращает значений.  Вместо возвращаемых 
значений мы можем использовать прочерк `_`, если нам нужны не все параметры.

```c#
(int val_1, int val_1) = new ObjectClass();

class ObjectClass
{
    private int field_1 = 10;
    private int field_1 = 20;
    
    public void Deconstruct(out string val_1, out int val_2)
    {
        val_1 = this.field_1;
        val_2 = this.field_2;
    }
}
```

---

**==Статика==**. Классы и структуры могут иметь статические поля, методы, свойства. Статика относятся ко всему классу и для обращения к ней необязательно создавать экземпляр.
Статические поля хранят состояние всего класса или структуры. Статическое поле определяется как и обычное, только перед типом поля указывается `static`.

На уровне памяти для статических полей будет создаваться участок в памяти, который будет общим для всех объектов класса. При этом память для статических переменных выделяется даже в том случае, если не создано ни одного объекта класса в котором она определена.

Также можно создавать статические методы, которые будут определять поведение одновременно для всех сущностей. Статические методы могут обращаться только к статическим членам класса. Обращение к нестатическим элементам в них запрещено.

Кроме обычных конструкторов у класса также могут быть статические конструкторы. Статические конструкторы имеют следующие отличительные черты: они не имеют модификатор доступа и не принимают параметров; в них нельзя ссылаться на текущий объект класса; cтатические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса.

Статические конструкторы обычно используются для инициализации статических данных, либо же выполняют действия, которые требуется выполнить только один раз в программе.
Также существуют статические локальные функции. Они отличаются от обычных локальных функций тем, что такие функции не могут обращаться к своему лексическому окружению.

---

**==Обобщения==**. Обобщенные типы это конструкции языка программирования, позволяющая писать код, который будет одинаково работать с различными типами данных. При этом данная конструкция позволяет сохранить строгую типизацию языка программирования.

Если объектно-ориентированная парадигма языка подразумевает наличие общего
корня наследования для классов. То обобщение сущности ссылочным типом может быть выполнено без использования обобщенных типов, а реализовываться на преобразовании требуемых объектов к базовому классу, который является корнем наследования типов.

Такой подход может быть реализован и для значимых типов, но потребует упаковки типа 
в базовый класс, с последующим переносом его в управляемую кучу, что приведет к накладным расходам на аллокацию памяти и последующий вызов сборки мусора.

Что касается языка `C#`, при использовании обобщений с ссылочными типами, компилятором будет сгенерирован один общий класс, оперирующий обобщением
как ссылкой. Такой подход похож на реализацию преобразования к корню наследования,
но выполняется не компилятором `MSIL`, а `JIT` компилятором во время выполнения.

Такой подход возможет, потому что каждый ссылочный тип всегда представлен ссылкой фиксированного размера. При этом нет проблем с типобезопасностью, из-за того что
все обращения к ссылочных типам проверены на этапе первичной компиляции `IL`.

Для значимых типов, чтобы избежать накладных расходов, компилятор сгенерирует отдельные классы для каждого обобщения. Такой подход раздувает исполняемые
файлы, использующие обобщения, но позволяет избежать лишних аллокаций.

---

**==Частичные классы==**. Частичные классы представляют собой классы разбитые на несколько определений через ключевое слово `partial`. При компиляции они будут собраны в один класс. Такой механизм применяется для логического разбиения элементов класса.

Также существуют и частичные методы, которые представляют собой методы реализация которых находиться в другом определении частичного класса. К ним применяется ряд ограничений, к примеру они должны возвращать `void` без модификаторов доступа.

---

**==Записи==**. Сущности `records` представляют новый ссылочный тип, который появился в `C#9`. Ключевая особенность `records` состоит в том, что они могут представлять неизменяемый  тип, который  обладает рядом дополнительных возможностей по сравнению с классами.

Стоит отметить, что начиная с версии `C#10` добавлена поддержка структур `record`, соответственно мы можем создавать `record` классы и `record` структуры. Для определения  используется ключевое слово `record`. Если определяется класс `record`, то ключевое слово `class` можно не использовать при определении. Для структур используется `record struct`. 

```c#
public record class Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}

public record struct Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
```



[[СSharp/🟡Base|🟡Base]]