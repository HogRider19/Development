Все классы в .NET, даже те, которые мы сами создаем, а также базовые типы, являются неявно производными от класса Object. Даже если мы не указываем класс Object в качестве базового, он всегда неявно стоит на вершине иерархии наследования.

### Методы System.Object

1. **ToString** - определяет строковое представление объекта.
2. **GetHashCode** - определяет получение хэша объекта.
3. **GetType** - получение типа объекта(не переопределяется).
4. **Equals** - сравнивает объекты(требует GetHashCode).

---
### Отношения между сущностями

- **Наследование** - является базовым принципом ООП и позволяет одному классу наследнику унаследовать функционал другого класса родительского. Нередко отношения наследования еще называют генерализацией или обобщением.
- **Реализация** - предполагает определение интерфейса и его реализация в классах. Например, имеется интерфейс IMovable, который реализуется в классе Car.
- **Ассоциация** - это тип отношения, при котором объекты одного типа неким образом связаны с объектами другого типа. Объекты будут ссылаться друг на друга. При этом они остаются полностью независимыми друг от друга.
- **Агрегация** - это тип отношений когда объект одного типа является частью объекта другого типа. Агрегация образует слабую связь между объектами. Все зависимые классы инициализируются вне основного объекта.
- **Композиция** - это тип отношений при котором один объект может принадлежать только другому объекту и никому другому. При композиции образуется сильная связь между объектами. При таком типе отношений основной объект полностью обеспечивает жизненный цикл объектов от которых он зависит.

---
### Инициализаторы объектов

Для инициализации объектов классов можно применять инициализаторы. Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта.

С помощью инициализатора объектов можно присваивать значения всем доступным полям и свойствам объекта в момент создания. При использовании инициализаторов следует учитывать следующие моменты:

- С помощью инициализатора мы можем установить значения только доступных из вне класса полей и свойств объекта, то есть публичным и их разновидностям. 
- Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей и свойств, то значения, устанавливаемые в конструкторе, перепишутся из инициализатора.

---
### Деконструкторы

Деконструкторы позволяют выполнить декомпозицию объекта на отдельные части. Для деконструирования объекта в нем должен быть объявлен публичный метод Deconstruct, который принимает параметры c ключевым словом out и инициализирует их. Объекты такого класса могут быть деконструированы в картеж.

При получении значений из деконструктора нам необходимо предоставить столько переменных, сколько реконструктор возвращает значений.  Вместо возвращаемых значений мы можем использовать прочерк \_, если нам нужны не все параметры.

---
### Статические сущности

Классы и структуры могут иметь статические поля, методы, свойства. Статические поля, методы, свойства относятся ко всему классу/всей структуре и для обращения к подобным членам необязательно создавать экземпляр класса/структуры.

Статические поля хранят состояние всего класса/структуры. Статическое поле определяется как и обычное, только перед типом поля указывается static.

На уровне памяти для статических полей будет создаваться участок в памяти, который будет общим для всех объектов класса. При этом память для статических переменных выделяется даже в том случае, если не создано ни одного объекта этого класса.

Также можно создавать статические методы, которые будут определять поведение одновременно для всех сущностей. Статические методы могут обращаться только к статическим членам класса. Обращаться к нестатическим методам, полям, свойствам внутри статического метода мы не можем.

Кроме обычных конструкторов у класса также могут быть статические конструкторы. Статические конструкторы имеют следующие отличительные черты:

- Такие конструкторы не имеют модификатор доступа и не принимают параметров
- Как и в статических методах, в статических конструкторах нельзя использовать ключевое слово this для ссылки на текущий объект класса
- Статические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса или при первом обращении к его статическим членам (если таковые имеются)

Статические конструкторы обычно используются для инициализации статических данных, либо же выполняют действия, которые требуется выполнить только один раз.

Также существуют статические локальные функции. Они отличаются от обычных локальных функций тем, что не могут обращаться к своему лексическому окружению.

---
#### Обобщения

**Обобщения** - конструкции языка программирования, позволяющие писать код, который будет одинаково работать с различными типами данных. При этом данная конструкция позволяет сохранить строгую типизацию языка.

Если объектно ориентированная парадигма языка подразумевает наличие общего корня наследования для классов. То обобщение сущности ссылочным типом может быть выполнено без использования обобщенных типов, а реализовываться на преобразовании требуемых объектов к базовому классу.

Такой подход может быть реализован и для значимых типов, но потребует упаковки типа в базовый класс, с последующим переносом его в управляемую кучу, что приведет к накладным расходам на аллокацию памяти и вызов сборки мусора.

При использовании обобщений с ссылочными типами, компилятором будет сгенерирован один общий класс, оперирующий обобщением как ссылкой. Такой подход похож на реализацию преобразования к корню наследования, но выполняется не компилятором языка в MSIL, а JIT компилятором во время выполнения программы.

Такой подход возможет, потому что каждый ссылочный тип всегда представлен ссылкой фиксированного размера. При этом у нас не возникнет проблем с типобезопасностью, так как все обращения к полям и свойствам ссылочных типов проверены еще на этапе компиляции в MSIL.

Для значимых типов, чтобы избежать накладных расходов, компилятор сгенерирует отдельные классы для каждого обобщения. Такой подход раздувает исполняемые файлы, использующие обобщения, но позволяет избежать лишних аллокаций памяти. 

[[🟡ExecutionModel]]