Все классы в системе, даже те, которые мы сами создаем, а также базовые типы, являются неявно производными от класса `Object`. Даже если мы не указываем данный класс в качестве базового, он всегда неявно стоит на вершине иерархии наследования.

Кроме того, переменная типа `object` может ссылаться на любой массив, поскольку в C# массивы реализуются как объекты. Формально имя `object` считается псевдонимом
класса `System.Object`, входящего в библиотеку классов для среды `DotNet`.

Значимые базовые типы также могут быть преобразованы к базовому классу, но такой механизм потребует упаковки. Базовый класс определяет ряд базовых методов. 

**==ToString==**. Возвращает символьную строку, содержащую описание того объекта, для
которого он вызывается. Он автоматически вызывается при выводе объекта в терминал.

**==GetType==**. Этот метод возвращает экземпляр класса, унаследованный от `System.Type`. Этот объект может предоставить большой объем информации о классе, членом которого является ваш объект, включая базовый тип, его методы и свойства для рефлексии.

**==GetHashCode==**. Возвращает идентификатор объекта. Идентификатор можно использовать в любом алгоритме, где хеширование применяется в качестве средства доступа к хранимым объектам. Следует, иметь в виду, что стандартная реализация не пригодна на все случаи.

Что качается `GetHashCode`, стандартная реализация этого метода ведёт себя как генератор уникального идентификатора. Проблема подхода в том, что одинаковые семантически объекты, могут возвращать разные идентификаторы. Также стандартная реализация ещё
и низко производительна. Грамотная реализация этого метода весьма проблематична.

**==Equals==**. По умолчанию определяет, равенство ссылок, то есть эквивалентность объектов. Он может быть также переопределен в создаваемых классах. Это позволяет выяснить, что же означает равенство объектов для создаваемого класса. Например, метод `Equals` можно определить таким образом, чтобы в нем сравнивалось содержимое двух объектов.

Язык предлагает множество способов сравнить объекты, как экземпляры классов, так
и структуры. Способов так много, что без упорядочения этих способов и понимания их грамотного использования и имплементации, их использование становится сложным.

```c#
public static bool operator == (Foo left, Foo right);

public static bool ReferenceEquals(object objA, object objB)
{
    return objA == objB;
}

public static bool Equals(object objA, object objB)
{
    return objA == objB || (objA != null && objB != null && objA.Equals(objB));
}

public virtual bool Equals(object obj)
{
    return RuntimeHelpers.Equals(this, obj);
}
```

Не статическая версия `Equals` по умолчанию ведёт себя точно также как `ReferenceEquals`. Для значимых типов он переопределяется как побитовое сравнение через рефлексию. Данная реализация очень медленная, поэтому при использовании значимых типов, необходимо переопределить этот метод. Для ссылочных типов, без нужды сравнения
двух экземпляров на манер значимых типов, переопределять этот метод необязательно.

Оператор сравнения для значимых типов всегда следует переопределять, как и `Equals`. Для ссылочных типов лучше не переопределять ибо, по умолчанию многие стандартные классы стандартной библиотеки на ссылочных типах ожидают поведение как у `ReferenceEquals`.

Вместе с `Equals` также следует переопределять `GetHashCode`, так как эти два метода логически связаны. Если объекты имеют одинаковые `Hash`, то они должны быть равны через `Equals`, так же верно и обратное. Эту логическую связь не следует нарушать.

---

**==Преобразования типов==**. Объекты производного типа  в то же время неявно представляют и базовый тип. Преобразование к базовому типу называется восходящим `Upcasting`. Кроме восходящих преобразований есть нисходящие `Downcasting`, то есть от базового типа к производному. Нисходящее преобразование требует явного указания, так как ведь не каждый экземпляр родительского класса является его дочерним экземпляром.

Во избежание ошибок при нисходящем преобразовании, существует несколько способов. Во-первых, можно использовать ключевое слово `as`. Оно преобразовывает выражение к определенному типу, при этом не выбрасывает исключение. В случае попытки неудачного преобразования выражение будет возвращать в качестве результата  значение `null`.

Второй способ заключается в проверке допустимости преобразования с помощью ключевого слова `is`. Оно проверяет возможность приведения типов. Причем оно позволяет автоматически преобразовать значение, если это возможно.

```c#
Child? chaild = parent as Child;
bool success = parent is Child chaild;
```

---

**==Переопределение методов==**. При наследовании нередко возникает необходимость изменить в наследнике функционал метода, который был унаследован от базового класса. В этом случае наследник может переопределять или скрыть методы базового класса.

Переопределяются только виртуальные методы, то есть с модификатором `virtual`.
При переопределении метод в наследнике, определяется с модификатором `override`. Переопределенный метод в классе наследнике должен иметь тот же набор входных параметров, что и сигнатура виртуального метода определенная в базовом классе.

Средствами языка определяется именно тот вариант виртуального метода, который следует вызывать, исходя из типа объекта, к которому происходит обращение по ссылке, причем
эта операция производится во время выполнения, а не во время компиляции в `IL`. 

При ссылке на разные типы объектов выполняются разные варианты виртуального метода. То есть вариант виртуального метода выбирается по типу объекта, а не по типу ссылки.
Дочерние классы также могут скрывать реализацию методов базового класса, для этого применяется ключевое слово `new`. Реализация родительского остается при преобразовании.

Для запрета наследования от класса применяется `sealed` при его объявлении. Так же это ключевое слово, примененное к виртуальному методу, запрещает его переопределение.

---

**==Инициализаторы==**. Для инициализации объектов можно использовать инициализаторы. Инициализаторы представляют передачу в фигурных скобках значений доступным полям
и свойствам объекта при создании экземпляра класса. Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей, то значения в конструкторе, перепишутся значениями инициализатора.

```c#
ObjectClass obj = new ObjectClass { filed_1 = val_1, filed_2 = val_2 };
```

---

**==Деконструкторы==**. Деконструкторы позволяют выполнить декомпозицию объекта на отдельные части. Для этого в классе должен быть публичный метод `Deconstruct`, который принимает параметры через `out`. Объекты такого класса деконструируются в картеж.

При получении значений из деконструктора нам необходимо предоставить столько переменных, сколько реконструктор возвращает значений.  Вместо возвращаемых 
значений мы можем использовать прочерк `_`, если нам нужны не все параметры.

```c#
(int val_1, int val_1) = new ObjectClass();

class ObjectClass
{
    private int field_1 = 10;
    private int field_1 = 20;
    
    public void Deconstruct(out string val_1, out int val_2)
    {
        val_1 = this.field_1;
        val_2 = this.field_2;
    }
}
```

---

**==Статика==**. Классы и структуры могут иметь статические поля, методы, свойства. Статика относятся ко всему классу и для обращения к ней необязательно создавать экземпляр.
Статические поля хранят состояние всего класса или структуры. Статическое поле определяется как и обычное, только перед типом поля указывается `static`.

На уровне памяти для статических полей будет создаваться участок в памяти, который будет общим для всех объектов класса. При этом память для статических переменных выделяется даже в том случае, если не создано ни одного объекта класса в котором она определена.

Также можно создавать статические методы, которые будут определять поведение одновременно для всех сущностей. Статические методы могут обращаться только к статическим членам класса. Обращение к нестатическим элементам в них запрещено.

Кроме обычных конструкторов у класса также могут быть статические конструкторы. Статические конструкторы имеют следующие отличительные черты: они не имеют модификатор доступа и не принимают параметров; в них нельзя ссылаться на текущий объект класса; cтатические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса.

Статические конструкторы обычно используются для инициализации статических данных, либо же выполняют действия, которые требуется выполнить только один раз в программе.
Также существуют статические локальные функции. Они отличаются от обычных локальных функций тем, что такие функции не могут обращаться к своему лексическому окружению.

---

**==Обобщения==**. Обобщенные типы это конструкции языка программирования, позволяющая писать код, который будет одинаково работать с различными типами данных. При этом данная конструкция позволяет сохранить строгую типизацию языка программирования.

Если объектно-ориентированная парадигма языка подразумевает наличие общего
корня наследования для классов. То обобщение сущности ссылочным типом может быть выполнено без использования обобщенных типов, а реализовываться на преобразовании требуемых объектов к базовому классу, который является корнем наследования типов.

Такой подход может быть реализован и для значимых типов, но потребует упаковки типа 
в базовый класс, с последующим переносом его в управляемую кучу, что приведет к накладным расходам на аллокацию памяти и последующий вызов сборки мусора.

Что касается языка `C#`, при использовании обобщений с ссылочными типами, компилятором будет сгенерирован один общий класс, оперирующий обобщением
как ссылкой. Такой подход похож на реализацию преобразования к корню наследования,
но выполняется не компилятором `MSIL`, а `JIT` компилятором во время выполнения.

Такой подход возможет, потому что каждый ссылочный тип всегда представлен ссылкой фиксированного размера. При этом нет проблем с типобезопасностью, из-за того что
все обращения к ссылочных типам проверены на этапе первичной компиляции `IL`.

Для значимых типов, чтобы избежать накладных расходов, компилятор сгенерирует отдельные классы для каждого обобщения. Такой подход раздувает исполняемые
файлы, использующие обобщения, но позволяет избежать лишних аллокаций.

---

**==Частичные классы==**. Частичные классы представляют собой классы разбитые на несколько определений через ключевое слово `partial`. При компиляции они будут собраны в один класс. Такой механизм применяется для логического разбиения элементов класса.

Также существуют и частичные методы, которые представляют собой методы реализация которых находиться в другом определении частичного класса. К ним применяется ряд ограничений, к примеру они должны возвращать `void` без модификаторов доступа.

[[СSharp/🟡Base|🟡Base]]