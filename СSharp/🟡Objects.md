Все классы в системе, даже те, которые мы сами создаем, а также базовые типы, являются неявно производными от класса `Object`. Даже если мы не указываем данный класс в качестве базового, он всегда неявно стоит на вершине иерархии наследования.

Кроме того, переменная типа `object` может ссылаться на любой массив, поскольку в C# массивы реализуются как объекты. Формально имя `object` считается псевдонимом класса `System.Object`, входящего в библиотеку классов для среды .NET Framework.

Значимые базовые типы также могут быть преобразованы к базовому классу, но такой механизм потребует упаковки. Базовый класс определяет ряд базовых методов. 

**==ToString==**. Возвращает символьную строку, содержащую описание того объекта, для которого он вызывается. Кроме того, метод автоматически вызывается при выводе содержимого объекта в консоль. Переопределяется во многих классах, что позволяет приспосабливать описание к конкретным типам объектов, его переопределяющих.

**==GetType==**. Этот метод возвращает экземпляр класса, унаследованный от `System.Type`. Этот объект может предоставить большой объем информации о классе, членом которого является ваш объект, включая базовый тип, методы, свойства.

**==GetHashCode==**. Этот метод используется, когда объект помещается в хеш-таблицу. Применяется классами, которые манипулируют этими структурами, чтобы определить, куда именно в таблицу должен быть помещен объект. Если вы намерены использовать свой класс как ключ словаря, то должны переопределить Этот метод.

Хеш-код можно использовать в любом алгоритме, где хеширование применяется в качестве средства доступа к хранимым объектам. Следует, однако, иметь в виду, что стандартная реализация метода `GetHashCode()` не пригодна на все случаи.

**==Equals==**. По умолчанию определяет тождество по ссылкам. Он должен быть также переопределен в создаваемых классах. Это позволяет выяснить, что же означает равенство объектов для создаваемого класса. Например можно определить таким образом, чтобы в нем сравнивалось содержимое двух переданных объектов.

Среда использует довольно сложную схему определения эквивалентности объектов. Следует учитывать и использовать тонкие различия между этими тремя методами и оператором сравнения. Кроме того, также существуют ограничения, определяющие, как следует переопределять виртуальную версию `Equals` с одним параметром.

---

**==Преобразования типов==**. Объекты производного типа  в то же время представляют и базовый тип. Преобразование к базовому типу называется восходящим `Upcasting`. Кроме восходящих преобразований есть нисходящие `Downcasting`, то есть от базового типа к производному. Такой механизм требует явного преобразования, так как ведь не каждый экземпляр родительского класса является его дочерним экземпляром.

Во избежание ошибок при нисходящем преобразовании, существует несколько способов. Во-первых, можно использовать ключевое слово `as`. Оно преобразовывает выражение к определенному типу, при этом не выбрасывает исключение. В случае неудачного преобразования выражение будет содержать значение `null`.

Второй способ заключается в проверке допустимости преобразования с помощью ключевого слова `is`. Оно проверяет возможность приведения типов. Причем оно позволяет автоматически преобразовать значение, если это возможно.

```c#
Child? chaild = parent as Child;
bool success = parent is Child chaild;
```

---

**==Переопределение методов==**. При наследовании нередко возникает необходимость изменить в наследнике функционал метода, который был унаследован от базового класса. В этом случае наследник может переопределять или скрыть методы базового.

Переопределяются только виртуальные методы, то есть с модификатором `virtual`. При переопределении метод в наследнике, определяется с модификатором `override`. Переопределенный метод в классе-наследнике должен иметь тот же набор входных параметров, что и сигнатура виртуального метода в базовом классе.

Средствами языка определяется именно тот вариант виртуального метода, который следует вызывать, исходя из типа объекта, к которому происходит обращение по ссылке, причем это делается во время выполнения, а не во время компиляции. 

Поэтому при ссылке на разные типы объектов выполняются разные варианты виртуального метода. Иными словами, вариант выполняемого виртуального метода выбирается по типу объекта, а не по типу ссылки на этот объект в памяти.

Дочерние классы также могут скрывать реализацию методов базового класса, для этого применяется ключевое слово `new`. Реализация родительского остается при касте.

Для запрета наследования от класса применяется `sealed` при его объявлении. Так же это ключевое слово, примененное к обычному методу, запрещает его сокрытие. Еще с помощью команд `override sealed`, можно запретить дальнейшее переопределение.

---

**==Инициализаторы==**. Для инициализации объектов классов можно использовать инициализаторы. Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта при определении экземпляра.

С помощью инициализатора объектов можно присваивать значения доступным полям и свойствам объекта в момент создания. Для этого используются фигурные скобки.

С помощью инициализатора мы можем установить значения только доступных из вне класса полей и свойств объекта, то есть публичным и их различным разновидностям. 

Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей и свойств, то значения, устанавливаемые в конструкторе, перепишутся из инициализатора.

```c#
ObjectClass obj = new ObjectClass { filed_1 = val_1, filed_2 = val_2 };
```

---

**==Деконструкторы==**. Деконструкторы позволяют выполнить декомпозицию объекта на отдельные части. Для деконструирования объекта в нем должен быть публичный метод `Deconstruct`, который принимает параметры c ключевым словом `out` и инициализирует их. Объекты такого класса могут быть деконструированы в картеж.

При получении значений из деконструктора нам необходимо предоставить столько переменных, сколько реконструктор возвращает значений.  Вместо возвращаемых значений мы можем использовать прочерк `_`, если нам нужны не все параметры.

```c#
(int val_1, int val_1) = new ObjectClass();

class ObjectClass
{
    private int field_1 = 10;
    private int field_1 = 20;
    
    public void Deconstruct(out string val_1, out int val_2)
    {
        val_1 = this.field_1;
        val_2 = this.field_2;
    }
}
```

---

**==Статические сущности==**. Классы и структуры могут иметь статические поля, методы, свойства. Статические поля, методы, свойства относятся ко всему классу и для обращения к подобным членам необязательно создавать экземпляр.

Статические поля хранят состояние всего класса или структуры. Статическое поле определяется как и обычное, только перед типом поля указывается `static`.

На уровне памяти для статических полей будет создаваться участок в памяти, который будет общим для всех объектов класса. При этом память для статических переменных выделяется даже в том случае, если не создано ни одного объекта этого класса.

Также можно создавать статические методы, которые будут определять поведение одновременно для всех сущностей. Статические методы могут обращаться только к статическим членам класса. Обращение к нестатическим элементам в них запрещено.

Кроме обычных конструкторов у класса также могут быть статические конструкторы. Статические конструкторы имеют следующие отличительные черты: они не имеют модификатор доступа и не принимают параметров; в них нельзя ссылаться на текущий объект класса; cтатические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса.

Статические конструкторы обычно используются для инициализации статических данных, либо же выполняют действия, которые требуется выполнить только один раз.

Также существуют статические локальные функции. Они отличаются от обычных локальных функций тем, что не могут обращаться к своему лексическому окружению.

---

**==Обобщения==**. Обобщенные типы это конструкции языка программирования, позволяющая писать код, который будет одинаково работать с различными типами данных. При этом данная конструкция позволяет сохранить строгую типизацию языка.

Если объектно ориентированная парадигма языка подразумевает наличие общего корня наследования для классов. То обобщение сущности ссылочным типом может быть выполнено без использования обобщенных типов, а реализовываться на преобразовании требуемых объектов к базовому классу наследования.

Такой подход может быть реализован и для значимых типов, но потребует упаковки типа в базовый класс, с последующим переносом его в управляемую кучу, что приведет к накладным расходам на аллокацию памяти и вызов сборки мусора.

При использовании обобщений с ссылочными типами, компилятором будет сгенерирован один общий класс, оперирующий обобщением как ссылкой. Такой подход похож на реализацию преобразования к корню наследования, но выполняется не компилятором языка в MSIL, а JIT компилятором во время выполнения программы.

Такой подход возможет, потому что каждый ссылочный тип всегда представлен ссылкой фиксированного размера. При этом нет проблем с типобезопасностью, из-за того что все обращения к ссылочных типам проверены на этапе компиляции в MSIL.

Для значимых типов, чтобы избежать накладных расходов, компилятор сгенерирует отдельные классы для каждого обобщения. Такой подход раздувает исполняемые файлы, использующие обобщения, но позволяет избежать лишних аллокаций памяти.

---

**==Частичные классы==**. Частичные классы представляют собой классы разбитые на несколько определений `partial`. При компиляции они будут собраны в один класс.
Такой механизм применяется для логического разбиения элементов класса.

Также существуют и частичные методы, которые представляют собой методы реализация которых находиться в другом частичном классе. К ним применяется ряд ограничений, к примеру они должны возвращать void без модификаторов доступа.

[[🟡ExecutionModel]]