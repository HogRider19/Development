Сборка мусора представляет собой высокоуровневую абстракцию, избавляющую разработчиков от необходимости заботиться об освобождении управляемой памяти. В окружениях, снабженных механизмом сборки мусора, выделение памяти производится в момент создания объектов, а освобождение происходит, когда в программе исчезает последняя ссылка на объект. Кроме того, сборщик мусора предоставляет интерфейс финализации для неуправляемых ресурсов за пределами управляемой памяти.

**==Управление свободным списком==**. Представляет механизм управления распределением памяти в стандартной библиотеке языка `C`, который также по умолчанию используется функциями управления памятью в `C++`, то есть `new` и `delete`. Это детерминированный диспетчер памяти, при использовании которого вся ответственность за выделение и освобождение памяти ложится на плечи разработчика. Свободные блоки памяти
хранятся в виде связанного списка, откуда изымаются и возвращаются.

![[{3916BD0C-1D70-4515-9679-C9577CA5CFC4}.png]]

Он изымает блоки из списка при выделении памяти и возвращает их обратно при освобождении. Приложение обычно получает блоки памяти, хранящие их размеры в служебной области. Механизм управления памятью на основе списка не свободен от тактических и стратегических решений, влияющих на производительность приложения.

Поиск блока, соответствующего параметрам запроса, требует времени. Кроме того, блоки часто разбиваются на несколько частей. В многопроцессорных системах неизбежно возникает конкуренция за список и необходимость синхронизации операций, если только в приложении используется несколько списков. Возврат блока в список требует времени, и здесь снова возникает проблема синхронизации операций освобождения памяти.

**==Подсчет ссылок==**. Сборщик мусора, опирающийся на подсчет ссылок, связывает каждый объект с целочисленной переменной счетчиком ссылок. Когда приложение создает новую ссылку на объект, его счетчик ссылок увеличивается. Когда приложение удаляет ссылку на существующий объект, его счетчик ссылок уменьшается. Когда счетчик ссылок
достигает значения 0, объект можно уничтожить и освободить его память.

![[{76975A56-E1D0-4882-B1BB-368FC78BB4CC}.png]]

Когда создается или уничтожается ссылка на объект, необходимо обновлять счетчик ссылок. Это означает, что к стоимости обновления прибавляются накладные расходы.

Счетчик ссылок на объект должен храниться в памяти объекта. Это увеличивает объем памяти объекта, что делает механизм нецелесообразным для легковесных объектов.

При управлении памятью на основе подсчета ссылок возникает проблема утилизации объектов с циклическими ссылками. Если приложение больше не ссылается на пару объектов, но каждый из них хранит ссылки на друг друга, возникает утечка памяти.

**==На основе трассировки==**. Сборка мусора на основе трассировки применяется для управления динамической памятью в `NetCLR`, `JavaVM` и в других управляемых окружениях. В этих окружениях сборщик мусора никак не используем механизм подсчета ссылок.

Разработчику не требуется явно освобождать память, об этом позаботится сборщик мусора. При использовании сборки мусора на основе трассировки обычно освобождение памяти не будет выполняется, пока уровень ее использования не достигнет определенного порога.

Когда запускается цикл сборки мусора, он начинается с фазы маркировки, в ходе которой выявляются все объекты, на которые существуют ссылки в приложении. После определения множества живых объектов, сборщик приступает к выполнению фазы чистки, в ходе которой он освобождает память, занимаемую неиспользуемыми объектами. Затем может запуститься фаза дефрагментации, в которой сборщик перемещает объекты в общий плотный кластер.

Стоимость выделения памяти сопоставима с выделением кадра на стеке, потому что отсутствует необходимость предусматривать сохранение какой-либо информации, для освобождении объекта. Выделение памяти заключается в наращивании указателя.

Сборка мусора выполняется циклически, а не распределяется примерно равномерно по всему времени выполнения приложения. Это имеет свои как преимущества так и недостатки.

Поиск объектов по ссылкам требует значительных затрат от среды выполнения. Ссылки на объекты могут храниться в статических переменных, локальных переменных потоков и так далее. Трассировка всех возможных ссылок на каждый доступный объект далеко не тривиальная задача, и часто сопряжена с затратами на итерации через коллекции.

Перемещение объектов в памяти требует времени, что может оказаться невозможным
для очень больших объектов. С другой стороны, устранение пустых пространств между объектами способствует локальности ссылок, потому что объекты, создававшиеся одновременно, наверняка окажутся в памяти рядом по соседству.

---

На этапе маркировки, сборщик мусора выполняет обход графа всех объектов, на которые ссылается приложение. Для успешного обхода графа и предотвращения ошибок первого и второго рода, сборщику мусора необходимо множество опорных точек, откуда можно будет начать обход ссылок. Эти отправные точки называют корнями дерева графа ссылок. 

После определения множества корней, остальные операции, выполняемые сборщиком мусора на этапе маркировки, просты и понятны. Он просматривает каждое внутреннее ссылочное поле в каждом корне и выполняет обход, пока не посетит все объекты.
Поскольку допускается создавать циклические ссылки, сборщик мусора маркирует посещенные им объекты, чтобы впредь не задерживаться на их обработке.

Наиболее типичными представителями корней являются локальные переменные, единственная локальная переменная может быть корнем целого графа объектов.
Всякая локальная переменная, которая потенциально может хранить ссылку на
объект, считается активным корнем, пока кадр стека метода не будет разрушен.

Сборщик мусора понятия не имеет, когда локальная переменная выходит из употребления в пределах метода. Эта информация записывается в специальные таблицы `JIT` компилятором в процессе компиляции метода. Для каждой локальной переменной компилятор записывает в таблицу адрес самой первой и самой последней инструкции, где локальная переменная остается активным корнем. Таблица используется сборщиком в процессе обхода ссылок. 

Локальные переменные могут храниться не только на стеке, но и в регистрах
процессора, и таблицы `JIT` компилятора должны знать об этой особенности.

Из этого следует, что объект с ссылкой в локальной переменной, может быть удален, до выхода из фрейма стека. Это поведение может быть не желательным, например при создании таймера. Чтобы этого избежать можно было бы использовать статическую переменную или метод `GC.KeepAlive()`, гарантирующий сохранность ссылки.

```c#
static void Main(string[] args)
{
	Timer timer = new Timer(OnTimer, null, 0, 1000);
	Console.ReadLine();
	GC.KeepAlive(timer);
}

static void OnTimer(object state)
{
	Console.WriteLine(DateTime.Now.TimeOfDay);
	GC.Collect();
}
```

Метод `GC.KeepAlive` устроен очень просто, по факту это просто пустой метод с
запретом на оптимизацию встраиванием, служить лишь для сохранения ссылки.

Еще одной разновидностью корней являются статические переменные. Статические члены типов создаются в момент их загрузки и считаются активными корнями на протяжении всего времени выполнения приложения. Статические переменные самые частые причины утечек.

Две категории корней, описанные выше, являются наиболее распространенными, однако существуют и другие категории. Например, дескрипторы сборщика `GCHandle`. Очередь объектов, готовых к завершению, объекты ожидающие финализации. Знание различных категорий корней может пригодиться при отладке утечек памяти в приложениях.

Фаза маркировки в цикле сборки мусора является фазой преимущественно для чтения, в процессе выполнения которой не производится перемещение объектов в памяти или их удаление. Тем не менее, эта фаза оказывает существенное влияние скорость работы.

В процессе маркировки сборщик мусора должен посетить каждую ссылку на объект. Это может приводить к ошибкам чтения страниц памяти, если они вытеснены в файл подкачки.

Обработка неиспользуемых объектов оказывается менее дорогостоящей на этом этапе, поэтому производительность фазы маркировки пропорциональна коэффициенту эффективности сборки: отношению используемых и неиспользуемых объектов.

Производительность фазы маркировки зависит также от количества объектов в графе, но не зависит от объема памяти, занимаемой объектами. А это означает, что производительность фазы прямо пропорциональная количеству живых объектов, управляемых компилятором.

---

В фазах чистки и сжатия сборщик мусора освобождает память, перемещая живые объекты так, чтобы они располагались в памяти последовательно, друг за другом в кластере.

Выделение памяти выполняется простым наращиванием указателя, который всегда ссылается на следующий свободный блок памяти. Он называется `newObjectPointer` 
и инициализируется при передаче динамической памяти при запуске приложения.

![[{E242D612-55EF-433B-B5C0-F115862646F0}.png]]

Выделение памяти в этой модели выполняется чрезвычайно быстро: достаточно просто выполнить единственную атомарную операцию увеличения указателя. Но в конкурентных системах будут возникать конкуренция за право доступа к указателю `newObjectPointer`.

Если бы память была неисчерпаемым ресурсом, запросы на выделение памяти можно было бы удовлетворять до бесконечности, просто увеличивая указатель на следующий объект. Однако  в некоторый момент времени будет достигнут определенный порог, за которым последует принудительный запуск процедуры сборки мусора. Все пороговые значения являются динамическими и доступны для настройки через чреду выполнения `CLR`.

В фазе сжатия сборщик мусора перемещает живые объекты в памяти, размещая 
их рядом друг с другом. Это способствует локальности ссылок, потому что объекты, создававшиеся одновременно, наверняка окажутся в памяти по соседству. С другой 
стороны, перемещение объектов влечет за собой две проблемы производительности.

Перемещение объектов означает необходимость копирования блоков памяти, что для крупных объектов не эффективно. Поэтому большие объекты обслуживаются иначе.

При перемещении объектов необходимо обновлять ссылки на них соответственно их новому местоположению. Для широко используемых объектов, обновление большого количества ссылок может оказаться медленной и очень дорогостоящей операцией.

Вопреки распространенному мнению, сборщик мусора не всегда перемещает объекты, даже если они не закреплены и между ними есть свободное пространство. Сборщик мусора определенным образом оценивает ситуацию и выбирает один из вариантов.

![[{2E71FB78-4BE7-4A29-A64E-99E4B26C4390}.png]]

Дефрагментация объектов может быть проблемой, если мы хотим передать ссылку на управляемый объект не управляемому коду. В таком случае мы могли бы на это время отключать сборщик, но это влечет гигантские накладные расходы. Вместо этого мы может воспользоваться специальной операцией закрепления объекта в памяти среды выполнения.

Сама операция закрепления стоит не очень дорого. Существует несколько механизмов, выполняющих ее очень быстро. Наиболее явным способом закрепления объекта является создание дескриптора сборщика мусора с флагом `GCHandleType.Pinned`. В результате создается новый корень в таблице дескрипторов, сообщающий сборщику мусора, что объект должен оставаться прикрепленным к определенному адресу в памяти. 

В число альтернатив входят магическая приправа, добавляемая маршалером `P/Invoke`, и механизм закрепленных указателей, предоставляемый языком в виде ключевого слова `fixed`, который опирается на специальную маркировку локальных переменных.

---

Среда выполнения поддерживает несколько разновидностей сборщиков мусора, даже при том, что внешне она выглядит как огромный монолит кода с ограниченными настройками. Эти разновидности предназначены для использования в разных ситуациях: в клиентских приложениях, в высокопроизводительных серверных приложениях, и так далее. Чтобы разобраться в отличительных чертах этих разновидностей, необходимо посмотреть, как сборщик мусора взаимодействует с прикладными потоками выполнения системы.

**==Режим рабочей станции==**. Режим сборки мусора по умолчанию и единственный режим, доступный на однопроцессорных компьютерах. Он используется в консольных приложениях и десктопах. Он выполняет полную сборку мусора асинхронно с работающей программой, тем самым сводя к минимуму задержки. Этот режим полезен для клиентских приложений, где воспринимаемая производительность важнее, чем реальная пропускная способность.

**==Режим сервера==**. Сборка мусора доступна только на многопроцессорных компьютерах. Она создает отдельную управляемую кучу и поток для каждого процессора и выполняет сборку параллельно. Во время сборки все управляемые потоки приложения приостанавливаются. Таким образом, режим серверной сборки мусора обеспечивает максимальную пропускную способность и повышает производительность по мере увеличения количества процессоров. Производительность особенно высока на компьютерах с четырьмя и более процессорами.

---

Модель поколений объектов позволяет оптимизировать производительность за счет выполнения частичной сборки мусора. Частичная сборка мусора характеризуется высоким коэффициентом эффективности, и сборщик мусора выполняет обход объектов, которые вероятнее всего придется утилизировать. Основным решающим фактором в определении вероятности, что объект потребуется утилизировать, является его возраст - согласно данной модели, между возрастом и продолжительностью жизни существует прямая зависимость.

Определение возраста зависит от частоты сборки мусора в приложении. В приложении, где сборка мусора выполняется раз в минуту, объект, созданный 5 секунд назад, будет считаться юным. А в приложении, интенсивно работающим с памятью, где сборка мусора выполняется десятки раз в секунду, объект точно такого же возраста как и первый будет считаться старым.

Эти предположения верны не для всех приложений. Легко можно представить приложение, в котором временные объекты составляют большинство и переживают несколько циклов сборки мусора. Это явление, когда продолжительность жизни объекта не соответствует предсказаниям модели поколений, неформально называют кризисом среднего возраста. Объекты, с таким поведением, сводят на нет все преимущества модели поколений.

Согласно модели поколений, динамическая память, обслуживаемая сборщиком мусора, делится на три области: поколение 0, поколение 1 и поколение 2. Эти области соответствуют ожидаемой продолжительности жизни объектов, находящихся в данных поколения.

Область `LargeObjectHeap` это специальная область, зарезервированная для размещения очень больших объектов. Большими считаются объекты, занимающие больше `85 Кбайт` памяти. Это пороговое значение относится к одному объекту, а не к графу объектов.

---

При запуске `CLR` запрашивает процессу два блока в виртуальной памяти, такие блоки называются сегментами. Первый сегмент используется для поколений 0, 1 и 2, этот сегмент сборщика имеет название эфемерный. Второй сегмент для кучи больших объектов.

Размеры сегментов зависят от разновидности сборщика мусора и от начальных настроек. В среднем это значение представлено размером от десятков мегабайт, до нескольких гигабайт. Среда выполнения `CLR` не передает сразу весь сегмент, она только резервирует адресное пространство и передает сегменты по частям, по мере их необходимости приложению.

Когда сегмент заполняется и от приложения поступает дополнительный запрос на выделение памяти, `CLR` выделяет еще один сегмент для процесса приложения.

Когда в результате сборки мусора сегмент пустеет, `CLR` обычно освобождает память и возвращает ее операционной системе. Это предпочтительное поведение для большинства приложений, особенно для приложений, нечасто запрашивающих большие объемы памяти.

Однако, можно потребовать от `CLR` оставить пустой сегмент в резервном списке, не возвращая его операционной системе. Такое поведение называют удержанием сегмента, или удержанием виртуальной памяти, и может быть определено при запуске приложения.

Удержание сегмента может способствовать повышению производительности
приложений, очень часто выделяющему и освобождающему сегменты, и снижению вероятности появления исключений нехватки памяти из-за фрагментации виртуальной памяти. Такое поведение используется по умолчанию в приложениях `ASP.NET`. 

Модель сегментов управляемого пространства памяти вводит весьма серьезную проблему, связанную с фрагментацией виртуальной памяти. Поскольку после опустошения сегменты возвращаются операционной системе, неуправляемый код может выделить для себя
память в середине области, которая когда-то была сегментом сборщика мусора.

Долгоживущие процессы, такие как веб-серверы, интенсивно работающие с памятью с частыми пиковыми нагрузками, обычно проявляют эту проблему через несколько часов, дней или недель выполнения. В не особенно критичных случаях, когда отказы допустимы,
эта проблема решается перезапуском процесса в котором запущено приложения.

---

Когда создается объект с деструктором, ссылка на него добавляется в специальную очередь, называемую очередью финализации. Эта очередь воспринимается сборщиком мусора как корень, в том смысле, что даже если в приложении не останется ни одной ссылки
на объект, он все равно будет удерживаться в памяти очередью финализации.

Когда объект становится ненужным в приложении, сборщик мусора обнаружит, что на объект указывает только одна ссылка из очереди финализации и переместит ссылку на объект в другую очередь, называемую очередью объектов, готовых к завершению. 
Она также является корнем, поэтому объект будет удерживаться в памяти.

Во время сборки мусора финализация объектов не выполняется. Эту процедуру выполняет специальный поток, называемый потоком финализации и создаваемый при инициализации среды выполнения. Этот поток ожидает появления события финализации. Это событие посылается сборщиком мусора, если хотя бы один объект был перемещен им в очередь объектов, готовых к завершению. Поток финализации удаляет ссылку из очереди и одновременно выполняет фииализатор объекта. В следующем цикле сборки мусора сборщик обнаружит отсутствие ссылок на объект и освободит занимаемую им память.

Почему финализатор объекта нельзя вызвать в сборщике мусора, а обязательно нужно отложить для выполнения в другом потоке? Это сделано для того чтобы не блокировать поток сборки мусора для выполнения пользовательских финализаторов, которые могут выполняться достаточно долго. Кроме того, обработка исключений, возникающих в процессе сборки мусора, реализуется очень сложно, а реализовать обработку операций выделения памяти, которые могут выполняться финализаторами во время сборки мусора, еще сложнее. Поэтому, из соображений надежности, сборщик мусора не выполняет финализацию объектов, а делегирует ее специальному зарезервированному потоку.

Объекты с финализаторами точно достигнут поколения 1, что увеличивает вероятность проявления эффекта кризиса среднего возраста, если их создается слишком много.

Создание объектов с финализаторами стоит несколько дороже, потому что дополнительно они добавляются в очередь финализации. При этом возникает необходимость пользоваться механизмами синхронизации на случай выполнения в многопроцессорной среде.

Большая нагрузка на поток финализации при большом количестве объектов, требующих финализации может вызывать утечки памяти. Если приложение создает объекты с более высокой скоростью, чем поток финализации способен финализировать их, приложение будет постоянно терять память, занятую объектами, которые ожидают финализации.

Даже при том, что процедура финализации считается пуленепробиваемой, гарантирующей освобождение ресурсов, среда выполнения `CLR` не гарантирует вызов финализатора.

Например, финализация не выполняется, когда работа процесса грубо прерывается через `TerminateProcess`. Также финализатор не вызовутся, если у процесса закончилась память,
а `JIT` компилятор еще не успел скомпилировать финализатор. Поэтому нельзя слепо доверять, что финализаторы освободят ресурсы, пересекающие границы процессов.

---

Cлабые ссылки представляют вспомогательный механизм обслуживания ссылок на объекты. Типичная ссылка на объект является очень детерминированной: пока имеется ссылка на объект, он будет продолжать существовать. И это правильно с точки сборщика мусора.

Однако иногда бывает желательно сохранить ссылку, связанную с объектом, не мешая при этом сборщику мусора удалить объект из памяти. Когда сборщик мусора удалит объект, ссылка окажется не связанной ни с каким объектом. Если сборщик еще не удалил объект,  мы сможем восстановить сильную ссылку на объект и использовать его для своих целей.

Это может пригодиться в ситуациях использования внешних объектов, таких как таймеры и события. Также при создании систем кеширования. Еще можно использовать для удержания больших объектов в надежде, что они не будут утилизированы. Приложение может хранить слабую ссылку на большой объект. Если объект окажется уничтожен сборщиком мусора, приложение сможет повторно создать его; в противном случае использовать повторно.

Механизм слабых ссылок доступен приложению в виде класса `System.WeakReference`, являющегося особым случаем типа `System.Runtime.InteropServices.GCHandle`. Слабая ссылка имеет логическое свойство `IsAlive`, сообщающее о существовании объекта ссылки, и свойство `Target`, которое можно использовать для получения ссылки на целевой объект.