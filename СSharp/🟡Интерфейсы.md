**Интерфейс** - сущность которая представляет некое описание типа, набор компонентов, который должен иметь тип данных. Мы не можем создавать объекты интерфейса напрямую с помощью конструктора, как например, в классах

---

**IClonable** - интерфейс копирования объекта  
**IComparable** - интерфейс для реализации сравнения
**IEquatable** - интерфейс для реализации проверки на равенство объектов
**IEnumerable** - интерфейс позволяющий итерироваться по объекту
**IQueryable** - интерфейс реализующий отложенный вызов коллекции
**IFormattable** - интерфейс позволяющий изменять строковое представление объекта
**IConvertible** - интерфейс для преобразования типа объекта
**ICloneable** - интерфейс для копирования объекта

---

### Ковариантность и Контравариантность

Понятия ковариантности и контравариантности связаны с возможностью использовать в приложении вместо некоторого типа другой тип, который находится ниже или выше в иерархии наследования.

**Ковариантность(out)** - использование более конкретного типа
**Контравариантность(in)** - использование более универсального типа
**Инвариантность** - использование только изначально заданного типа

DotNet позволяет создавать ковариантные и контравариантные обобщенные интерфейсы. Эта функциональность повышает гибкость при использовании обобщенных интерфейсов в программе. По умолчанию все обобщенные интерфейсы являются инвариантными.

Обобщенные интерфейсы могут быть ковариантными, если к универсальному параметру применяется ключевое слово out. Такой параметр должен представлять тип объекта, который возвращается из метода.

При создании ковариантного интерфейса надо учитывать, что универсальный параметр может использоваться только в качестве типа значения, возвращаемого методами интерфейса. Но не может использоваться в качестве типа аргументов метода или ограничения методов интерфейса.

Для создания контравариантного интерфейса надо использовать ключевое слово in. При создании контрвариантного интерфейса надо учитывать, что универсальный параметр контрвариантного типа может применяться только к аргументам метода, но не может применяться к возвращаемому результату метода.

---

Начиная с версии C# 8.0 интерфейсы поддерживают реализацию методов и свойств по умолчанию. Если класс не реализует метод, будет применяться реализация по умолчанию.

Классы и структуры могут реализовать сразу несколько интерфейсов. Все реализуемые интерфейсы указываются через запятую

Существует также явная реализация интерфейса. При явной реализации указывается название метода или свойства вместе с названием интерфейса, при этом этим методы являются закрытыми. При явной реализации интерфейса его методы и свойства не являются частью интерфейса класса.

Если модификатор доступа не public, а какой-то другой, то для реализации метода, свойства или события интерфейса в классах и структурах также необходимо использовать явную реализацию интерфейса

Также можно и не реализовать методы, сделав их абстрактными в классе который реализует интерфейс, переложив право их реализации на производные классы

В случае когда базовый класс реализовал интерфейс, но в классе-наследнике необходимо изменить его реализацию. Тогда мы можем использовать либо переопределение, либо скрытие метода или свойства интерфейса, а также повторная реализация интерфейса в классе-наследнике

Интерфейсы, как и классы, могут наследоваться. При этом дочерний интерфейс не обязан реализовывать родительский. Однако в отличие от классов мы не можем применять к интерфейсам sealed и abstract.

Методы дочерних интерфейсов могут использовать ключевое слово new для скрытия методов из базового интерфейса