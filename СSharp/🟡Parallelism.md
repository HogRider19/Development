Система определяет `TPL(Task Parallel Library)`, которая представляет собой библиотеку, которая обеспечивает высокий уровень абстракции для параллельного и конкурентного программирования с использованием `Task` и других конструкций.

Данная библиотека упрощает работу с многоядерными системами. Кроме того, она упрощает работу по созданию новых потоков. Поэтому рекомендуется использовать именно `TPL` и ее классы для создания многопоточных приложений, хотя стандартный подход с использованием `Thread` по-прежнему находят широкое применение.

---

Библиотека `TPL` содержит статический класс `Parallel`. Который предназначен для упрощенного параллельного выполнения методов и параллельных итераций.

**==Invoke==**. Принимает набор методов и пытается выполнить их параллельно. При это блокирует вызывающий поток до выполнения каждой из переданных операций. Не имеет прямого способа вернуть результат. Возврат реализуется через замыкание.

```c#
Parallel.Invoke(action1, ..., actionN);
```

**==For==**. Позволяет выполнить параллельно набор методов, передавая в каждый соответствующий индекс. Также принимает начальный и конечный индексы.

```c#
ParallelLoopResult result = Parallel.For(startIndedx, endIndedx, (index) => {});
```

**==ForEach==**. Осуществляет итерацию по коллекции, реализующей интерфейс `IEnumerable`, подобно циклу `foreach`, только осуществляет параллельное выполнение перебора.

```c#
ParallelLoopResult result = Parallel.ForEach<int>(colection, (item) => res));
```

Методы `Parallel.ForEach` и `Parallel.For` возвращают объект `ParallelLoopResult`. Содержит свойство `IsCompleted`, указывающее завершен ли полностью цикл и свойство `LowestBreakIteration`, содержащее индекс остановленной итерации.

Также в делегаты Action методов `For` и `ForEach` может передаваться дополнительный параметр `ParallelLoopState`, который позволяет управлять поведением цикла. Через метод `Break` можно итерации после завершения текущей. Или сразу через `Stop`.

```c#
ParallelLoopResult result = Parallel.For(1, 10, Method);
if (!result.IsCompleted) Console.WriteLine($"{result.LowestBreakIteration}");
 
void Method(int n, ParallelLoopState pls)
{
    pls.Break();
    pls.Stop();
}
```

---

Основной функционал библиотеки `TPL` содержится в классе `Task`. Данный класс описывает отдельную задачу, которая запускается асинхронно в одном из потоков из пула потоков. Хотя ее также можно запускать синхронно в текущем потоке.

Экземпляр запущенной задачи можно создать, используя конструктор `Task(action)`, после чего запустить ее методом `Start`. Также можно воспользоваться статическим методом `Run(action)` или же создать ее фабрикой `Task.Factory.StartNew(action)`. 

```c#
Task task1 = new Task(action); task1.Start();
Task task2 = Task.Factory.StartNew(action);
Task task3 = Task.Run(action);
```

При создании экземпляра задачи через фабрику задач `Task.Factory` или через конструктор задачи, можно передать вторым параметром элемент перечисления `TaskCreationOptions` для ее настройки. Данное перечисление определяет:

**==AttachedToParent==**. Указывает, что задача должна быть присоединена к родительской задаче. По умолчанию дочерняя задача выполняется независимо от родительской. Это означает, что по умолчанию дочерняя задача может завершится раньше родительской.

**==DenyChildAttach==**. Указывает, что любая дочерняя задача, должна быть выполнена как часть текущей, то есть как будто все дочерние задачи созданы с `AttachedToParent`.

**==LongRunning==**. Указывает планировщику задач, что создаваемая задача является долгоисполняемой, чтобы планировщик учел это при настройке пула потоков.

**==PreferFairness==**. Рекомендация для планировщика планировать задач максимально прямым способом, то есть задачи, запланированные ранее, будут выполняться ранее.

С помощью методов класса Task, можно проверить статус завершения задачи: `IsCompleted`, `IsCanceled`, `IsFaulted` и также `IsCompletedSuccessfully`. Также через свойство `Status` можно получить статус выполнения задачи, если задача завершилась с выбрасыванием исключения, то получить это исключение через свойство `Exception`.

Задачи могут не только выполняться как процедуры, но и возвращать определенные результаты. Для этого необходимо типизировать объект `Task` тем типом, объект которого мы хотим получить из задачи. Возвращаемое число будет храниться в свойстве `Result`.  Обращение к свойству `Result` блокирует текущий поток.

---

**==Wait==**. Чтобы приложение ожидало завершения задачи, можно использовать метод `Wait()` объекта `Task`. Стоит учитывать, что при ожидании текущий поток блокируется.

```c#
Task task = Task.Run(action);
task.Wait();
```

**==RunSynchronously==**. По умолчанию задачи запускаются асинхронно. Однако с помощью метода `RunSynchronously` задачу можно запускать в синхронном режиме. Такая задача забирает вызывающий ее поток и выполняется в его контексте. Не требует ожидания.

```c#
Task task = new Task(action);
task.RunSynchronously();
```

**==Delay==**. Представляет статический метод класса `Task`, который принимает число миллисекунд в виде числа и выполняет асинхронное ожидание текущей задачи.

**==WaitAll==**. Представляет статический метод класса `Task`, который принимает массив задач и блокирует текущий поток выполнения до выполнения каждой из них.

**==WaitAny==**. Представляет статический метод класса `Task`, который принимает массив задач и блокирует текущий поток выполнения до выполнения первой из них.

**==ContinueWith==**. Задачи продолжения позволяют определить задачи, которые выполняются после завершения других задач. Благодаря этому мы можем вызвать после выполнения одной задачи несколько других, определить условия их вызова, передать из предыдущей задачи в следующую некоторые требуемые данные.

```c#
Task baseTask = new Task(action);
Task contTack = baseTask.ContinueWith(baseTaskInst => {});
```

**==FromResult==**. Представляет статический метод `Task`, который принимает результат задачи и создает уже завершенную задачу с переданным результатом.

---

Параллельное выполнение задач может занимать много времени. И иногда может возникнуть необходимость прервать выполняемую задачу. Для этого платформа предоставляет механизм отмены задач в виде структуры `CancellationToken`.

Для начала требуется создать источник токенов `CancellationTokenSource`, который через свойство `Token` выписывает токен, который можно отменить через `Cancel`.
Данный класс является неуправляемым ресурсом и требует вызова `Dispose`.
Токен должен быть доступен в контексте задачи и передаваться в нее при запуске.

Также CancellationTokenSource позволяет установить таймаут по истечению которого автоматически отменяться все токены. Для этого используется `cts.CancelAfter(time`).

Токены представлены классом `CancellationToken`. Свойство `IsCancellationRequested`, возвращает `true` при отмене токена. При отмене код задачи должен выбрасывать исключение `OperationCanceledException`. Есть метод `ThrowIfCancellationRequested`, который автоматически выбрасывает это исключение при отмене токена.

```c# 
CancellationTokenSource cancelTokenSource = new CancellationTokenSource(); 
CancellationToken token = cancelTokenSource.Token;
Task task = new Task(() => { token.ThrowIfCancellationRequested() }, token);
```

Также есть и другой способ узнать о том, что был послан сигнал отмены задачи. Метод `Register()` позволяет зарегистрировать обработчик отмены задачи в виде `Action`. Зарегистрированное действие будет вызвано при сигнале об отмене токена.

```c#
Task task = new Task(() => {
	token.Registr(action);
}, token);
```

---

Одним из механизмов, позволяющим эффективно работать задачам, является класс `TreadPool`. Пул потоков представляет коллекцию зарезервированных потоков, для оптимизирования выполнения многопоточных задач. Это уменьшает расходы на создание и уничтожение потоков, особенно при большом количестве коротких задач, поскольку потоки в пуле могут быть повторно использованы после завершения задачи.

При наличии большого количества одновременно работающих задач, будет создан еще один фоновый поток, который будет сохранен в пуле. Когда поток отработает, он не уничтожается, а возвращается в пул потоков для ожидания следующей задачи.

---

Класс Task определяет рад методов и свойств для получения информации о выполняемой задаче, о ее статусе, идентификаторе и о ее состоянии:

1. **AsyncState** - возвращает объект состояния задачи
3. **Id** - возвращает идентификатор текущей задачи
4. **Status** - возвращает статус задачи.
5. **IsCompleted** - возвращает true, если задача завершена
6. **IsCanceled** - возвращает true, если задача была отменена
7. **IsFaulted** - true, если задача завершилась с исключением
8. **IsCompletedSuccessfully** - true, если задача завершилась успешно
9. **Exception** - возвращает исключения, возникшего при выполнении задачи

[[🟡ExecutionModel]]


