Система определяет `TPL(Task Parallel Library)`, которая представляет собой библиотеку, которая обеспечивает высокий уровень абстракции для параллельного и конкурентного программирования с использованием `Task` и других конструкций библиотеки `NET`.

Данная библиотека упрощает работу с многоядерными системами. Кроме того, она упрощает работу по созданию новых потоков. Поэтому рекомендуется использовать
именно `TPL` и ее классы для создания многопоточных приложений, хотя стандартный подход с использованием `Thread` по прежнему находят широкое применение.

Библиотека параллельных задач представляет собой набор открытых типов и интерфейсов
в пространствах имен `System.Threading` и `System.Threading.Tasks`. Ее цель в повышении производительности труда разработчиков за счет упрощения параллелизма в приложения.

Библиотека динамически масштабирует степень параллелизма, чтобы использовать все доступные процессоры наиболее эффективно. Кроме того, в библиотеке параллельных
задач осуществляется секционирование работы, планирование потоков в  `ThreadPool`, поддержка отмены, управление состоянием и выполняет другие задачи приложения.

---

Библиотека `TPL` содержит статический класс `Parallel`. Который предназначен
для упрощенного параллельного выполнения методов и параллельных итераций.

**==Invoke==**. Принимает набор методов и пытается выполнить их параллельно. При это
блокирует вызывающий поток до выполнения каждой из переданных операций. Не
имеет прямого способа вернуть результат. Возврат реализуется через замыкание.

```c#
Parallel.Invoke(action1, ..., actionN);
```

**==For==**. Позволяет выполнить параллельно набор методов, передавая в каждый соответствующий индекс. Также принимает начальный и конечный индексы.

```c#
ParallelLoopResult result = Parallel.For(startIndedx, endIndedx, (index) => {});
```

**==ForEach==**. Осуществляет итерацию по коллекции, реализующей интерфейс `IEnumerable`, подобно циклу `foreach`, только осуществляет параллельное выполнение перебора.

```c#
ParallelLoopResult result = Parallel.ForEach<int>(colection, (item) => res));
```

Методы `Parallel.ForEach` и `Parallel.For` возвращают объект `ParallelLoopResult`. Содержит свойство `IsCompleted`, указывающее завершен ли полностью цикл и
свойство `LowestBreakIteration`, содержащее индекс остановленной итерации.

Также в делегаты `Action` методов `For` и `ForEach` может передаваться дополнительный параметр `ParallelLoopState`, который позволяет управлять поведением цикла. Через
метод `Break` можно итерации после завершения текущей. Или сразу через `Stop`.

```c#
ParallelLoopResult result = Parallel.For(1, 10, Method);
if (!result.IsCompleted) Console.WriteLine($"{result.LowestBreakIteration}");
 
void Method(int n, ParallelLoopState pls)
{
    pls.Break();
    pls.Stop();
}
```

---

Основной функционал библиотеки `TPL` содержится в классе `Task`. Данный класс описывает отдельную задачу, которая запускается асинхронно в одном из потоков из пула потоков.

Экземпляр запущенной задачи можно создать, используя конструктор `Task(action)`, после чего запустить ее методом `Start`. Также можно воспользоваться статическим методом `Run(action)` или же создать ее фабрикой `Task.Factory.StartNew(action)`. 

```c#
Task task1 = new Task(action); task1.Start();
Task task2 = Task.Factory.StartNew(action);
Task task3 = Task.Run(action);
```

С помощью методов класса Task, можно проверить статус завершения задачи: `IsCompleted`, `IsCanceled`, `IsFaulted` и также `IsCompletedSuccessfully`. Также через свойство `Status` можно получить статус выполнения задачи, если задача завершилась с выбрасыванием исключения, то получить это исключение можно через свойство задачи `Exception`.

Задачи могут не только выполняться как процедуры, но и возвращать определенные результаты. Для этого необходимо типизировать объект `Task` тем типом, объект которого мы хотим получить из задачи. Возвращаемое число будет храниться в свойстве `Result`.  Обращение к свойству `Result` блокирует текущий поток до момента завершения.

---

**==Wait==**. Чтобы приложение ожидало завершения задачи, можно использовать метод
`Wait()` объекта `Task`. Стоит учитывать, что при ожидании текущий поток блокируется.

```c#
Task task = Task.Run(action);
task.Wait();
```

**==RunSynchronously==**. По умолчанию задачи запускаются асинхронно. Однако с помощью метода `RunSynchronously` задачу можно запускать в синхронном режиме. Такая задача забирает вызывающий ее поток и выполняется в его контексте. Не требует ожидания.

```c#
Task task = new Task(action);
task.RunSynchronously();
```

**==Delay==**. Представляет статический метод класса `Task`, который принимает число
миллисекунд в виде числа и выполняет асинхронное ожидание текущей задачи.

**==WaitAll==**. Представляет статический метод класса `Task`, который принимает массив
задач и блокирует текущий поток выполнения до выполнения каждой из них.

**==WaitAny==**. Представляет статический метод класса `Task`, который принимает массив
задач и блокирует текущий поток выполнения до выполнения первой из них.

**==ContinueWith==**. Задачи продолжения позволяют определить задачи, которые выполняются после завершения других задач. Благодаря этому мы можем вызвать после выполнения одной задачи несколько других, определить условия их вызова, передать результат.

```c#
Task baseTask = new Task(action);
Task contTack = baseTask.ContinueWith(baseTaskInst => {});
```

**==FromResult==**. Представляет статический метод `Task`, который принимает результат
задачи и создает уже завершенную задачу с переданным в аргументе результатом.

---

Параллельное выполнение задач может занимать много времени. И иногда может возникнуть необходимость прервать выполняемую задачу. Для этого платформа предоставляет механизм отмены задач в виде структуры `CancellationToken`.

Для начала требуется создать источник токенов `CancellationTokenSource`, который 
через свойство `Token` выписывает токен, который можно отменить через `Cancel`.
Данный класс является неуправляемым ресурсом и требует вызова `Dispose`.
Токен должен быть доступен в задачи и передаваться в нее при запуске.

Также `CancellationTokenSource` позволяет установить таймаут по истечению которого автоматически отменяться все токены. Для этого используется `cts.CancelAfter(time`).

Токены представлены классом `CancellationToken`. Свойство `IsCancellationRequested`, возвращает `true` при отмене токена. При отмене задачи ее код должен выбрасывать исключение `OperationCanceledException`. Есть метод `ThrowIfCancellationRequested`, который автоматически выбрасывает это исключение если токен сейчас отменен.

```c# 
CancellationTokenSource cancelTokenSource = new CancellationTokenSource(); 
CancellationToken token = cancelTokenSource.Token;
Task task = new Task(() => { token.ThrowIfCancellationRequested() }, token);
```

Также есть и другой способ узнать о том, что был послан сигнал отмены задачи. Метод `Register()` позволяет зарегистрировать обработчик отмены задачи в виде `Action`. Зарегистрированное действие будет вызвано при сигнале об отмене токена.

```c#
Task task = new Task(() => {
	token.Registr(action);
}, token);
```

---

Фабрика задач `TaskFactory` представляет класс, который упрощает создание задач
с дополнительными параметрами. Он позволяет создать задачи с настройками отмены, расписания, приоритетов и обработки ошибок. Доступна через статический `Taks.Factory`.
Также экземпляр фабрики можно создать и отдельно от статической фабрики в классе `Task`.
При создании экземпляра задачи через фабрику задач `Task.Factory` или через конструктор задачи, можно передать  элемент перечисления `TaskCreationOptions` для ее настройки.

**==AttachedToParent==**. Указывает, что задача должна быть присоединена к родительской задаче. По умолчанию дочерняя задача выполняется независимо от родительской. Это означает,
что по умолчанию дочерняя задача может завершится раньше родительской.

**==DenyChildAttach==**. Указывает, что любая дочерняя задача, должна быть выполнена как
часть текущей, то есть как будто все дочерние задачи созданы с `AttachedToParent`.

**==LongRunning==**. Указывает планировщику задач, что создаваемая задача является
долго исполняемой, чтобы планировщик учел это при настройке пула потоков,
создав под запускаемую задачу отдельный поток вне текущего пула потоков.

**==PreferFairness==**. Рекомендация для планировщика планировать задач максимально
прямым способом, то есть задачи, запланированные ранее, будут выполняться ранее.

---

Планировщик задач `TaskScheduler` представляет собой абстракцию, которая управляет
тем, когда и где будут выполняться задачи в многозадачном приложении. Когда создается задача, она передается своему планировщику задач для исполнения. По умолчанию, задачи выполняются в контексте пула потоков то есть используя класс `ThreadPoolTaskScheduler`. 
Планировщик задач можно задать через конструктор класса фабрики `TaskFactory`.

Каждая задача связана с планировщиком задач, который определяет, где и когда она будет выполнена. Планировщик задач управляет потоком выполнения задачи, гарантируя, что она будет выполнена в нужном контексте. Это важный так как задачи могут требовать условий для выполнения, в определенном потоке или на определенной аппаратной платформе.

В некоторых случаях стандартного поведения может быть недостаточно. В таких случаях можно создавать пользовательские реализации `TaskScheduler`, которые определяют, как
и где задачи будут выполняться. Например, можно создать планировщик, который будет выполнять задачи только в одном потоке или будет использовать специальные очереди.

**==TaskScheduler.Current==**. Возвращает текущий планировщик. Обычно это пул потоков, но для некоторых ситуаций, например в десктопных приложениях, может быть иное значение.

==**TaskScheduler.Default**==. Возвращает стандартный планировщик задач, использующий
пул потоков для планирования параллельного выполнения задач в приложении.

**==TaskScheduler.FromCurrentSynchronizationContext()==**: Cоздает планировщик
задач, который выполняет задачи в контексте синхронизации текущего потока.

```c#
Task.Factory.StartNew(() => {
    // Код, который будет выполняться в потоке UI
}, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.FromCurrentSynchronizationContext());
```

---

Класс `SynchronizationContext` в представляет абстракцию для управления контекстом синхронизации, который используется для выполнения операций в определенном потоке. Этот класс предоставляет механизм для выполнения кода в нужном потоке, например, для взаимодействия с пользовательским интерфейсом в многозадачных приложениях.

Контекст используется для управления синхронизацией потоков. Позволяет перенаправлять выполнение кода в контексте нужного потока например, для потока интерфейса. А также управляет асинхронными операциями при работе с  асинхронными методами.


```c#
SynchronizationContext context = new SynchronizationContext();

context.Post(_ => {}, null); // Async
context.Send(_ => {}, null); // Sync
```


[[СSharp/🟡Base|🟡Base]]


