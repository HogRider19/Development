Среда предусматривает написание по большей части безопасного кода. Безопасный код означает, что средства .NET могут убедиться, что код валидно работает с памятью. Как правило, в безопасном коде не используется прямой доступ к памяти с помощью указателей. В нем также не используется выделение блоков памяти в сыром виде.

Но также среда предоставляет создание блоков небезопасного контекста. В таком контексте `unsafe` в коде можно использовать указатели, выделять и освобождать блоки памяти, а также обращаться к методам с помощью указателей функций.
При этом компиляция должна проходить с параметром `AllowUnsafeBlocks`.

В небезопасном контексте тип может быть не только типом значения или ссылочным типом, но и типом указателя. Объявления типа указателя выполняется способом:

```c#
type* identifier;
void* identifier;
```

При этом в качестве типа указателя могут выступать только значимые объекты. При объявлении указателя с ссылочным типом, будет объявлен указатель на ссылку.

Указатель может указывать на структуру, содержащую ссылки, но эта операция не имеет смысла, поскольку ссылка на объект может быть подвергнута сбору мусора, даже если на нее указывает указатель. Сборщик мусора не отслеживает наличие указателей при сборке. Из-за этого получаем неопределенное поведение.

При передаче указателей между методами может также возникнуть неопределенное поведение. Рекомендуется использовать метод, возвращающий указатель в локальную переменную с помощью параметра `out`. Если указатель был задан в фиксированном блоке, переменная, на которую он указывает, больше не может быть фиксированной.

Любой тип указателя можно неявно преобразовать в тип void*. Любому типу указателя может быть присвоено значение null. Любой тип указателя можно явно преобразовать в любой другой тип указателя с помощью выражения приведения.

Можно также преобразовать любой целочисленный тип в тип указателя и наоборот. Для этих преобразований требуется явным образом использовать приведение.

---

Инструкция `fixed` предотвращает дефрагментацию переменной сборщиком мусора и объявляет указатель на нее. Адрес закрепленной переменной не изменяется во время выполнения. Указатель можно использовать только в соответствующем контексте.

```c#
unsafe
{
    byte[] bytes = [1, 2, 3];
    fixed (int* toFirst = &bytes[0], toLast = &bytes[^1]) 
    {
	    // some code
    }
}
```

Также эта конструкция используется в при получении адреса значимого типа, находящегося внутри ссылочного, для фиксации памяти ссылочного типа.

---

Выражение `stackalloc` выделяет блок памяти в стеке. Выделенный стеком блок памяти, созданный во время выполнения метода, автоматически очищается при его завершении. Вы не можете явно освободить память, выделенную через `stackalloс`. Выделенный блок памяти стека не должен быть закреплен с помощью `fixed`.

Результат выполнения выражения `stackalloc` можно присвоить переменной типа `Span`, `ReadOnlySpan` или указателю в небезопасном контексте выполнения.

```c#
Span<int> num         = stackalloc int[10];
ReadOnlySpan<int> num = stackalloc int[10];
int* ptr              = stackalloc int[10];
```

Нет необходимости использовать небезопасный контекст при назначении выделенного в стеке блока памяти переменным с типами `Span<T>` или `ReadOnlySpan<T>`.

При работе с такими типами вы можете использовать выражение `stackalloc` в условном выражении или выражении присваивания, как показано в примере:

```c#
Span<byte> b = length <= 1024 ? stackalloc byte[length] : new byte[length];
```

Содержимое только что выделенной памяти не определено. Его следует определить перед использованием. Например, вы можете использовать метод `Span<T>.Clear`, который задает для всех элементов значение по умолчанию, предусмотренное `T`.

При использовании `stackalloc` в среде `CLR` автоматически включается контроль переполнения буфера. Если буфер переполнен, процесс незамедлительно прерывается. Это позволяет минимизировать риск случайного исполнения вредоносного кода.

---

Вы можете использовать ключевое слово `fixed`  для создания буфера с массивом фиксированного размера в структуре данных. Буферы фиксированного размера полезны при написании, взаимодействия с источниками данных других платформ. 

Буфер фиксированного размера может принимать любые атрибуты или модификаторы, разрешенные для обычных элементов структуры. Единственным ограничением является то, что получаемый массив должен быть неуправляемым.

```c#
private fixed char name[30];
```

В безопасном коде структура, содержащая массив, не содержит элементы массива. Вместо этого в ней присутствуют ссылки на элементы. Вы можете внедрить массив фиксированного размера в структуру, если она объявляется в небезопасном коде.