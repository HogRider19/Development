Программное обеспечение `Git` представляет собой распределённую систему для контроля версий, которая позволяет управлять исходным кодом. Изначально, `Git` был разработан  `Линусом Торвальдсом` для удобной разработки `Linux Kernel`.

Система контроля версий представляет собой программное обеспечение, которое помогает разработчикам работать в команде и сохранять историю разработки проекта.
Они могут классифицироваться на централизованные и децентрализованные.

Централизованные системы используют центральный сервер для хранения всех файлов. Но данный тип систем подвержен большой опасности – выходу из строя центрального сервера. Если с сервером что-то происходит, то работа прекращается.

Клиент децентрализованной системы не только проверяет крайние изменения базовой директории, но также является и резервным хранилищем проекта. Если сервер выходит из строя, базовая версия может быть восстановлена с помощью клиентской машины.

---

Основное отличие `Git` от любой другой системы контроля версий это подход к работе со своими данными. Концептуально, большинство других систем хранят информацию в виде списка изменений в файлах. Эти системы представляют хранимую информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени.

В свою очередь `Git` не хранит и не обрабатывает данные таким способом. Вместо этого, каждый раз, когда вы делаете коммит, система создает снимок текущего состояния репозитория, и сохраняет ссылку на этот снимок. Для эффективности, если файлы не были изменены, `Git` не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён.

В `Git` для всего вычисляется хеш-сумма, и только потом происходит сохранение. В дальнейшем обращение к сохранённым объектам происходит по этой хеш-сумме. Это значит, что невозможно изменить файл так, чтобы система `Git` не узнала об этом. Это встроено в `Git` на низком уровне и является неотъемлемой частью его философии. 

Хеш представляет строку длиной в 40 шестнадцатеричных символов, она вычисляется на основе содержимого файла или структуры каталога. На самом деле, Git сохраняет все объекты в свою базу данных не по имени, а по хеш-сумме содержимого объекта.

У `Git` есть три основных состояния, в которых могут находиться внутренние         файлы: `modified(изменён)`,  `staged(индексирован)`, `committed (зафиксирован)`:

К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
К индексированным измененные файлы, отмеченные для включения в коммит.
К зафиксированным файлы, которые уже сохранены в вашей локальной базе.

![[Pasted image 20240302142052.png]]

---

**==Init==**. Эта команда создаёт в текущем каталоге новый подкаталог с именем `.git`, содержащий все необходимые файлы репозитория структуру `Git` репозитория. На этом этапе ваш проект ещё не находится под версионным контролем.

```sh
git init
```

**==Add==**. Для того чтобы начать отслеживать то есть добавления под версионный контроль новый файл, используется команда `add`. Это многофункциональная команда, которая используется для добавления под версионный контроль новых файлов, для индексации изменений и для указания файлов с исправленным конфликтом слияния.

```sh
git add filename
git add -A
```

**==Status==**. Вывод команды `git status` довольно всеобъемлющий и многословный. Также имеется флаг сокращённого статуса, так что можно увидеть компактную информацию. В выводе содержится два столбца  со статусом файла и указанием модификации.

```sh
git status -s

?? - не отслеживаемые
A - добавленные в отслеживаемые
M - отредактированные файлы
```

**==Diff==**. Если результат работы команды `git status` недостаточно информативен для вас  и вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены, можно воспользоваться встроенной командой `git diff`.

```sh
git diff
```

**==Commit==**. Используется для создания коммита со всеми проиндексированными файлами.
Добавление параметра `-a` в команду заставляет `Git` автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя обойтись без `git add`.

```sh
git commit -m ""
git commit -a -m ""
```

**==Rm==**. Для того чтобы удалить файл из `Git`, вам необходимо удалить его из отслеживаемых файлов через `git rm`, а затем выполнить коммит. Команда также удаляет файл из вашего рабочего каталога. Если файл изменен и проиндексирован, вы должны использовать принудительное удаление с помощью `-f`. Используйте `--cached` чтобы удалить файл из индекса, оставив его сохраненным в файловой системе.

```sh
git rm --cached -f README
git rm log/\*.log
```

**==Log==**. Используется для отображения списка коммитов. Может включать в себя параметр `-p` или `--patch`, который отображает разницу между коммитами. Также можно добавить `--oneline` для отображения коммитов в одной строке.

Также есть опция `-S`, которая принимает аргумент в виде строки и показывает только те коммиты, в которых изменение в коде повлекло добавление или удаление строки. 

```sh
git log --patch --oneline
git log -S function_name
```

---

В любой момент вам может потребоваться что-либо отменить. Не все операции отмены в свою очередь можно отменить! Это одна из редких областей `Git`, где неверными действиями можно необратимо удалить результаты своей работы.

**==Ammend==**. Отмена может потребоваться, если вы сделали коммит, например, забыв добавить какие-то файлы или комментарий к коммиту. В таком случае внесите необходимые изменения, добавьте их в индекс и сделайте коммит, указав `--amend`:

```sh
git commit -m 'Initial commit'
git add forgotten_file
git commit --amend
```

Эта команда использует область подготовки для внесения правок в коммит. Если вы ничего не меняли с момента последнего коммита, то снимок состояния останется в точности таким же, а всё что вы сможете изменить это ваше сообщение к коммиту.

**==Reset==**. Для отмены индексации файлов, можно воспользоваться командой `reset`. Команда `git reset` может быть опасной если вызвать её с параметром `--hard`.

```sh
git reset HEAD <file_name>
```

**==Сheckout==**. Для отмены индексации файла и возврату его к предыдущему состоянию, можно воспользоваться командой `git checkout -- <file>`. Она отменяет все изменения и возвращает файл в состояние последнего созданного коммита. 

```sh
git checkout -- <file_name>
```

**==Restore==**. Новая версия `Git` представила новую команду: `git restore`. По сути, это альтернатива `git reset`. Также она используется для многих операций отмены.
Без аргументов откатывает файл, а с аргументом `--staged` снимает индексацию.

```sh
git restore <file_name>            // Отмена индексации и изменений файла
git restore --staged <file_name>   // Только отмена индексации файла
```

---

Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения и записи. 

Для того, чтобы просмотреть список настроенных удалённых репозиториев относительно локального, вы можете запустить команду `git remote`. Также можно указать ключ `-v`, чтобы просмотреть адреса для чтения и записи репозитория.

Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду `git remote add <shortname> <remote_server_url>`.

Теперь вместо указания полного пути вы можете использовать `<shortname>` при выполнении `fetch <shortname>` для загрузки удаленного репозитория, а также               в `pull <shortname>` для загрузки и слияния с удаленным репозиторием.

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий через команду: `git push <remote-name> <branch-name>`.

```sh
git remote -v                           // Показывает удаленные репозитории
git fetch <remote-name>                 // Получение данных с сервера
git pull  <remote-name>                 // Получение данных и слияние
git push  <remote-name> <branch-name>   // Отправка данных на сервер
```

Для переименования удалённого репозитория можно выполнить `git remote rename`.  Для удаления удалённого репозитория  можно использовать команду `git remote rm`.

---

Как и большинство других систем контроля версий, `Git` имеет возможность помечать определённые моменты в истории как важные. Как правило, эта функциональность используется для отметки моментов выпуска версий. Пометки в `Git` называются тэги.

Просмотреть список имеющихся тегов в Git можно очень просто. Достаточно набрать команду `git tag`, параметр `--list <ptrn>` используется для фильтрации по шаблону.

```sh
git tag -l "v1.8.5*"             // Вывод всех тегов начинающихся с v1.8.5
```

Git использует два основных типа тегов: `легковесные` и `аннотированные`.
Легковесный тег представляет собой  просто указатель на определённый коммит.
А вот аннотированные теги хранятся в базе данных как полноценные объекты. Они содержат контрольную сумму, имя автора, почту и дату создания, имеют комментарий.

Обычно рекомендуется создавать аннотированные теги, чтобы сохранить всю  перечисленную информацию. Но если вы хотите сделать временную метку или не хотите сохранять остальную информацию, то для этого годятся и легковесные теги.

Создание аннотированного тега в `Git` выполняется легко. Самый простой способ  это указать `-a` при выполнении команды `tag`.  Опция `-m` задаёт комментарий. С помощью команды `git show <tag_name>` вы можете посмотреть данные тега вместе с коммитом.

Для создания легковесного тега не передавайте опций `-a`, `-s` и `-m`, укажите только название. По сути легковесный тег это контрольная сумма коммита, сохранённая в файл, больше никакой информации в системе контроля версий храниться не будет.

Если в конец команды создания тега передать хэш коммита или его часть, то создаваемый тег прикрепится к коммиту с заданной хэш суммой.

```sh
git tag -a <tag_name> -m <description>   // Создание аннотированного тега
git tag -a v1.4.11-lw -m "" 9fceb02      // Прикрепление тега к коммиту
git tag <tag_name>                       // Создание легковесного тега
```

По умолчанию, команда `git push` не отправляет теги на удалённые сервера. После создания теги нужно отправлять явно на удалённый сервер. Процесс аналогичен отправке веток,  достаточно выполнить команду `git push origin <tagname>`.

Если у вас много тегов, и вам хотелось бы отправить все за один раз, то можно использовать опцию `--tags` для команды `git push`. В таком случае все ваши теги отправятся на удалённый сервер (если только удаленный сервер их уже не содержит).

```sh
git push <remote_server_name> <tagname>
git push --tags
```

Для локального удаления тега требуется выполнить команду `git tag -d <tagname>`.  При удалении тега не происходит его удаления с внешних серверов. Для удаления тега с удаленного сервера нужно выполнить команду `push` c опцией `--delete`.

```sh
git tag -d <tagname>                   // Локальное удаление тега
git push <remote> --delete <tagname>   // Удаление тега с сервера
```

Если вы хотите получить версии файлов, на которые указывает тег, то вы можете сделать `git checkout` для тега. Однако, это переведёт репозиторий в состояние `detached HEAD`, которое имеет ряд неприятных побочных эффектов.

Если в состоянии `detached HEAD` внести изменения и сделать коммит, то тег не изменится, при этом новый коммит не будет относиться ни к какой из веток, а доступ к нему можно будет получить только по его хэшу. Поэтому, если вам нужно внести изменения следует вместе с переходом на тег создать ветку новую ветку.

```sh
git checkout -b <new_branch_name> <tag_name>
```
