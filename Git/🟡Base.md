Программное обеспечение `Git` представляет собой распределённую систему для контроля версий, которая позволяет управлять исходным кодом. Изначально, `Git` был разработан  `Линусом Торвальдсом` для удобной разработки `Linux Kernel`.

Система контроля версий представляет собой программное обеспечение, которое помогает разработчикам работать в команде и сохранять историю разработки проекта.
Они могут классифицироваться на централизованные и децентрализованные.

Централизованные системы используют центральный сервер для хранения всех файлов. Но данный тип систем подвержен большой опасности – выходу из строя центрального сервера. Если с сервером что-то происходит, то работа прекращается.

Клиент децентрализованной системы не только проверяет крайние изменения базовой директории, но также является и резервным хранилищем проекта. Если сервер выходит из строя, базовая версия может быть восстановлена с помощью клиентской машины.

---

Основное отличие `Git` от любой другой системы контроля версий это подход к работе со своими данными. Концептуально, большинство других систем хранят информацию в виде списка изменений в файлах. Эти системы представляют хранимую информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени.

В свою очередь `Git` не хранит и не обрабатывает данные таким способом. Вместо этого, каждый раз, когда вы делаете коммит, система создает снимок текущего состояния репозитория, и сохраняет ссылку на этот снимок. Для эффективности, если файлы не были изменены, `Git` не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён.

Такие снимки называются деревьями директорий `tree`, каждое такое дерево хранит набор файлов `blob`, которые в свою очередь хранят размеры и содержимое советующих им файлов. Каждый коммит хранит ссылку на такое дерево.   

В `Git` для всего вычисляется хеш-сумма, и только потом происходит сохранение. В дальнейшем обращение к сохранённым объектам происходит по этой хеш-сумме. Это значит, что невозможно изменить файл так, чтобы система `Git` не узнала об этом. Это встроено в `Git` на низком уровне и является неотъемлемой частью его философии. 

Хеш представляет строку длиной в 40 шестнадцатеричных символов, она вычисляется на основе содержимого файла или структуры каталога. На самом деле, Git сохраняет все объекты в свою базу данных не по имени, а по хеш-сумме содержимого объекта.

У `Git` есть три основных состояния, в которых могут находиться внутренние         файлы: `modified(изменён)`,  `staged(индексирован)`, `committed (зафиксирован)`:

К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
К индексированным измененные файлы, отмеченные для включения в коммит.
К зафиксированным файлы, которые уже сохранены в вашей локальной базе.

![[Pasted image 20240302142052.png]]

---

**==Init==**. Эта команда создаёт в текущем каталоге новый подкаталог с именем `.git`, содержащий все необходимые файлы репозитория структуру `Git` репозитория. На этом этапе ваш проект ещё не находится под версионным контролем.

```sh
git init
```

**==Add==**. Для того чтобы начать отслеживать то есть добавления под версионный контроль новый файл, используется команда `add`. Это многофункциональная команда, которая используется для добавления под версионный контроль новых файлов, для индексации изменений и для указания файлов с исправленным конфликтом слияния.

```sh
git add filename
git add -A
```

**==Status==**. Вывод команды `git status` довольно всеобъемлющий и многословный. Также имеется флаг сокращённого статуса, так что можно увидеть компактную информацию. В выводе содержится два столбца  со статусом файла и указанием модификации.

```sh
git status -s

?? - не отслеживаемые
A - добавленные в отслеживаемые
M - отредактированные файлы
```

**==Diff==**. Если результат работы команды `git status` недостаточно информативен для вас  и вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены, можно воспользоваться встроенной командой `git diff`.

```sh
git diff
```

**==Commit==**. Используется для создания коммита со всеми проиндексированными файлами.
Добавление параметра `-a` в команду заставляет `Git` автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя обойтись без `git add`.

```sh
git commit -m ""
git commit -a -m ""
```

**==Rm==**. Для того чтобы удалить файл из `Git`, вам необходимо удалить его из отслеживаемых файлов через `git rm`, а затем выполнить коммит. Команда также удаляет файл из вашего рабочего каталога. Если файл изменен и проиндексирован, вы должны использовать принудительное удаление с помощью `-f`. Используйте `--cached` чтобы удалить файл из индекса, оставив его сохраненным в файловой системе.

```sh
git rm --cached -f README
git rm log/\*.log
```

**==Log==**. Используется для отображения списка коммитов. Может включать в себя параметр `-p` или `--patch`, который отображает разницу между коммитами. Также можно добавить `--oneline` для отображения коммитов в одной строке.

Также есть опция `-S`, которая принимает аргумент в виде строки и показывает только те коммиты, в которых изменение в коде повлекло добавление или удаление строки. 

```sh
git log --patch --oneline
git log -S function_name
```

**==Grep==**. Позволяет легко искать вхождения в истории коммитов или в рабочем каталоге по строке или регулярному выражению.  По умолчанию эта команда ищет по файлам в рабочем каталоге. Параметр `-n` или `--line-number` печатает номера строк вхождений. Параметр `-с` или `--count` выводит имена файлов в которых были найдены вхождения.

```sh
git grep <re>
git grep --line-number <re>
git grep --count <re>
```