Почти каждая система контроля версий так или иначе поддерживает ветвление. Используя ветвление, вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. Во многих системах контроля версий создание веток  очень затратный процесс, часто требующий   создания новой копии каталога с исходным кодом, что может занять время.

Когда вы делаете коммит, `Git` сохраняет его в виде объекта, который содержит указатель на снимок подготовленных данных. Этот объект так же содержит имя автора, почту, сообщение и указатель на предшествующие коммит или коммиты: отсутствие родителя для первоначального коммита, один родитель для обычного коммита, и несколько родителей для результатов слияния двух и более различных веток.

Предположим, у вас есть каталог с тремя файлами и вы добавляете их все в индекс и создаёте коммит. Во время индексации вычисляется контрольная сумма файлов, затем файлы сохраняются в репозиторий в виде `blob`, а контрольная сумма попадёт в индекс.

![[Pasted image 20240307192230.png]]

Ветка в `Git` это простой перемещаемый указатель на один из таких коммитов. По умолчанию, имя основной ветки  `master`. Как только вы начнёте создавать коммиты, ветка `master` будет всегда указывать на последний коммит. Каждый раз при создании коммита указатель ветки `master` будет передвигаться автоматически.

Что же на самом деле происходит при создании ветки? Всего лишь создаётся новый указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с именем `new_branche`. Вы можете это сделать это действие командой `git branch`. При использовании параметра `-b`, при создании ветки произойдет переключение на нее.

Команда `git branch` без параметров просто выводит список веток. Параметр `-v` выводит информацию о последнем коммите в ветках. Опции `--merged` и `--no-merged` показывают только слитые и не слитые с текущей веткой другие ветки соответственно.
Параметр `-d` удаляет только слитую ветку, а `-D` удаляет любую имеющуюся ветку.

```sh
git branch -v                         // Список веток с коммитами
git branch --merged                   // Список слитых веток
git branch <branch_name>              // Создает ветку
git branch -b <branch_name>           // Создает и переходит в ветку
git branch -d <branch_name>           // Удаляет слитую ветку
```


Как `Git` определяет, в какой ветке вы находитесь? Он хранит указатель `HEAD`, который ссылается на текущую ветку рабочей директории. Для переключения на другую ветку, то есть перемещение указателя `HEAD` выполняется команда `git checkout <name>`.

```sh
git checkout <branch_name>
```

В новых версиях `Git`, вы можете использовать `git switch` вместо `git checkout`, чтобы: Переключиться на существующую ветку и Создать новую ветку и переключиться на неё.

```sh
git switch <branch_name>          // Переключение на ветку
git switch --create <branch_name> // Создать и переключиться на ветку
git switch -                      // Вернуться к предыдущей извлечённой ветке
```

Для переименовании ветки, нужно сначала изменить ее локальное название, затем загрузить изменения на сервер, а потом удалить старую ветку с сервера.

```sh
git branch --move <old_name> <new_name>
git push --set-upstream <server_name> <new_name>
git push <server_name> --delete <old_name>
```

---

Удалённые ссылки  это ссылки в ваших удалённых репозиториях, включая ветки, теги и так далее. Полный список удалённых ссылок можно получить с помощью команды `git ls-remote <remote>` или команды `git remote show <remote>`. Тем не менее, более распространённым способом является использование веток слежения.

Ветки слежения представляют собой ссылки на определённое состояние удалённых веток. Это локальные ветки, которые нельзя перемещать; `Git` перемещает их автоматически при любой коммуникации с удалённым репозиторием.

Имена веток слежения имеют вид `<remote>/<branch>`. Например, если вы хотите посмотреть, как выглядела ветка `master` на сервере `origin` во время последнего соединения с ним, используйте ветку `origin/master`. Если кто-то отправил на сервер ветку `iss53`, при том что у вас может быть своя локальная ветка `iss53`, удалённая ветка будет представлена веткой слежения поименованной как `origin/iss53`.

Для синхронизации ваших изменений с удалённым сервером выполняется команда `git fetch <remote>` . Эта команда извлекает оттуда данные, которых у вас ещё нет, и обновляет локальную базу данных, сдвигая указатели удаленных веток.

Когда вы хотите поделиться веткой, вам необходимо отправить её на удалённый сервер. Ваши локальные ветки автоматически не синхронизируются с удалёнными ветками при отправке, вам нужно явно указать ветки, которые вы хотите отправить.

```sh
git push <remote_name> <branch>           // Обновление ветки branch
git push <remote> <local_b>:<remote_b>    // Полная запись при разных названиях
```

Необходимо отметить, что при получении данных создаются ветки слежения, вы не получаете автоматически для них локальных редактируемых копий. Чтобы слить эти наработки в свою текущую рабочую ветку, выполните `git merge <remote_branch>`.   Если же вам нужна просто локальная ветка на основе ветки слежения используйте:

```sh
git checkout -b <name> <remote_branch_name>
```

Получение локальной ветки из удалённой автоматически создаёт ветку слежения. Ветки слежения представляют собой локальные ветки, которые напрямую связаны с удалённой веткой. Если, находясь на ветке слежения, выполнить `git pull`, то `Git` уже будет знать с какого сервера получать данные и какую ветку использовать для слияния.

При клонировании репозитория, как правило, автоматически создаётся ветка `master`, которая следит за `origin/master`. Вы можете настроить отслеживание и других веток. Cделать это можно с помощью команды `git checkout -b <branch> <remote>/<branch>`. 

Это часто используемая команда, поэтому Git предоставляет сокращённую форму записи в виде флага `--track`. Также если вы пытаетесь извлечь ветку и существует только одна удалённая ветка с таким именем, то создастся ветка слежения:

```sh
git checkout --track origin/serverfix
git checkout serverfix     
```

Если у вас уже есть локальная ветка и вы хотите настроить её для отслеживания, то воспользуйтесь параметрами `-u` или `--set-upstream-to` для команды `git branch`, чтобы явно установить новое значение. Если вы хотите посмотреть как в системе настроены ветки слежения, воспользуйтесь опцией `-vv` для команды `git branch`.

```sh
git branch -u origin/serverfix         // Настройка слежения текущей ветки
git branch -vv                         // Информация о ветках слежения  
```

---

В `Git` есть два способа внести изменения из одной ветки в другую: `merge` (слияние) и `rebase` (перебазирование). Простейший способ выполнить слияние двух веток - это команда `merge`. Она осуществляет трёхстороннее слияние между двумя последними снимками сливаемых веток и общего родительского снимка , создавая новый коммит.

Есть и другой способ: вы можете взять изменения одной ветки и применить их поверх другой. Это называется перебазированием. С помощью команды `rebase` вы можете взять все коммиты из одной ветки и в том же порядке применить их к другой ветке.

В большинстве случаев нет никакой разницы в конечном результате между слиянием и перебазированием, но перебазирование делает историю коммитов более линейной.

Часто вы будете делать так для уверенности, что ваши коммиты могут быть бесконфликтно слиты в удалённую ветку. Для этого вам следует работать в своей ветке и затем перебазировать вашу работу поверх `origin/master`. Тогда владельцу проекта не придётся делать никакой лишней работы, всё решится бесконфликтным слиянием.

Но даже перебазирование, при всех своих достоинствах, не лишено недостатков:        Не перемещайте коммиты, уже отправленные в публичный репозиторий!

Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаёте новые, похожие на старые, но являющиеся другими. Если другие люди создадут функционал на основе перебазированных коммитов, то им придется заново  выполнять слияние для своих наработок. В итоге, вы получите путаницу.

Одна из точек зрения заключается в том, что история коммитов в вашем репозитории это запись того, что на самом деле произошло. Это исторический документ и его нельзя подделывать. С этой точки зрения не нужно изменять историю коммитов.

Противоположная точка зрения заключается в том, что история коммитов это история того, как был сделан ваш проект. Сторонники этого лагеря считают использование инструментов `rebase` и `filter-branch` способом улучшить историю проекта.

---

Напомним, что `Git` сохраняет изменения в файле в репозитории целиком, что позволяет перемещаться между коммитами командой `git checkout <commit_hesh>`. Узнать хэш коммита можно командой `git log`. Перемещаться между коммитами можно для просмотра удаленных частей кода или восстановления удаленных файлов.

Вообще, откреплять `HEAD` от ветки не рекомендуется, но это можно сделать для восстановления удаленных файлов. Откатываться назад и коммитить там нельзя. Оно получится, но вы не увидите изменений в основной ветке. Перемещение между коммитами сделано только для ознакомления с состоянием файлов в прошлом, а вот перемещение между ветками является базовой и очень полезной фишка `Git`.

```sh
git checkout <commit_hesh>
git switch --detach <commit_hesh>
```

В результате перехода к конкретному коммиту, а не к ветке, вы оказываетесь в состоянии отсоединенного указателя `HEAD` («`detached HEAD state`»). Получается       `HEAD` открепился от известных веток, так что все изменения с этого момента будут формировать новый путь в репозитории. Поэтому система хочет убедиться, что вы именно этого хотите, и в выводе предлагает вам пространство для экспериментов.

[[Git/🟡Base|🟡Base]]