Почти каждая система контроля версий так или иначе поддерживает ветвление. Используя ветвление, вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. Во многих системах контроля версий создание веток  очень затратный процесс, часто требующий   создания новой копии каталога с исходным кодом, что может занять время.

Когда вы делаете коммит, `Git` сохраняет его в виде объекта, который содержит указатель на снимок подготовленных данных. Этот объект так же содержит имя автора, почту, сообщение и указатель на предшествующие коммит или коммиты: отсутствие родителя для первоначального коммита, один родитель для обычного коммита, и несколько родителей для результатов слияния двух и более различных веток.

Предположим, у вас есть каталог с тремя файлами и вы добавляете их все в индекс и создаёте коммит. Во время индексации вычисляется контрольная сумма файлов, затем файлы сохраняются в репозиторий в виде `blob`, а контрольная сумма попадёт в индекс.

![[Pasted image 20240307192230.png]]

Ветка в `Git` это простой перемещаемый указатель на один из таких коммитов. По умолчанию, имя основной ветки  `master`. Как только вы начнёте создавать коммиты, ветка `master` будет всегда указывать на последний коммит. Каждый раз при создании коммита указатель ветки `master` будет передвигаться автоматически.

Что же на самом деле происходит при создании ветки? Всего лишь создаётся новый указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с именем `new_branche`. Вы можете это сделать это действие командой `git branch`. При использовании параметра `-b`, при создании ветки произойдет переключение на нее.

Команда `git branch` без параметров просто выводит список веток. Параметр `-v` выводит информацию о последнем коммите в ветках. Опции `--merged` и `--no-merged` показывают только слитые и не слитые с текущей веткой другие ветки соответственно.
Параметр `-d` удаляет только слитую ветку, а `-D` удаляет любую имеющуюся ветку.

```sh
git branch -v                         // Список веток с коммитами
git branch --merged                   // Список слитых веток
git branch <branch_name>              // Создает ветку
git branch -b <branch_name>           // Создает и переходит в ветку
git branch -d <branch_name>           // Удаляет слитую ветку
```


Как `Git` определяет, в какой ветке вы находитесь? Он хранит указатель `HEAD`, который ссылается на текущую ветку рабочей директории. Для переключения на другую ветку, то есть перемещение указателя `HEAD` выполняется команда `git checkout <name>`.

```sh
git checkout <branch_name>
```

В новых версиях `Git`, вы можете использовать `git switch` вместо `git checkout`, чтобы: Переключиться на существующую ветку и Создать новую ветку и переключиться на неё.

```sh
git switch <branch_name>          // Переключение на ветку
git switch --create <branch_name> // Создать и переключиться на ветку
git switch -                      // Вернуться к предыдущей извлечённой ветке
```

Для переименовании ветки, нужно сначала изменить ее локальное название, затем загрузить изменения на сервер, а потом удалить старую ветку с сервера.

```sh
git branch --move <old_name> <new_name>
git push --set-upstream <server_name> <new_name>
git push <server_name> --delete <old_name>
```

---

Удалённые ссылки  это ссылки в ваших удалённых репозиториях, включая ветки, теги и так далее. Полный список удалённых ссылок можно получить с помощью команды `git ls-remote <remote>` или команды `git remote show <remote>`. Тем не менее, более распространённым способом является использование веток слежения.

Ветки слежения представляют собой ссылки на определённое состояние удалённых веток. Это локальные ветки, которые нельзя перемещать; `Git` перемещает их автоматически при любой коммуникации с удалённым репозиторием.

Имена веток слежения имеют вид `<remote>/<branch>`. Например, если вы хотите посмотреть, как выглядела ветка `master` на сервере `origin` во время последнего соединения с ним, используйте ветку `origin/master`. Если кто-то отправил на сервер ветку `iss53`, при том что у вас может быть своя локальная ветка `iss53`, удалённая ветка будет представлена веткой слежения поименованной как `origin/iss53`.

Для синхронизации ваших изменений с удалённым сервером выполняется команда `git fetch <remote>` . Эта команда извлекает оттуда данные, которых у вас ещё нет, и обновляет локальную базу данных, сдвигая указатели удаленных веток.

Когда вы хотите поделиться веткой, вам необходимо отправить её на удалённый сервер. Ваши локальные ветки автоматически не синхронизируются с удалёнными ветками при отправке, вам нужно явно указать ветки, которые вы хотите отправить.

```sh
git push <remote_name> <branch>           // Обновление ветки branch
git push <remote> <local_b>:<remote_b>    // Полная запись при разных названиях
```

Необходимо отметить, что при получении данных создаются ветки слежения, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку `serverfix` — только указатель `origin/serverfix`, который вы не можете изменять.